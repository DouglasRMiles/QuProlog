<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from main.tex on 30 November 1999 -->
<!-- Edited by Michael Walters on 30 November 1999 -->

<TITLE>
Qu-Prolog 10.6 Reference Manual - Built-in Predicates
</TITLE>
</HEAD>

<BODY>


<!-- Section 3 -->
<H1>
<A NAME="Section3">3 Built-in Predicates</A>
</H1>

<!-- Section 3.1 -->
<H2>
<A NAME="Section3.1">3.1 Introduction</A>
</H2>

<P>This section contains descriptions of the library predicates of Qu-Prolog, grouped by predicate family. The meaning of the terms used may be found in <A HREF="SEC5.html#Section5">Notation</A>.

<P>Many of the predicates described in this section are accompanied with mode information and examples. The mode information of each argument of a predicate is represented by a pair consisting of a mode and a type.

<P>The mode is one of

<UL type="disc">
<LI>
<KBD>-</KBD> : must be a variable at the time of call
<LI>
<KBD>+</KBD> : must be supplied at the time of call
<LI>
<KBD>?</KBD> : may be a variable or supplied at the time of call
<LI>
<KBD>@</KBD> : unchanged by call -- that is, no bindings to variables in the argument
</UL>

<P>The type is one of

<UL type="disc">
<LI>
<KBD>integer</KBD> : an integer			
<LI>
<KBD>float</KBD> : a double precision float			
<LI>
<KBD>atom</KBD> : an atom			
<LI>
<KBD>atomic</KBD> : an atom or integer
<LI>
<KBD>var</KBD> : a variable
<LI>
<KBD>obvar</KBD> : an object variable
<LI>
<KBD>anyvar</KBD> : a variable or object variable
<LI>
<KBD>compound</KBD> : a structure
<LI>
<KBD>gcomp</KBD> : a ground structure
<LI>
<KBD>ground</KBD> : a ground term
<LI>
<KBD>quant</KBD> : a quantified term
<LI>
<KBD>list(Type)</KBD> : a list whose elements have type <KBD>Type</KBD>			
<LI>
<KBD>closed_list(Type)</KBD> : a closed list
<LI>
<KBD>open_list(Type)</KBD> : an open list			
<LI>
<KBD>string</KBD> : a string
<LI>
<KBD>nonvar</KBD> : any term other than a variable
<LI>
<KBD>term</KBD> : any term			
<LI>
<KBD>goal</KBD> : an atom or compound representing a goal.
<LI>
<KBD>stream</KBD> : a term representing a stream
<LI>
<KBD>handle</KBD> : a term representing the handle (address) for messages
</UL>

<P>As an example, the mode information for <KBD>=..</KBD> is

<BR><KBD>mode +nonvar =.. ?closed_list(term)</KBD>
<BR><KBD>mode -nonvar =.. @closed_list(term)</KBD>

<P>The first mode deals with the case where the first argument is a nonvar at the time of call and the second argument will be a closed list of terms by the end of the call. The second mode deals with the case where the first argument is a variable at the time of call (and is instantiated to a nonvar by the end of the call) and the second argument is a closed list of terms that is unchanged by the call.

<!-- Section 3.2 -->
<H2>
<A NAME="Section3.2">3.2 Control</A>
</H2>

<P>This set of predicates provides control for the execution of Qu-Prolog.

<P>Predicates:

<P><KBD><a name=","></a>Goal1 , Goal2</KBD>

<BLOCKQUOTE>
Conjunction. <KBD>Goal1</KBD> and then <KBD>Goal2</KBD>.			
<BR><KBD>mode ','(+goal, +goal)</KBD>

<P>Example:

<KBD>
<P>| ?- A = 10 , B is 2 * A.
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name=";"></a>Goal1 ; Goal2</KBD>

<BLOCKQUOTE>
Disjunction. <KBD>Goal1</KBD> or <KBD>Goal2</KBD>.
<BR><KBD>mode +goal ; +goal</KBD>

<P>Example:

<KBD>
<P>| ?- A = 10 ; B = 20.
<BR>
<BR>A = 10
<BR>B = B;
<BR>
<BR>A = A
<BR>B = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="true"></a>true</KBD>

<BLOCKQUOTE>
Succeed.

<P>Example:

<KBD>
<P>| ?- true.
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="\+"></a>\+ Goal</KBD>

<BLOCKQUOTE>
Negation. If <KBD>Goal</KBD> then fail else succeed.
<BR><KBD>mode \+ +goal</KBD>

<P>Example:

<KBD>
<P>| ?- \+ (10 = 20).
<BR>
<BR>yes
<BR>
<BR>| ?- \+ true.
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="->"></a>Goal1 -&#62; Goal2</KBD>

<BLOCKQUOTE>
If <KBD>Goal1</KBD> then <KBD>Goal2</KBD> else fail.
<BR><KBD>mode +goal -&#62; +goal</KBD>

<P>Example:

<KBD>
<P>| ?- true -&#62; A = 10.
<BR>
<BR>A = 10;
<BR>
<BR>no
<BR>
<BR>| ?- \+ true -&#62; A = 10.
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="->;"></a>Goal1 -&#62; Goal2 ; Goal3</KBD>

<BLOCKQUOTE>
If <KBD>Goal1</KBD> then <KBD>Goal2</KBD> else <KBD>Goal3</KBD>.
<BR><KBD>mode +goal -&#62; +goal ; +goal</KBD>

<P>Example:

<KBD>
<P>| ?- true -&#62; A = 10 ; B = 20.
<BR>
<BR>A = 10
<BR>B = B;
<BR>
<BR>no
<BR>
<BR>| ?- \+ true -&#62; A = 10 ; B = 20.
<BR>
<BR>A = A
<BR>B = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="!"></a>!</KBD>

<BLOCKQUOTE>
The `cut' operator removes all choices from the parent goal and any goals before the cut in the clause.

<P>Example:

<KBD>
<P>| ?- A = 10 , ! ; B = 20.
<BR>
<BR>A = 10
<BR>B = B;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="break"></a>break</KBD>

<BLOCKQUOTE>
Start an invocation of the interpreter. The debugging state is unaffected.  A control-<KBD>D</KBD> exits the break and returns to the previous level.

<P>Example:

<KBD>
<P>| ?- A = 10 , B = 10 , break, C = 15.
<BR>
<BR>[b1] | ?- A = 15.
<BR>
<BR>no
<BR>
<BR>[b1] | ?- A = B.
<BR>
<BR>A = 10
<BR>B = 10;
<BR>
<BR>no
<BR>
<BR>[b1] | ?- C = 20.
<BR>
<BR>C = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="fail"></a>fail</KBD>

<BLOCKQUOTE>
Fail.

<P>Example:

<KBD>
<P>| ?- A = 10, fail ; B = 20
<BR>
<BR>A = A
<BR>B = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="halt"></a>halt</KBD>
<BR><KBD>halt(Integer)</KBD>

<BLOCKQUOTE>
Exit Qu-Prolog with exit code 0 or <KBD>Integer</KBD>.

<P>Example:

<KBD>
<P>| ?- A = 10, halt ; B = 20
</KBD>
<BR>Qu-Prolog exits and returns the user to the system prompt.
</BLOCKQUOTE>

<P><KBD><a name="call"></a>call(Goal)</KBD>

<BLOCKQUOTE>
Execute <KBD>Goal</KBD>. If <KBD>Goal</KBD> has an inline declaration then it will be expanded.
<BR><KBD>mode call(+goal)</KBD>

<P>Example:

<KBD>
<P>| ?- call( (A = 10, B = 20) ).
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD>call(F, A1)</KBD>
<BR><KBD>call(F, A1, A2)</KBD>
<BR><KBD>call(F, A1, A2, A3)</KBD>
<BR><KBD>call(F, A1, A2, A3, A4)</KBD>
<BR><KBD>call(F, A1, A2, A3, A5)</KBD>
<BR><KBD>call(F, A1, A2, A3, A5, A6)</KBD>
<BR><KBD>call(F, A1, A2, A3, A5, A6, A7)</KBD>
<BR><KBD>call(F, A1, A2, A3, A5, A6, A7, A8)</KBD>
<BLOCKQUOTE>
Build a goal with functor <KBD>F</KBD> and the supplied arguments and call that goal.
</BLOCKQUOTE>

<P><KBD><a name="callable"></a>callable(Goal)</KBD>

<BLOCKQUOTE>
The same as <KBD>once((atom(Goal);compound(Goal)))</KBD>.
</BLOCKQUOTE>

<P><KBD><a name="initialization"></a>initialization(Goal)</KBD>

<BLOCKQUOTE>
The same as <KBD>call(Goal)</KBD>.
It is included for compatibility with the ISO standard.
</BLOCKQUOTE>
<P><KBD><a name="call_predicate"></a>call_predicate(Goal)</KBD>
<BR><KBD>call_predicate(Goal,Arg1)</KBD>
<BR><KBD>call_predicate(Goal,Arg1,Arg2)</KBD>
<BR><KBD>call_predicate(Goal,Arg1,Arg2,Arg3)</KBD>
<BR><KBD>call_predicate(Goal,Arg1,Arg2,Arg3,Arg4)</KBD>

<BLOCKQUOTE>
Execute <KBD>Goal</KBD> with the required arguments. This is more direct than using <KBD><a href="#call">call</a>(Goal)</KBD> and, from the point of view of the debugger, behaves like compiled code. Note that <KBD>Goal</KBD> can be higher-order, that is, <KBD>Goal</KBD> can include arguments.
<BR><KBD>mode call_predicate(+goal, +term, ...)</KBD>

<P>Example:

<KBD>
<P>| ?- call_predicate(=, A, 10).
<BR>
<BR>A = 10;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="repeat"></a>repeat</KBD>

<BLOCKQUOTE>
Succeeds repeatedly.

<P>Example:

<KBD>
<P>| ?- A = 10, repeat, B = 20.
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>...
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="once"></a>once(Goal)</KBD>

<BLOCKQUOTE>
Execute the <KBD>Goal</KBD> and discard any generated alternatives.			
<BR><KBD>mode once(+goal)</KBD>

<P>Example:

<KBD>
<P>| ?- once( (A = 10, repeat, B = 20) ).
<BR>
<BR>A = 10
<BR>B = 20;
<BR>
<BR>no
<BR>
<BR>| ?- once( (A = 10 ; B = 20) ).
<BR>
<BR>A = 10
<BR>B = B;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="catch"></a>catch(Goal1, Template, Goal2)</KBD>

<BLOCKQUOTE>
Set a trap for <KBD>Template</KBD> during the execution of <KBD>Goal1</KBD>. <KBD>Goal2</KBD> is executed when a term that unifies with <KBD>Template</KBD> is thrown.
<BR><KBD>catch/3</KBD> and <KBD>throw/1</KBD> are typically used for error handling.
<BR><KBD>mode catch(+goal, +term, +goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="throw"></a>throw(Template)</KBD>

<BLOCKQUOTE>
Throw <KBD>Template</KBD> to the innermost matching <KBD>catch/3</KBD>.
<BR><KBD>mode throw(+term)</KBD>

<P>Example:

<P>Consider an application that carries out complex processing and may exit at various points within this processing. One way of programming this behaviour is by using <KBD>catch</KBD> at the top level of the application as given below.

<P><KBD>main(Args) :- </KBD>
<BR> <KBD>&nbsp;&nbsp;&nbsp;&nbsp;catch(process(Args), exit_throw(Msg), write(Msg)).</KBD>

<DT>
<P>When the application is started, <KBD>process(Args)</KBD> is executed with a trap set that will write a message when an <KBD>exit_throw(Msg)</KBD> is thrown.

<P>The application can exit at a given point within the execution of <KBD>process(Args)</KBD> by making a call such as		

<P><KBD>throw(exit_throw('this is my exit message'))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="unwind_protect"></a>unwind_protect(Goal1, Goal2)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Goal1</KBD> succeeds.  <KBD>Goal2</KBD> is executed after <KBD>Goal1</KBD>, even if <KBD>Goal1</KBD> fails or exits non-locally. <KBD>Goal2</KBD> is called for its side effects only, and any bindings it makes are ignored.  Note that it is not currently possible to protect against <KBD><a href="#halt">halt/0</a></KBD> or against <KBD>SIGKILL</KBD> signal from the operating system.
<BR><KBD>mode unwind_protect(+goal, +goal)</KBD>

<P>Example:

<P>Assume that a goal <KBD>p</KBD> is to be executed in an environment where the fact <KBD>fact(a,b)</KBD> is added to the dynamic database. Further assume that this fact is to be removed when the execution of <KBD>p</KBD> finishes with success or failure or because of a <KBD><a href="#throw">throw/1</a></KBD> within <KBD>p</KBD>, assuming that <KBD>fact(a,b)</KBD> is the only clause for <KBD>fact/2</KBD>, this can be achieved with the call
<BR><KBD>unwind_protect((assert(fact(a,b)), p), retract(fact(a,b)))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="setup_call_cleanup"></a>setup_call_cleanup(Goal0, Goal1, Goal2)</KBD>
 <BLOCKQUOTE>
First calls <KBD>Goal0</KBD> deterministically then 
 calls <KBD>Goal1</KBD> and whenever this call fails or succeeds deterministically,
 then <KBD>Goal2</KBD> is called. It is similar to <KBD>unwind_protect</KBD>. The main difference is that <KBD>unwind_protect</KBD> is called on success
 (even if choice points remain) whereas <KBD>call_cleanup</KBD> is called
 on success only when <KBD>Goal1</KBD> has no more choices.

</BLOCKQUOTE>
<P><KBD><a name="call_cleanup"></a>call_cleanup(Goal1, Goal2)</KBD>
 <BLOCKQUOTE>
The same as <KBD>setup_call_cleanup(true, Goal1, Goal2)</KBD>
</BLOCKQUOTE>

<H2>
<A NAME="Section3.3">3.3 Input / Output</A>
</H2>

<H3>
<A NAME="Section3.3.1" >3.3.1 File and Stream Handling</A>
</H3>

<P>Streams are the basic input/output management units.  
They provide a uniform interface to files and strings.  
Each stream can be opened for reading or writing, and data is sent through 
the stream using term or character input/output predicates.  
String streams behave in the same way as file streams.  

<P>Rather than having a file attached to the stream, 
a string stream is connected to an atom or a list of <KBD>CharCode</KBD>. 
If the string stream is opened for writing, any further writing to the 
stream is not possible after the successful execution of 
<KBD><a href="#stream_to_atom">stream_to_atom/2</a></KBD>,
<KBD><a href="#stream_to_string">stream_to_string/2</a></KBD> or
<KBD><a href="#stream_to_chars">stream_to_chars/2</a></KBD> 
as these predicates close the stream.

<P>If the process is registered with Pedro then it is possible to open
a message stream for either reading or writing.

<P>A term representing a stream is an
integer (the stream ID)
generated by a call to <KBD><a href="#open">open/[3,4]</a></KBD> 
or one of the atoms <KBD>stdin</KBD>, <KBD>user_input</KBD>, 
<KBD>stdout</KBD>, <KBD>user_output</KBD>, <KBD>stderr</KBD> 
and <KBD>user_error</KBD>, or an atom declared by the user
as an alias for a stream.

<P>Predicates:
<P><KBD><a name="stat"></a>stat(File, Info)</KBD>
<BLOCKQUOTE>
<KBD>Info</KBD> is a structure of the form <KBD>stat(LastModified, Size)</KBD>
and represents the last time of modification and size of <KBD>File</KBD>.
<BR><KBD>mode stat(@atom, ?structure)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="access"></a>access(File, Permission, Result)</KBD>

<BLOCKQUOTE>
<KBD>Integer</KBD> contains the result of <KBD>Permission</KBD> 
check for <KBD>File</KBD>.  
<KBD>Permission</KBD> is an integer made up of mask bits 0,1,2,4
and is used to test if the file exists, and has execute, write and 
read permissions. <KBD>Result</KBD> is <KBD>0</KBD> if the file passes the test and <KBD>-1</KBD> if it fails. The usage is identical to the Unix system call <KBD>access(2)</KBD>.
<BR> So, for example, <KBD>access(File, 3, 0)</KBD> will succeed if the file is readable and writable.
<BR><KBD>mode access(@atom, @integer, ?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open"></a>open(File, Mode, Stream)</KBD>
<BR><KBD>open(File, Mode, Stream, OptionList)</KBD>

<BLOCKQUOTE>
<KBD>Stream</KBD> is the stream resulting from opening <KBD>File</KBD> with the given <KBD>Mode</KBD> and <KBD>OptionList</KBD>.			

<P>Modes:

<UL type="disc">
<LI>
<KBD>read</KBD> - Input
<LI>
<KBD>write</KBD> - Output
<LI>
<KBD>append</KBD> - Output
</UL>

<P>Options:

<UL type="disc">
<LI>
<KBD>type(Value)</KBD>
<BR><KBD>text</KBD> or <KBD>binary</KBD> stream. 
<BR>(Default: <KBD>text</KBD>.)
<LI>
<KBD>reposition(Boolean)</KBD>
<BR>Reposition the stream. 
<BR>(Default: <KBD>false</KBD>.)
<LI>
<KBD>eof_action(Value)</KBD>
<BR>Action when read past EOF: <KBD>error</KBD>, <KBD>eof_code</KBD>, <KBD>reset</KBD>.
<BR>(Default: <KBD>error</KBD>.)
</UL>

<BR><KBD>mode open(@atom, @atom, -stream)</KBD>
<BR><KBD>mode open(@atom, @atom, -stream, @closed_list(gcomp))</KBD>

<P>Example:

<KBD>
<P>| ?- open(filename, write, Stream), 
<BR>write_term_list(Stream, [wqa('Hello World'), pc(0'.), nl]), 
<BR>close(Stream).
<BR>
<BR>Stream = 3
<BR>
<BR>| ?- open(filename, append, Stream), 
<BR>write_term_list(Stream, [wqa('Bye'), pc(0'.), nl]), 
<BR>close(Stream).
<BR>
<BR>Stream = 3
<BR>
<BR>| ?- open(filename, read, Stream), 
<BR>read(Stream, Term1), 
<BR>read(Stream, Term2).
<BR>
<BR>Stream = 3
<BR>Term1 = Hello World
<BR>Term2 = Bye
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_string"></a>open_string(StringMode, Stream)</KBD>
<BR><KBD>open_string(StringMode, Stream, OptionList)</KBD>

<BLOCKQUOTE>
<KBD>Stream</KBD> is the stream resulting from opening the string with the given <KBD>StringMode</KBD> and <KBD>OptionList</KBD>.  Possible value for  <KBD>OptionList</KBD> is explained in <KBD><a href="#open">open/4</a></KBD>.

The possible values for <KBD>StringMode</KBD> are 

<UL type="disc">
<LI>
<KBD>write</KBD> - Output
<LI>
<KBD>read(Atom)</KBD> - Input obtained from the <KBD>Atom</KBD>
<LI>
<KBD>read(String)</KBD> - Input obtained from the <KBD>String</KBD>
<LI>
<KBD>read(CharCodeList)</KBD> - Input obtained from the <KBD>CharCodeList</KBD>
</UL>

<BR><KBD>mode open_string(@ground, -stream)</KBD>
<BR><KBD>mode open_string(@ground, -stream, +closed_list(gcomp))</KBD>

<P>Example:

<KBD>
<P>| ?- open_string(write, Stream),
<BR>write_term_list(Stream, [wqa('Hello World'), pc(0'.), nl]),
<BR>stream_to_atom(Stream, Atom).
<BR>
<BR>Stream = 3
<BR>Atom = 'Hello World'.
<BR>
<BR>| ?- open_string(read('p(X,Y).'), Stream), 
<BR>read(Stream, Term).
<BR>
<BR>Stream = 3
<BR>Term = p(B, A)
<BR>
<BR>| ?- open_string(read("p(X,Y)."), Stream), 
<BR>read(Stream, Term).
<BR>
<BR>Stream = 3
<BR>Term = p(B, A)
</KBD>
</BLOCKQUOTE>



<P><KBD><a name="open_msgstream"></a>open_msgstream(Handle, Mode, Stream)</KBD>

<BLOCKQUOTE>
This predicate opens a stream with <KBD>Mode</KBD> for an address given 
by the handle <KBD>Handle</KBD>. If the stream is opened for reading 
then messages from the sender should be of the form
<BR>
<KBD>p2pmsg('':myname@mymachine, Handle, msg)</KBD>
<BR>
where <KBD>myname</KBD> and <KBD>mymachine</KBD> are respectively
the name of this process and the machine on which this process
is running. <KBD>Handle</KBD> is the handle specified when opening the
stream. The third argument, <KBD>msg</KBD> should be a string - 
it is appended to a stream buffer that can then be read from using the 
Qu-Prolog input predicates. Messages from this address are ignored
by the predicates that look at the message buffer such as <KBD>ipc_peek</KBD>.

<P> If the stream is opened for writing then when the stream is flushed,
the contents of the stream buffer is wrapped into a message of the form
<BR>
<KBD>p2pmsg(Handle, MyHAndle, msg)</KBD>
<BR>
<P> For most applications the message sends and receives are more appropriate
but for interacting with GUI's it is sometimes more convenient to use streams.
The <KBD>xqpdebug</KBD> GUI uses this mechanism.
</BLOCKQUOTE>

<P><KBD><a name="set_std_stream"></a>set_std_stream(StreamNo, Stream)</KBD>

<BLOCKQUOTE>
This predicate resets one of the standard streams given by <KBD>StreamNo</KBD>
to <KBD>Stream</KBD>. <KBD>StreamNo</KBD> must be 0,1 or 2 (stdin,stdout,stderr).
<P> This is used in combination with <KBD>open_msgstream</KBD> in the 
<KBD>xqpdebug</KBD> GUI
so that reads and writes in the debugger become reads and writes via the GUI. 
This allows the GUI to behave in a transparent way with respect
to IO.
</BLOCKQUOTE>

<P><KBD><a name="reset_std_stream"></a>reset_std_stream(StreamNo)</KBD>

<BLOCKQUOTE>
Reset the supplied standard stream.
</BLOCKQUOTE>

<P><KBD><a name="close"></a>close(Stream)</KBD>
<BR><KBD>close(Stream, OptionList)</KBD>

<BLOCKQUOTE>
Close the given <KBD>Stream</KBD>. The only possible kind of term in <KBD>OptionList</KBD> is

<UL type="disc">
<LI>
<KBD> force(Value)</KBD>
<BR>If <KBD>Value</KBD> is true then close the stream even when there is an error condition.
<BR>(Default: false.)
</UL>

<BR><KBD>mode close(@stream)</KBD>
<BR><KBD>mode close(@stream, @closed_list(gcomp))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="at_end_of_stream"></a>at_end_of_stream</KBD>
<BR><KBD>at_end_of_stream(Stream)</KBD>

<BLOCKQUOTE>
Succeed if at the end of <KBD>Stream</KBD> or the current input stream.
<BR><KBD>mode at_end_of_stream(@stream)</KBD>

<P>Example:

<KBD>
<P>| ?- open(filename, write, Stream), 
<BR>write_term_list(Stream, [wqa('Hello World'), pc(0'.), nl]), 
<BR>write_term_list(Stream, [wqa('Bye'), pc(0'.), nl]), 
<BR>close(Stream).
<BR>
<BR>Stream = 3
<BR>
<BR>| ?- open(filename, read, Stream),
<BR>at_end_of_stream(Stream), 
<BR>close(ReadStream).
<BR>
<BR>no
<BR>
<BR>| ?- open(filename, read, Stream), 
<BR>read(Stream, Term1), 
<BR>read(Stream, Term2),
<BR>at_end_of_stream(Stream).
<BR>
<BR>Stream = 3
<BR>Term1 = Hello World
<BR>Term2 = Bye
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="current_input"></a>current_input(Stream)</KBD>

<BLOCKQUOTE>
The current input stream is <KBD>Stream</KBD>.
<BR><KBD>mode current_input(?stream)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="set_input"></a>set_input(Stream)</KBD>

<BLOCKQUOTE>
Change the current input stream to <KBD>Stream</KBD>. The initial stream is <KBD>user_input</KBD>.
<BR><KBD>mode set_input(@stream)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- open(filename, read, Stream), 
<BR>set_input(Stream), 
<BR>current_input(Input), 
<BR>read(Term1), read(Term2), 
<BR>set_input(stdin).
<BR>
<BR>Stream = 3
<BR>Input = 3
<BR>Term1 = Hello World
<BR>Term2 = Bye
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="see"></a>see(File)</KBD>

<BLOCKQUOTE>
Open <KBD>File</KBD> for reading and change the current input stream to <KBD>File</KBD>.
<BR><KBD>mode see(@atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- see(filename), 
<BR>seeing(File), 
<BR>read(Term1), read(Term2), 
<BR>seen.
<BR>
<BR>File = filename
<BR>Term1 = Hello World
<BR>Term2 = Bye
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="seeing"></a>seeing(File)</KBD>

<BLOCKQUOTE>
Return the file name of the current input stream.			
<BR><KBD>mode seeing(?atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="seen"></a>seen</KBD>

<BLOCKQUOTE>
Close the current input stream. Change the stream to <KBD>user_input</KBD>.
</BLOCKQUOTE>

<P><KBD><a name="current_output"></a>current_output(Stream)</KBD>

<BLOCKQUOTE>
The current output stream is <KBD>Stream</KBD>.
<BR><KBD>mode current_output(?stream)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="set_output"></a>set_output(Stream)</KBD>

<BLOCKQUOTE>
Change the current output stream to <KBD>Stream</KBD>. The initial stream is <KBD>user_output</KBD>.
<BR><KBD>mode set_output(@stream)</KBD>

<P>Example:

<KBD>
<P>| ?- open_string(write, Stream),
<BR>set_output(Stream),
<BR>current_output(Output),
<BR>write_term_list([wqa('Hello World'), pc(0'.), nl]),
<BR>stream_to_atom(Stream, Atom),
<BR>set_output(stdout).
<BR>
<BR>Stream = 3
<BR>Output = 3
<BR>Atom = 'Hello World'.
</KBD>


</BLOCKQUOTE>

<P><KBD><a name="tell"></a>tell(File)</KBD>

<BLOCKQUOTE>
Open <KBD>File</KBD> for writing and change the current output stream to <KBD>File</KBD>.
<BR><KBD>mode tell(@atom)</KBD>

<P>Example:

<KBD>
<P>| ?- tell(filename), 
<BR>telling(File),
<BR>write_term_list(Stream, [wqa('Hello World'), pc(0'.), nl]), 
<BR>write_term_list(Stream, [wqa('Bye'), pc(0'.), nl]), 
<BR>told.
<BR>
<BR>File = filename
<BR>
<BR>| ?- open(filename, read, Stream), 
<BR>read(Stream, Term1), 
<BR>read(Stream, Term2).
<BR>
<BR>Stream = 3
<BR>Term1 = Hello World
<BR>Term2 = Bye
</KBD>

</BLOCKQUOTE>

<P><KBD><a name="telling"></a>telling(File)</KBD>

<BLOCKQUOTE>
Return the file name of the current output stream.
<BR><KBD>mode telling(@atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="told"></a>told</KBD>

<BLOCKQUOTE>
Close the current output stream. Change the stream to <KBD>user_output</KBD>.
</BLOCKQUOTE>

<P><KBD><a name="flush_output"></a>flush_output</KBD>
<BR><KBD>flush_output(Stream)</KBD>

<BLOCKQUOTE>
Flush <KBD>Stream</KBD> or the current output stream.  Forces a write on any remaining output to the stream.
</BLOCKQUOTE>

<P><KBD><a name="set_autoflush"></a>set_autoflush(Stream)</KBD>

<BLOCKQUOTE>
Set <KBD>Stream</KBD> to automatically flush after each token is written.
This is useful for streams that are to behave like standard error.
(The default for streams is to flush only at a newline or at an explicit call
to <KBD>flush_output</KBD>.)
</BLOCKQUOTE>


<P><KBD><a name="set_stream_position"></a>set_stream_position(Stream, N)</KBD>

<BLOCKQUOTE>
Move <KBD>Stream</KBD> to the position <KBD>N</KBD>. The reposition flag must have been set when <KBD>Stream</KBD> was opened.
<BR><KBD>mode set_stream_position(@stream, @integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="stream_property"></a>stream_property(Stream, Property)</KBD>

<BLOCKQUOTE>
A property of <KBD>Stream</KBD> is <KBD>Property</KBD>. The possible values for <KBD>Property</KBD> are given below.

<UL type="disc">
<LI>
<KBD>alias(Value)</KBD>
<BR>Alias name.
<LI>
<KBD>end_of_stream(Value)</KBD>
<BR><KBD>no</KBD>, <KBD>at</KBD>, <KBD>past</KBD> end of stream.				
<LI>
<KBD>eof_action(Value)</KBD>
<BR>EOF action defined in <KBD><a href="#open">open/[3,4]</a></KBD>.
<LI>
<KBD>file_name(Value)</KBD>
<BR>File Name.
<LI>
<KBD>input</KBD>
<BR>Input Stream.
<LI>
<KBD>line_number(Value)</KBD>
<BR>Line number for input stream.
<LI>
<KBD>mode(Value)</KBD>
<BR><KBD><a href="#open">open/[3,4]</a></KBD> mode.
<LI>
<KBD>output</KBD>
<BR>Output Stream.
<LI>
<KBD>position(Value)</KBD>
<BR>Position.
<LI>
<KBD>reposition(Value)</KBD>
<BR>Reposition of stream.
<LI>
<KBD>type(Value)</KBD>
<BR>Type of stream.
</UL>
<BR><KBD>mode stream_property(@stream, ?compound)</KBD>

<P>Example:

<KBD>
<P>| ?- open(filename, write, Stream), 
<BR>stream_property(Stream, file_name(Value)).
<BR>
<BR>Stream = 3
<BR>Value = filename
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="stream_to_atom"></a>stream_to_atom(Stream, Atom)</KBD>

<BLOCKQUOTE>
<KBD>Stream</KBD> specifies the output string stream where <KBD>Atom</KBD> can be obtained.  When this predicate terminates successfully the stream is closed and any further writing to the stream is not possible.
<BR><KBD>mode stream_to_atom(@stream, -atom)</KBD>

<P>Example:

<KBD>
<P>| ?- open_string(write, Stream),
<BR>write(Stream, Hello),
<BR>write(Stream, ' '),
<BR>write(Stream, World),
<BR>stream_to_atom(Stream, Atom).
<BR>
<BR>Stream = 3
<BR>Hello = Hello
<BR>World = World
<BR>Atom = Hello World
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="stream_to_string"></a>stream_to_string(Stream, String)</KBD>

<BLOCKQUOTE>
<KBD>Stream</KBD> specifies the output string stream where <KBD>String</KBD> can be obtained.  When this predicate terminates successfully the stream is closed and any further writing to the stream is not possible.
<BR><KBD>mode stream_to_string(@stream, -string)</KBD>

<P>Example:
<KBD>
<P>| ?- open_string(write, Stream),
<BR>write(Stream, Hello),
<BR>write(Stream, ' '),
<BR>write(Stream, World),
<BR>stream_to_string(Stream, String).
<BR>
<BR>Stream = 3
<BR>Hello = Hello
<BR>World = World
<BR>String = "Hello World"

</KBD>
</BLOCKQUOTE>

<P><KBD><a name="stream_to_chars"></a>stream_to_chars(Stream, CharCodeList)</KBD>

<BLOCKQUOTE>
<KBD>Stream</KBD> specifies the output string stream where <KBD>CharCodeList</KBD> can be obtained.  When this predicate terminates successfully the stream is closed and any further writing to the stream is not possible.
<BR><KBD>mode stream_to_chars(@stream, -closed_list(integer))</KBD>

<P>Example:

<KBD>
<P>| ?- open_string(write, Stream),
<BR>write(Stream, Hello),
<BR>write(Stream, ' '),
<BR>write(Stream, World),
<BR>stream_to_chars(Stream, Chars).
<BR>
<BR>Stream = 3
<BR>Hello = Hello
<BR>World = World
<BR>Chars = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
</KBD>
</BLOCKQUOTE>

<P>An example of the use of string streams is for determining where information will appear in output to a user interface. The following definitions may be used to retrieve the character positions of matching bracket pairs of a supplied term (assuming the character position of the first character of the term is in position one).

<KBD>		
<P><DT>brackets(Term, Brackets) :-
<DD>open_string(write, Stream),
<DD>write(Stream, Term),
<DD>stream_to_chars(Stream, CharList),
<DD>match_brackets(CharList, 1, [], Brackets).

<DT>match_brackets([], _, _, []).
<DT>match_brackets([C|Rest], CurrPos, LeftBr, Brackets) :-
<DD>NewCurrPos is CurrPos + 1,
<DD>( C = 0'(    % open bracket
<DD>&nbsp; -&#62;
<DD>&nbsp; &nbsp; match_brackets(Rest, NewCurrPos, [CurrPos|LeftBr], Brackets)
<DD>&nbsp; ;
<DD>&nbsp; C = 0')    % close bracket
<DD>&nbsp; -&#62;
<DD>&nbsp; &nbsp; LeftBr = [LBPos|LBRest],
<DD>&nbsp; &nbsp; Brackets = [(LBPos - CurrPos)|Brackets1],
<DD>&nbsp; &nbsp; match_brackets(Rest, NewCurrPos, LBRest, Brackets1)
<DD>&nbsp; ;
<DD>&nbsp; &nbsp; match_brackets(Rest, NewCurrPos, LeftBr, Brackets)
<DD>).
<DT>
</KBD>		

<P>Given the above definitions, the system will behave as follows.

<KBD>		
<P>| ?- brackets(f(XYZ, g(a, XYZ), h(b)),B).
<BR>
<BR>XYZ
<BR>B = [9 - 16, 20 - 22, 2 - 23]; 
<BR>
<BR>no
<BR>
<BR>| ?- write(f(XYZ, g(a, XYZ), h(b))).
<BR>
<BR>f(XYZ, g(a, XYZ), h(b))
<BR>XYZ = XYZ;
<BR>
<BR>no
</KBD>

<P><KBD><a name="get_open_streams"></a>get_open_streams(Streams)</KBD>

<BLOCKQUOTE>
Retrieve a list of all the current open streams.
</BLOCKQUOTE>

<!-- Section 3.3.2 -->
<H3>
<A NAME="Section3.3.2">3.3.2 Term Input/Output</A>
</H3>

<P>For input/output predicates, if the stream is specified explicitly, the stream appears as the first argument.  Otherwise, the current input/output stream is assumed.

<P>Qu-Prolog supports multiple operator tables and object variable prefix tables. At any time, there is one active operator table and one active object variable prefix table.  Active tables can be changed and new tables can be created by <KBD><a href="#op_table">op_table/1</a></KBD> and <KBD><a href="#obvar_prefix_table">obvar_prefix_table/1</a></KBD>. When a new operator table is created, the comma `<KBD>,</KBD>' operator is automatically declared. An inheritance mechanism is also available for operator tables.  The input/output predicates can use a table other than the current active table by specifying the name of the table in the <KBD>OptionList</KBD>.

<P>The input/output predicates are enhanced with the ability to remember the association between the ASCII representation and the internal representation for both meta and object variables over multiple input/output operations.  This enables the user to refer to the same variable over a number of input/output operations, and is useful in applications with interactive environments, such as interactive theorem provers.  The association is not remembered for any variable that begins with an underscore (`<KBD>_</KBD>').

<P>Qu-Prolog supports high-speed input/output using byte-encoded Qu-Prolog terms. Byte-encoded terms are written with <KBD><a href="#encoded_write_term">encoded_write_term/3</a></KBD> and read with <KBD><a href="#encoded_read_term">encoded_read_term/3</a></KBD>. The compiler can accept byte-encoded files as input and generates some intermediate files in this form (see the online manual qc(1) for further details).  <KBD><a href="#consult">consult/1</a></KBD> also accepts such files as input. The system is supplied with a decoder for byte-encoded terms (see the online manual qecat(1) for further details).

<P>Predicates:

<P><KBD><a name="op_table"></a>op_table(Table)</KBD>

<BLOCKQUOTE>
Retrieve or change the current operator table.  The initial table is <KBD>user</KBD>.  Each new table is initialised with a comma `<KBD>,</KBD>' when it is first created.
<BR><KBD>mode op_table(?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- op_table(Table).
<BR>
<BR>Table = user;
<BR>
<BR>no
<BR>
<BR>| ?- op_table(mine).
<BR>
<BR>yes
<BR>
<BR>| ?- op_table(Table).
<BR>
<BR>Table = mine;
<BR>
<BR>no  
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="op_table_inherit"></a>op_table_inherit(Table1, Table2)</KBD>

<BLOCKQUOTE>
<KBD>Table1</KBD> inherits all the operators declared in <KBD>Table2</KBD>. These operators do not include the ones which are inherited by <KBD>Table2</KBD> from a third table. That is, inheritance is non-transitive.
<BR><KBD>mode op_table_inherit(@atom, @atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- op_table_inherit(mine, user).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="current_op"></a>current_op(Precedence, Associativity, Operator)</KBD>
<BR><KBD>current_op(Table, Precedence, Associativity, Operator)</KBD>

<BLOCKQUOTE>
<KBD>Operator</KBD> is an operator in <KBD>Table</KBD> 
<BR>(default: the current operator table) with <KBD>Precedence</KBD> and <KBD>Associativity</KBD>.
<BR><KBD>mode current_op(?integer, ?atom, ?atom)</KBD>
<BR><KBD>mode current_op(@atom, ?integer, ?atom, ?atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- current_op(700, Assoc, Op).
<BR>
<BR>Assoc = xfx
<BR>Op = =;
<BR>
<BR>Assoc = xfx
<BR>Op = \=;
<BR>
<BR>Assoc = xfx
<BR>Op = ?=;
<BR>
<BR>Assoc = xfx
<BR>Op = ==
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="op"></a>op(Precedence, Associativity, Operator)</KBD>
<BR><KBD>op(Table, Precedence, Associativity, Operator)</KBD>

<BLOCKQUOTE>
Declare <KBD>Operator</KBD> with <KBD>Precedence</KBD> and <KBD>Associativity</KBD> as an operator in <KBD>Table</KBD> or in the current operator table. <KBD>Precedence</KBD> is any number between 0 and 1200, where higher numbers given lower precedence (loose binding).

<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>fx</KBD></TD>
<TD>Prefix. Argument has lower precedence than operator.</TD>
</TR>
<TR>
<TD><KBD>fy</KBD></TD>
<TD>Prefix. Argument has the same precedence as operator.</TD>
</TR>
<TR>
<TD><KBD>quant</KBD></TD>
<TD>Quantifier. Argument has the same precedence as operator.</TD>
</TR>
<TR>
<TD><KBD>xfx</KBD></TD>
<TD>Infix. Not associative.</TD>
</TR>
<TR>
<TD><KBD>xfy</KBD></TD>
<TD>Infix. Right associative.</TD>
</TR>
<TR>
<TD><KBD>yfx</KBD></TD>
<TD>Infix. Left associative.</TD>
</TR>
<TR>
<TD><KBD>xf</KBD></TD>
<TD>Postfix. Argument has lower precedence than operator.</TD>
</TR>
<TR>
<TD><KBD>yf</KBD></TD>
<TD>Postfix. Argument has the same precedence as operator.</TD>
</TR>
</TABLE>

<P>If <KBD>Precedence</KBD> is 0, any previous declaration is removed.

<BR><KBD>mode op(@integer, @atom, @atom)</KBD>
<BR><KBD>mode op(@atom, @integer, @atom, @atom)</KBD>

<P>Example: (Continued from last):

<KBD>
<P>| ?- op(0, yfx, '+').
<BR>
<BR>yes
<BR>
<BR>| ?- current_op(Prec, Assoc, '+').
<BR>
<BR>Prec = 200
<BR>Assoc = fy;
<BR>
<BR>no   
<BR>
<BR>| ?- op(500, yfx, '+').
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="obvar_prefix_table"></a>obvar_prefix_table(Table)</KBD>

<BLOCKQUOTE>
Retrieve or change the current object variable prefix table. The initial table is <KBD>user</KBD>.
<BR><KBD>mode obvar_prefix_table(?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- obvar_prefix_table(Table).
<BR>
<BR>Table = user;
<BR>
<BR>no
<BR>
<BR>| ?- obvar_prefix_table(mine).
<BR>
<BR>yes
<BR>
<BR>| ?- obvar_prefix_table(Table).
<BR>
<BR>Table = mine;
<BR>
<BR>no  
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="current_obvar_prefix"></a>current_obvar_prefix(Atom)</KBD>
<BR><KBD>current_obvar_prefix(Table, Atom)</KBD>

<BLOCKQUOTE>
<KBD>Atom</KBD> is an object variable prefix in <KBD>Table</KBD>
<BR> (default: the current object variable prefix table).
<BR><KBD>mode current_obvar_prefix(?atom)</KBD>
<BR><KBD>mode current_obvar_prefix(@atom, ?atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- current_obvar_prefix(Atom).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="obvar_prefix"></a>obvar_prefix(AtomList)</KBD>
<BR><KBD>obvar_prefix(Table, AtomList)</KBD>

<BLOCKQUOTE>
Declares all the atoms in <KBD>AtomList</KBD> as object variable prefixes in <KBD>Table</KBD> or the current object variable prefix table. This also implicitly declares all variant names produced by extending the variable name with a combination of underscores and sequences of digits and letters.  The name of the constant being declared as an object variable prefix must be made up of lower case letters. 
<BR><KBD>mode obvar_prefix(@closed_list(atom))</KBD>
<BR><KBD>mode obvar_prefix(@atom)</KBD>
<BR><KBD>mode obvar_prefix(@atom, @closed_list(atom))</KBD>
<BR><KBD>mode obvar_prefix(@atom, @atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- obvar_prefix(a).
<BR>
<BR>yes
<BR>
<BR>| ?- obvar_prefix(user, [x , y , z]).
<BR>
<BR>yes
<BR>
<BR>| ?- current_obvar_prefix(Atom).
<BR>
<BR>A = a;
<BR>
<BR>no
<BR>
<BR>| ?- current_obvar_prefix(user, Atom).
<BR>
<BR>A = x;
<BR>
<BR>A = y;
<BR>
<BR>A = z;
<BR>
<BR>no
</KBD>

</BLOCKQUOTE>

<P><KBD><a name="remove_obvar_prefix"></a>remove_obvar_prefix(Atom)</KBD>
<BR><KBD>remove_obvar_prefix(Table, Atom)</KBD>

<BLOCKQUOTE>
Remove the object variable prefix specified by <KBD>Atom</KBD> from <KBD>Table</KBD> or the current object variable prefix table.
<BR><KBD>mode remove_obvar_prefix(@atom)</KBD>
<BR><KBD>mode remove_obvar_prefix(@atom, @atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- remove_obvar_prefix('a').
<BR>
<BR>yes
<BR>
<BR>| ?- remove_obvar_prefix(user, 'z').
<BR>
<BR>yes
<BR>
<BR>| ?- current_obvar_prefix(Atom).
<BR>
<BR>no
<BR>
<BR>| ?- current_obvar_prefix(user, Atom).
<BR>
<BR>A = x;
<BR>
<BR>A = y;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="obvar_name_to_prefix"></a>obvar_name_to_prefix(Atom, Atom)</KBD>

<BLOCKQUOTE>
Strips any trailing numbers or underscores from the first Atom and unifies the result with the second Atom. This predicate does not actually check whether the computed prefix is, in fact, a current object variable prefix. It is merely provided for convenience.
<BR><KBD>mode obvar_name_to_prefix(@atom, ?atom)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- obvar_name_to_prefix('!_a_1', A).
<BR>
<BR>A = !_a;
<BR>
<BR>no
<BR>
<BR>| ?- obvar_name_to_prefix('y_28_1_3', A).
<BR>
<BR>A = y;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="set_obvar_name"></a>set_obvar_name(ObVar, Name)</KBD>

<BLOCKQUOTE>
Set <KBD>ObVar</KBD> to have the base name <KBD>Name</KBD>. A suffix will be added to <KBD>Name</KBD> to complete the final name for <KBD>ObVar</KBD>.  If <KBD>ObVar</KBD> has a name already, the predicate fails.  See <KBD><a href="#obvar_prefix">obvar_prefix/[1,2]</a></KBD>.
<BR><KBD>mode set_obvar_name(+obvar, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- set_obvar_name(!_y_3, x).
<BR>
<BR>_y_3 = !x_0;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="set_var_name"></a>set_var_name(Var, Name)</KBD>

<BLOCKQUOTE>
Set <KBD>Var</KBD> to have the base name <KBD>Name</KBD>. A suffix will be added to <KBD>Name</KBD> to complete the final name for <KBD>Var</KBD>.  If <KBD>Var</KBD> has a name already, the predicate fails.
<BR><KBD>mode set_var_name(+obvar, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- set_var_name(_32, 'X').
<BR>
<BR>_32 = X_0;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_var_name"></a>get_var_name(Variable, Name)</KBD>

<BLOCKQUOTE>
<KBD>Variable</KBD> has <KBD>Name</KBD>. Fails if <KBD>Variable</KBD> has no name.
<BR><KBD>mode get_var_name(@anyvar, ?atom)</KBD>

<P>Examples (Assuming x is still a current object variable prefix):

<KBD>
<P>| ?- get_var_name(Max, Name), write(Name), nl, fail.
<BR>Max
<BR>
<BR>no
<BR>
<BR>| ?- get_var_name(_32, Name), write(Name), nl, fail.
<BR>
<BR>no
<BR>
<BR>| ?- get_var_name(!x_3, Name), write(Name), nl, fail.
<BR>x_3
<BR>
<BR>no
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_unnamed_vars"></a>get_unnamed_vars(Term, VarList)</KBD>

<BLOCKQUOTE>
<KBD>VarList</KBD> is the list of unnamed (object) variables in <KBD>Term</KBD>.
<BR><KBD>mode get_unnamed_vars(@term, -closed_list(anyvar))</KBD>

<P>Examples (Assuming x is still a current object variable prefix):

<KBD>
<P>| ?- get_unnamed_vars((A, _Y, !x, !_y), Vars), 
<BR>write(Vars), fail.
<BR>[_117, !_x0]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="name_vars"></a>name_vars(Term)</KBD>
<BR><KBD>name_vars(Term, VarList)</KBD>

<BLOCKQUOTE>
Name all unnamed (object) variables in <KBD>Term</KBD> returning them in <KBD>VarList</KBD>.
<BR><KBD>mode name_vars(+term)</KBD>
<BR><KBD>mode name_vars(+term, -closed_list(anyvar))</KBD>

<P>Example:

<KBD>
<P>| ?-  Term = f(X, _Y, !x, !_x), write(Term) , nl, fail.
<BR>f(X, _F5, !x, !_x0)
<BR>
<BR>no
<BR>
<BR>| ?- Term = f(X, _Y, !x, !_x), name_vars(Term), 
<BR>write(Term), nl, fail.
<BR>f(X, A, !x, !x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="error"></a>error(Term)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to <KBD>user_error</KBD>.
<BR><KBD>mode error(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- error('Hello'), error(' '), error('World').
<BR>Hello World
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="errornl"></a>errornl(Term)</KBD>
<BR><KBD>errornl</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> and a newline to <KBD>user_error</KBD>, or write a newline to <KBD>user_error</KBD>.
<BR><KBD>mode errornl(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- errornl('Hello'), errornl('World').
<BR>Hello
<BR>World
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="read"></a>read(Term)</KBD>
<BR><KBD>read(Stream, Term)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from <KBD>Stream</KBD> or the current input stream.
<BR><KBD>mode read(?term)</KBD>
<BR><KBD>mode read(@stream, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- read(Term), write(Term), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>f(_1A2, _19D, !_x0, !_x1)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="read_term"></a>read_term(Term, OptionList)</KBD>
<BR><KBD>read_term(Stream, Term, OptionList)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from <KBD>Stream</KBD> or the current input stream. <KBD>OptionList</KBD> is a list whose entries are chosen from the items given below.

<OL>
<LI>Input Options
<BR>Input options not mentioned in <KBD>OptionList</KBD> take on their default values.

<UL type="disc">
<LI>
	<KBD>remember_name(Value)</KBD>
	<BR>Remember the names for all the variables other than those beginning with an underscore in <KBD>Term</KBD>.
	<BR>(Default: <KBD>false</KBD>.)
<LI>
	<KBD>op_table(Value)</KBD>
	<BR>Use the operator table given in <KBD>Value</KBD>.
	<BR>(Default: Current table.)
<LI>
	<KBD>obvar_prefix_table(Value)</KBD>
	<BR>Use the object variable prefix table given in <KBD>Value</KBD>.
	<BR>(Default: Current table.)
</UL>

<LI>Output Options.  
<BR>The <KBD>Value</KBD> for each output option is instantiated during the reading of <KBD>Term</KBD>.
<UL type="disc">
<LI>
	<KBD>variables(Value)</KBD>
	<BR>All variables, including anonymous variables, from left to right. 
	<BR>(Default: <KBD>[]</KBD>.) Typically <KBD>Value</KBD> is a variable that is bound to the list of variables appearing in the term.
<LI>
	<KBD>variable_names(Value)</KBD>
	<BR><KBD>Variable=Name</KBD> pairs, excluding anonymous variables.  
	<BR>(Default: <KBD>[]</KBD>.)
<LI>
	<KBD>singletons(Value)</KBD>
	<BR><KBD>Variable=Name</KBD> pair for all singleton variables, excluding anonymous variables. 
	<BR>(Default: <KBD>[]</KBD>.)
</UL>
</OL>

<BR><KBD>mode read_term(?term, +closed_list(compound))</KBD>
<BR><KBD>mode read_term(@stream, ?term, +closed_list(compound))</KBD>

<P>Example:

<KBD>
<P>| ?- read_term(Term, []), write(Term), nl.
<BR>f(X, _Y, !x, !_x)
<BR>f(_3BE, _3B4, !_x0, !_x1)
<BR>
<BR>Term = f(A, B, !x0, !x1)
<BR>| ?- read_term(Term, [variables(Var)]), 
<BR>write(Var), nl, fail.
<BR>
<BR>f(X, _Y, !x, !_x)
<BR>[_1F1, _1EC, !_x0, !_x1]
<BR>
<BR>no
<BR>
<BR>| ?- read_term(Term, [variable_names(Var)]),
<BR> write(Var), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>[_1F1 = X, _1EC = _Y, !_x0 = x, !_x1 = _x]
<BR>
<BR>no
<BR>
<BR>| ?- read_term(Term, [remember_name(true)]),
<BR> write(Term), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>f(X, _1DC, !x, !_x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="read_1_term"></a>read_1_term(Term, VariableNames)</KBD>
<BR><KBD>read_1_term(Stream, Term, VariableNames)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from <KBD>Stream</KBD> or the current input stream. 
Return the list of variables and their names in <KBD>VariableNames</KBD>. 
<BR>It is the same as <KBD><a href="#read_term">read_term</a>(Term, [variable_names(VariableNames)])</KBD>.
<BR><KBD>mode read_1_term(?term, -closed_list(compound))</KBD>
<BR><KBD>mode read_1_term(@stream, ?term, -closed_list(compound))</KBD>

<P>Example:

<KBD>
<P>| ?- read_1_term(Term, Var), write(Var), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>[_1F1 = X, _1EC = _Y, !_x0 = x, !_x1 = _x]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="readR"></a>readR(Term)</KBD>
<BR><KBD>readR(Stream, Term)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from <KBD>Stream</KBD> or the current input stream. 
Remember the names for all the variables other than those beginning 
with an underscore in <KBD>Term</KBD>.  
<BR>It is the same as 
<KBD>
<BR><a href="#read_term">read_term</a>(Term, [remember_name(true)])
</KBD>
<BR><KBD>mode readR(?term)</KBD>
<BR><KBD>mode readR(@stream, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- readR(Term), write(Term), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>f(X, _1DC, !x, !_x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="readR_1_term"></a>readR_1_term(Term, VariableNames)</KBD>
<BR><KBD>readR_1_term(Stream, Term, VariableNames)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from <KBD>Stream</KBD> or the current input stream. Remember the names for all the variables in <KBD>Term</KBD>, and return the list of variables and their names in <KBD>VariableNames</KBD>. 
<BR>It is the same as 
<KBD>
<BR>read_term(Term, [variable_names(VariableNames), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remember_name(true)])
</KBD> 
<BR><KBD>mode readR_1_term(?term, -closed_list(compound))</KBD>
<BR><KBD>mode readR_1_term(@stream, ?term, -closed_list(compound))</KBD>

<P>Example:

<KBD>
<P>| ?- readR_1_term(Term, Var), write(Term), nl, 
<BR>write(Var), nl, fail.
<BR>f(X, _Y, !x, !_x)
<BR>f(X, _217, !x, !_x0)
<BR>[X = X, _217 = _Y, !x = x, !_x0 = _x]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="encoded_read_term"></a>encoded_read_term(Term, OptionList)</KBD>
<BR><KBD>encoded_read_term(Stream, Term, OptionList)</KBD>

<BLOCKQUOTE>
Read <KBD>Term</KBD> from the encoded stream <KBD>Stream</KBD> or the current input stream. The <KBD>OptionList</KBD> is the same as for <KBD><a href="#read_term">read_term/[2,3]</a></KBD>.
<BR><KBD>mode encoded_read_term(@term, +closed_list(compound))</KBD>
<BR><KBD>mode encoded_read_term(@stream, @term, +closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="write"></a>write(Term)</KBD>
<BR><KBD>write(Stream, Term)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to <KBD>Stream</KBD> or the current output stream.
<BR><KBD>mode write(?term)</KBD>
<BR><KBD>mode write(@stream, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- write(f(X, _Y, !x, !_x)), nl, fail.
<BR>f(X, _D0, !x, !_x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="write_term"></a>write_term(Term, OptionList)</KBD>
<BR><KBD>write_term(Stream, Term, OptionList)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to <KBD>Stream</KBD> or the current output stream. <KBD>OptionList</KBD> is a list whose entries are chosen from the items given below. Items not mentioned in <KBD>OptionList</KBD> take on their default values.

<UL type="disc">
<LI>
<KBD>quoted(Value)</KBD>
<BR>Meaning: Quote all unsafe atoms.
<BR>(Default: <KBD>false</KBD>.)
<LI>
<KBD>ignore_ops(Value)</KBD>
<BR>Meaning: Output operators in structural format.
<BR>(Default: <KBD>false</KBD>.)
<LI>
<KBD>numbervars(Value)</KBD>
<BR>Meaning: Generate variable names (not including object variables).
<BR>(Default: <KBD>false</KBD>.)
<LI>
<KBD>remember_name(Value)</KBD>
<BR>Meaning: Generate and remember variable names (including object variables).
<BR>(Default: <KBD>false</KBD>.)
<LI>
<KBD>op_table(Value)</KBD>
<BR>Meaning: Operator table.
<BR>(Default: Current table.)
<LI>
<KBD>max_depth(Value)</KBD>
<BR>Meaning: Print depth limit.
<BR>(Default: 0 (unlimited).)
<LI>
<KBD>obvar_prefix_table(Value)</KBD>
<BR>Meaning: Object variable prefix table.
<BR>(Default: Current table.)
</UL>

<BR><KBD>mode write_term(@term, @closed_list(compound))</KBD>
<BR><KBD>mode write_term(@stream, @term, @closed_list(compound))</KBD>

<P>Example:

<KBD>
<P>| ?- write_term(f(X, _Y, !x, !_y), [remember_name(true)]), 
<BR>nl, fail.
<BR>f(X, A, !x, !x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<BR><KBD><a name="writeR"></a>writeR(Term)</KBD>
<BR><KBD>writeR(Stream, Term)</KBD>
<BR><KBD><a name="writeq"></a>writeq(Term)</KBD>
<BR><KBD>writeq(Stream, Term)</KBD>
<BR><KBD><a name="writeRq"></a>writeRq(Term)</KBD>
<BR><KBD>writeRq(Stream, Term)</KBD>
<BR><KBD><a name="writeT"></a>writeT(Term, Table)</KBD>
<BR><KBD>writeT(Stream, Term, Table)</KBD>
<BR><KBD><a name="writeRT"></a>writeRT(Term, Table)</KBD>
<BR><KBD>writeRT(Stream, Term, Table)</KBD>
<BR><KBD><a name="writeTq"></a>writeTq(Term, Table)</KBD>
<BR><KBD>writeTq(Stream, Term, Table)</KBD>
<BR><KBD><a name="writeRTq"></a>writeRTq(Term, Table)</KBD>
<BR><KBD>writeRTq(Stream, Term, Table)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to <KBD>Stream</KBD> or the current output stream. The trailing <KBD>R</KBD>, <KBD>T</KBD>, <KBD>q</KBD> determine if variable names are to be created and remembered, if an operator table is to be used, and if unsafe atoms are to be quoted. These variants are faster than using the option list method above.
<BR><KBD>mode write{R,q}(@term)</KBD>
<BR><KBD>mode write{R,q}(@stream, @term)</KBD>
<BR><KBD>mode write{R,T,q}(@term, @atom)</KBD>
<BR><KBD>mode write{R,T,q}(@stream, @term, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- writeR(f(X, _Y, !x, !_y)), nl, fail.
<BR>f(X, A, !x, !x0)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="write_atom"></a>write_atom(Atom)</KBD>
<BR><KBD>write_atom(Stream, Atom)</KBD>
<BR><KBD><a name="writeq_atom"></a>writeq_atom(Atom)</KBD>
<BR><KBD>writeq_atom(Stream, Atom)</KBD>

<BLOCKQUOTE>
Write <KBD>Atom</KBD> to <KBD>Stream</KBD> or the current output stream. <KBD>write_atom</KBD> is faster than <KBD><a href="#write"></a>write</KBD> as it avoids many of the tests in write.  Unsafe atoms are quoted if <KBD>writeq_atom</KBD> is used.
<BR><KBD>mode write_atom(@atom)</KBD>
<BR><KBD>mode write_atom(@stream, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- write_atom('Hello'), nl, fail.
<BR>Hello
<BR>
<BR>no
<BR>
<BR>| ?- writeq_atom('Hello'), nl, fail.
<BR>'Hello'
<BR>
<BR>no
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="write_canonical"></a>write_canonical(Term)</KBD>
<BR><KBD>write_canonical(Stream, Term)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to <KBD>Stream</KBD> or the current output stream. All the operators are written in structural format. 
<P>It is the same as <KBD><a href="#write_term">write_term</a>(Term, [ignore_ops(True)])</KBD>.
<BR><KBD>mode write_canonical(@term)</KBD>
<BR><KBD>mode write_canonical(@stream, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- write_canonical((A = B + C * D)), nl, fail.
<BR>(=)(A, (+)(B, (*)(C, D)))
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="write_integer"></a>write_integer(Stream, Integer)</KBD>

<BLOCKQUOTE>
Write <KBD>Integer</KBD> to <KBD>Stream</KBD>. <KBD>write_integer</KBD> is faster than <KBD><a href="#write">write</a></KBD> as it avoids many of the tests in write.
<BR><KBD>mode write_integer(@integer)</KBD>
<BR><KBD>mode write_integer(@stream, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- write_integer(stdout, 42), nl, fail.
<BR>42
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>
<P><KBD><a name="write_string"></a>write_string(Stream, String)</KBD>

<BLOCKQUOTE>
Write <KBD>String</KBD> to <KBD>Stream</KBD> but without the quotes. 
<BR><KBD>mode write_string(@string)</KBD>
<BR><KBD>mode write_string(@stream, @string)</KBD>

<P>Example:

<KBD>
<P>| ?- write_string(stdout, "Hello World").
<BR>Hello World
<BR>
</KBD>
</BLOCKQUOTE>
<P><KBD><a name="writeq_string"></a>writeq_string(Stream, String)</KBD>

<BLOCKQUOTE>
Write <KBD>String</KBD> to <KBD>Stream</KBD> with quotes. 
<BR><KBD>mode writeq_string(@string)</KBD>
<BR><KBD>mode writeq_string(@stream, @string)</KBD>

<P>Example:

<KBD>
<P>| ?- writeq_string(stdout, "Hello World").
<BR>"Hello World"
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="write_term_list"></a>write_term_list(Message)</KBD>
<BR><KBD>write_term_list(Stream, Message)</KBD>

<BLOCKQUOTE>
Write terms to <KBD>Stream</KBD> or the current output stream according to the formatting information in the list <KBD>Message</KBD> described below. The Qu-Prolog compiler unfolds this predicate to low-level calls to carry out the writing and is therefore the most efficient way to output a sequence of terms. The call <KBD>write_term_list(stdout, Message)</KBD> is faster than <KBD>write_term_list(Message)</KBD> because the current output stream does not need to be looked up.

<UL type="disc">
<LI>
<KBD><a href="#nl">nl</a></KBD>
<BR>Meaning: New line.
<LI>
<KBD>sp</KBD>
<BR>Meaning: Space.
<LI>
<KBD><a href="#tab">tab</a>(N)</KBD>
<BR>Meaning: Write <KBD>N</KBD> spaces.
<LI>
<KBD>wa(Atom)</KBD>
<BR>Meaning: Use <KBD><a href="#write_atom">write_atom</a></KBD> for <KBD>Atom</KBD>.
<LI>
<KBD>wqa(Atom)</KBD>
<BR>Meaning: Use <KBD><a href="#write_atom">writeq_atom</a></KBD> for <KBD>Atom</KBD>.
<LI>
<KBD>wi(Integer)</KBD>
<BR>Meaning: Use <KBD><a href="#write_integer">write_integer</a></KBD> for <KBD>Integer</KBD>.
<LI>
<KBD>pc(Code)</KBD>
<BR>Meaning: Use <KBD><a href="#put_code">put_code</a></KBD> for 	<KBD>Code</KBD>.
<LI>
<KBD>w(Term)</KBD>
<BR>Meaning: Use <KBD><a href="#write">write</a></KBD>for <KBD>Term</KBD>.
<LI>
<KBD>q(Term)</KBD>
<BR>Meaning: Use <KBD><a href="#write">writeq</a></KBD> for <KBD>Term</KBD>.
<LI>
<KBD>wR(Term)</KBD>
<BR>Meaning: Use <KBD><a href="#write">writeR</a></KBD> for <KBD>Term</KBD>.
<LI>
<KBD>wRq(Term)</KBD>
<BR>Meaning: Use <KBD><a href="#write">writeRq</a></KBD> for <KBD>Term</KBD>.
<LI>
<KBD>wl(List, Sep)</KBD>
<BR>Meaning: Write the elements of <KBD>List</KBD> using  <KBD><a href="#write">write</a></KBD> with <KBD>Sep</KBD> as a list separator.
</UL>

<BR><KBD>mode write_term_list(@closed_list(term))</KBD>
<BR><KBD>mode write_term_list(@stream, @closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- write_term_list([wa('Hello'), sp, wa('World'), nl, 
<BR>wqa('Hello World'), pc(0'!)]), nl, fail.
<BR>Hello World
<BR>'Hello World'!
<BR>
<BR>no
<BR>
<BR>| ?- write_term_list([wi(42), tab(5), w(f(X, _Y, !x, !_x)), sp, 
<BR>pc(0'-), sp, wRq(f(X, _Y, !x, !_x)), nl, 
<BR>wl([31, 12, 1999], '/')]), nl, fail.
<BR>42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(X, _197, !x, !_x0) - f(X, A, !x, !x0)
<BR>31/12/1999
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="encoded_write_term"></a>encoded_write_term(Term, OptionList)</KBD>
<BR><KBD>encoded_write_term(Stream, Term, OptionList)</KBD>

<BLOCKQUOTE>
Write <KBD>Term</KBD> to the encoded stream <KBD>Stream</KBD> or the current output stream. The <KBD>OptionList</KBD> is the same as for <KBD><a href="#write_term">write_term/[2,3]</a></KBD>.
<BR><KBD>mode encoded_write_term(+term, +closed_list(compound))</KBD>
<BR><KBD>mode encoded_write_term(@stream, +term, +closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="portray_clause"></a>portray_clause(Clause)</KBD>
<BR><KBD>portray_clause(Stream, Clause)</KBD>

<BLOCKQUOTE>
Pretty print <KBD>Clause</KBD> in <KBD>Stream</KBD> or the current output stream.
<BR><KBD>mode portray_clause(@compound)</KBD>
<BR><KBD>mode portray_clause(@stream, @compound)</KBD>

<P>Example:

<KBD>
<P>| ?- portray_clause((p(X,Y) :- q(X,Z), r(Z,Y), s(Y))), fail.
<BR>p(X, Y) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;q(X, Z),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;r(Z, Y),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;s(Y).
<BR>no        
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="print"></a>print(Term)</KBD>
<BR><KBD>print(Stream, Term)</KBD>


<BLOCKQUOTE>
The same as <KBD>writeq</KBD> except that the dynamic predicate <KBD>portray/1</KBD>
is first tried. If that succeeds then <KBD>writeq</KBD> is not called. This provides a hook 
for user defined term writing.

<BR><KBD>mode print(@term)</KBD>
<BR><KBD>mode print(@stream, @term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="portray"></a>portray(Term)</KBD>


<BLOCKQUOTE>
A dynamic predicate used as a hook for user defined term writing in <KBD>print</KBD>.
</BLOCKQUOTE>

<!-- Section 3.3.3 -->
<H3>
<a name="Section3.3.3">3.3.3 Character Input/Output</a>
</H3>

<P>These predicates can be divided into two categories according to the representation of the character used.  The <KBD>_char</KBD> predicates deal with the character as a single letter atom.  The <KBD>_code</KBD> predicates handle the character in its character code representation, which is an integer. Any predicate without these suffixes are intended to be compatible with existing Prologs, which use character codes.  Predicates without a stream argument use the current input/output stream.		

<P>Predicates:

<P><KBD><a name="get"></a>get(CharCode)</KBD>
<BR><KBD>get(Stream,CharCode)</KBD>

<BLOCKQUOTE>
Get the next visible character from the current input stream, and unify it with <KBD>CharCode</KBD>.
<BR><KBD>mode get(?integer)</KBD>
<BR><KBD>mode get(@stream, ?integer)</KBD>

<P>Note: non-visible characters are character codes less than 33.  This includes:

<TABLE  border="0" cellspacing="0" cellpadding="10">
<TR>
<TD>Tab</TD>
<TD>Character code: 9</TD>
</TR>
<TR>
<TD>New line</TD>
<TD>Character code: 10</TD>
</TR>
<TR>
<TD>Space</TD>
<TD>Character code: 32</TD>
</TR>
</TABLE>

<P>Examples (In the second example, a 'tab' precedes the 'A'):

<KBD>
<P>| ?- get(CharCode).
<BR>A
<BR>
<BR>CharCode = 65
<BR>
<BR>| ?- get(CharCode).
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A
<BR>
<BR>CharCode = 65
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get0"></a>get0(CharCode)</KBD>
<BR><KBD>get0(Stream,CharCode)</KBD>

<BLOCKQUOTE>
Get the next character from the current input stream, and unify it with <KBD>CharCode</KBD>. The same as <KBD><a href="#get_code">get_code/[1,2]</a></KBD>.
<BR><KBD>mode get0(?integer)</KBD>
<BR><KBD>mode get0(@stream, ?integer)</KBD>

<P>Examples (In the second example, a 'tab' precedes the 'A'):

<KBD>
<P>| ?- get0(CharCode).
<BR>A
<BR>
<BR>CharCode = 65
<BR>
<BR>| ?- get0(CharCode).
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A
<BR>
<BR>CharCode = 9
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_char"></a>get_char(Character)</KBD>
<BR><KBD>get_char(Stream, Character)</KBD>

<BLOCKQUOTE>
<KBD>Character</KBD> is the next character from <KBD>Stream</KBD> or the current input stream.
<BR><KBD>mode get_char(?atom)</KBD>
<BR><KBD>mode get_char(@stream, ?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- get_char(Char).
<BR>A
<BR>
<BR>Char = A
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_code"></a>get_code(CharCode)</KBD>
<BR><KBD>get_code(Stream, CharCode)</KBD>

<BLOCKQUOTE>
<KBD>CharCode</KBD> is the next character code from <KBD>Stream</KBD> or the current input stream. 
<BR><KBD>mode get_code(?integer)</KBD>
<BR><KBD>mode get_code(@stream, ?integer)</KBD>

<P>Examples (In the second example, a 'tab' precedes the 'A'):

<KBD>
<P>| ?- get_code(CharCode).
<BR>A
<BR>
<BR>CharCode = 65
<BR>
<BR>| ?- get_code(CharCode).
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A
<BR>
<BR>CharCode = 9
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_line"></a>get_line(String)</KBD>
<BR><KBD>get_line(Stream, String)</KBD>

<BLOCKQUOTE>
<KBD>String</KBD> is the next line from 
<KBD>Stream</KBD> or the current input stream. The newline is consumed but
is not part of the returned list. <KBD>String</KBD> is instantiated to <KBD>-1</KBD> at EOF.
<BR><KBD>mode get_line(?string)</KBD>
<BR><KBD>mode get_line(@stream, ?string)</KBD>
</BLOCKQUOTE>


<P><KBD><a name="put_line"></a>put_line(CodeList)</KBD>
<BR><KBD>put_line(Stream, CodeList)</KBD>

<BLOCKQUOTE>
<KBD>CodeList</KBD> is written to 
<KBD>Stream</KBD> or the current output stream. A newline is added. 
<BR><KBD>mode put_line(@list(integer))</KBD>
<BR><KBD>mode put_line(@string)</KBD>
<BR><KBD>mode put_line(@stream, @list(integer))</KBD>
<BR><KBD>mode put_line(@stream, @string)</KBD>


<P>Example:

<KBD>
<P>| ?- get_line(L),put_line(L).
<BR>abc
<BR>
<BR>abc
<BR>
<BR>L = "abc"
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="skip"></a>skip(CharCode)</KBD>
<BR><KBD>skip(Stream, CharCode)</KBD>

<BLOCKQUOTE>
Skip the input from <KBD>Stream</KBD> or the current input stream until after the first occurrence of <KBD>CharCode</KBD>. It is assumed that <KBD>CharCode</KBD> occurs in <KBD>Stream</KBD>.
<BR><KBD>mode skip(@integer)</KBD>
<BR><KBD>mode skip(@stream, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- skip(0'*), get_char(Char).
<BR>ABC*DEF*GHI
<BR>
<BR>Char = D;
<BR>
<BR>no
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="nl"></a>nl</KBD>
<BR><KBD>nl(Stream)</KBD>

<BLOCKQUOTE>
Write a new line on <KBD>Stream</KBD> or the current output stream. 
<BR><KBD>mode nl(@stream)</KBD>

<P>Example:

<KBD>
<P>| ?- write('Hello'), nl, write('World'), nl.
<BR>Hello
<BR>World
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tab"></a>tab(N)</KBD>
<BR><KBD>tab(Stream, N)</KBD>

<BLOCKQUOTE>
Output <KBD>N</KBD> spaces to <KBD>Stream</KBD> or the current output stream.
<BR><KBD>mode tab(@integer)</KBD>
<BR><KBD>mode tab(@stream, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- write('Hello'), tab(5), write('World'), nl.
<BR>Hello&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;World
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>		

<P><KBD><a name="put"></a>put(CharCode)</KBD>

<BLOCKQUOTE>
Send <KBD>CharCode</KBD> to the current output stream.
<BR><KBD>mode put(@integer)</KBD>

<P>Example:

<KBD>
<P>| ?- put(0'H), put(0'e), put(0'l), put(0'l), put(0'o), nl.
<BR>
<BR>Hello
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="put_code"></a>put_code(CharCode)</KBD>
<BR><KBD>put_code(Stream, CharCode)</KBD>

<BLOCKQUOTE>
Send the character code, <KBD>CharCode</KBD>, to <KBD>Stream</KBD> or the current output stream.
<BR><KBD>mode put_code(@integer)</KBD>
<BR><KBD>mode put_code(@stream, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- put_code(0'H), put_code(0'e), put_code(0'l), 
<BR>put_code(0'l), put_code(0'o), nl.
<BR>
<BR>Hello
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="put_char"></a>put_char(Character)</KBD>
<BR><KBD>put_char(Stream, Character)</KBD>

<BLOCKQUOTE>
Send <KBD>Character</KBD> to <KBD>Stream</KBD> or the current output stream.
<BR><KBD>mode put_char(@atom)</KBD>
<BR><KBD>mode put_char(@stream, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- put_char('H'), put_char(e), put_char(l),
<BR>put_char(l), put_char(o), nl.
<BR>Hello
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<!-- Section 3.4 -->
<H2>
<a name="Section3.4">3.4 Terms</a>
</H2>

<!-- Section 3.4.1 -->
<H2>
<a name="Section3.4.1">3.4.1 Comparison of Terms</a>
</H2>

<P>Two terms are compared according to the standard ordering, which is defined below.  Items listed at the beginning come before the items listed at the end.  For example, meta variables are less than object variables in the standard ordering.

<OL>
<LI>
Meta variables, in age ordering (older variables come before younger variables). 	If the variables are the same and there are substitutions, then the substitutions are compared as lists using the standard ordering.
<LI>
Object variables, in age ordering (older variables come before younger variables). If the variables are the same and there are substitutions, then the substitutions are compared as lists using the standard ordering.
<LI>
Integers, in numerical ordering.
<LI>
Atoms, in character code (ASCII) ordering.
<LI>
Compound terms (including lists) are compared in the following order:
<OL>
<LI>
Arity, in numerical ordering.
<LI>
Functor, in standard ordering.
<LI>
Arguments, in standard ordering, from left to right.
</OL>
If the terms are the same and there are substitutions, then the substitutions are compared as lists using the standard ordering.
<LI>
Quantified terms are compared in the following order:
<OL>
<LI>
Quantifier, in standard ordering.
<LI>
Bound variables list, in standard ordering.
<LI>
Body, in standard ordering.
</OL>
If the terms are the same and there are substitutions, then the substitutions are compared as lists using the standard ordering.
</OL>

<P>Predicates:

<P><KBD><a name="=="></a>Term1 == Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> and <KBD>Term2</KBD> are alpha-equivalent without instantiation.
<BR><KBD>mode @term == @term</KBD>

<P>Example:

<KBD>
<P>| ?- 10 * 2 == 10 + 10.
<BR>
<BR>no
<BR>
<BR>| ?- A == 10 * 2.
<BR>
<BR>no
<BR>
<BR>| ?- A = 10 * 2, A == 10 * 2.
<BR>
<BR>A = 10 * 2;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="\=="></a>Term1 \== Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> and <KBD>Term2</KBD> are not alpha-equivalent without instantiation.
<BR><KBD>mode @term \== @term</KBD>

<P>Example:

<KBD>
<P>| ?- 10 * 2 \== 10 + 10.
<BR>
<BR>yes
<BR>
<BR>| ?- A = 10 * 2, A \== 10 * 2.
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="@="></a>Term1 @= Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> equals to  <KBD>Term2</KBD> in the standard order.
<BR><KBD>mode @term @= @term</KBD>
</BLOCKQUOTE>

<P><KBD><a name="@<"></a>Term1 @&#60; Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> precedes <KBD>Term2</KBD> in the standard order.
<BR><KBD>mode @term @&#60; @term</KBD>
</BLOCKQUOTE>


<P><KBD><a name="@=<"></a>Term1 @=&#60; Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> precedes or equals to <KBD>Term2</KBD> in the standard order.			
<BR><KBD>mode @term @=&#60; @term</KBD>
</BLOCKQUOTE>

<P><KBD><a name="@>"></a>Term1 @&#62; Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> follows <KBD>Term2</KBD> in the standard order.			
<BR><KBD>mode @term @&#62; @term</KBD>
</BLOCKQUOTE>

<P><KBD><a name="@>="></a>Term1 @&#62;= Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> follows or equals to <KBD>Term2</KBD> in the standard order.
<BR><KBD>mode @term @&#62;= @term</KBD>
</BLOCKQUOTE>


<P><KBD><a name="compare">compare</a>(Operator, Term1, Term2)</KBD>

<BLOCKQUOTE>
The relation <KBD>Operator</KBD> holds between <KBD>Term1</KBD> and <KBD>Term2</KBD>.
<BR>The possible choices of <KBD>Operator</KBD> are given below.

<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>=</KBD></TD>
<TD>If <KBD>@=/2</KBD> holds.</TD>
</TR>
<TR>
<TD><KBD>&#60;</KBD></TD>
<TD>If <KBD>@&#60;/2</KBD> holds.</TD>
</TR>
<TR>
<TD><KBD>&#62;</KBD></TD>
<TD>If <KBD>@&#62;/2</KBD> holds.</TD>
</TR>
</TABLE>

<BR><KBD>mode compare(?atom, @term, @term)</KBD>
</BLOCKQUOTE>

<!-- Section 3.4.2) -->
<H2>
<A NAME="Section3.4.2">3.4.2 Testing of Terms</A>
</H2>

<P>These testing predicates are used to determine various properties of the data objects, or apply constraints to the data objects.

<P>Predicates:

<P><KBD><a name="simple"></a>simple(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is atomic or any variable.
<BR><KBD>mode simple(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- simple(atom).
<BR>
<BR>yes
<BR>
<BR>| ?- simple(10).
<BR>
<BR>yes
<BR>
<BR>| ?- simple(Var).
<BR>
<BR>Var = Var
<BR>
<BR>| ?- simple(!obvar).
<BR>
<BR>obvar = !obvar
<BR>
<BR>| ?- simple([a/!x]Var).
<BR>
<BR>x = !x
<BR>Var = Var
<BR>| ?- simple(functor(arg1, arg2)).
<BR>
<BR>no
<BR>
<BR>| ?- simple([list1, list2]).
<BR>
<BR>no
<BR> 
<BR>| ?- simple(!!quant !x Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atomic"></a>atomic(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is an atom or a number.
<BR><KBD>mode atomic(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- atomic(atom).
<BR>
<BR>yes
<BR>
<BR>| ?- atomic(10).
<BR>
<BR>yes
<BR>
<BR>| ?- atomic(Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atom"></a>atom(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is an atom.
<BR><KBD>mode atom(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- atom(atom).
<BR>
<BR>yes
<BR>
<BR>| ?- atom(10).
<BR>
<BR>no
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="number"></a>number(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a number.
<BR><KBD>mode number(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- number(10).
<BR>
<BR>yes
<BR>
<BR>| ?- number(3.4).
<BR>
<BR>yes
<BR>
<BR>| ?- number(atom).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="integer"></a>integer(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is an integer.
<BR><KBD>mode integer(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- integer(10).
<BR>
<BR>yes
<BR>
<BR>| ?- integer(3.4).
<BR>
<BR>no
<BR>
<BR>| ?- integer(atom).
<BR>
<BR>no
<BR> 
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="float"></a>float(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a double.
<BR><KBD>mode float(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- float(10).
<BR>
<BR>no
<BR>
<BR>| ?- float(3.4).
<BR>
<BR>yes
<BR>
<BR>| ?- float(atom).
<BR>
<BR>no
<BR> 
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="any_variable"></a>any_variable(Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is a meta or an object variable.
<BR><KBD>mode any_variable(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- any_variable(Var).
<BR>
<BR>Var = Var
<BR>
<BR>| ?- any_variable(!obvar).
<BR>
<BR>obvar = !obvar
<BR>
<BR>| ?- any_variable([a/!x]Var).
<BR>
<BR>x = !x
<BR>Var = Var
<BR> 
<BR>| ?- any_variable(atom).
<BR>
<BR>no
<BR>
<BR>| ?- any_variable(f(G)).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="var"></a>var(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a meta variable.
<BR><KBD>mode var(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- var(Var).
<BR>
<BR>Var = Var
<BR>
<BR>| ?- var(!obvar).
<BR>
<BR>no
<BR>
<BR>| ?- var([a/!x]Var).
<BR>
<BR>x = !x
<BR>Var = Var
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="nonvar"></a>nonvar(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is not a meta variable.
<BR><KBD>mode nonvar(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- nonvar(Var).
<BR>
<BR>no
<BR>
<BR>| ?- nonvar(!obvar).
<BR>
<BR>obvar = !obvar
<BR>
<BR>| ?- nonvar([a/!x]Var).
<BR>
<BR>no
<BR> 
<BR>| ?- nonvar(f(G)).
<BR>
<BR>G = G   
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ground"></a>ground(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> does not contain any meta variables 
(after simplifying substitutions).
<BR><KBD>mode ground(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- ground(Var).
<BR>
<BR>no
<BR>
<BR>| ?- ground(!obvar).
<BR>
<BR>obvar = !obvar
<BR>
<BR>| ?- ground([a/!x]Var).
<BR>
<BR>no
<BR> 
<BR>| ?- ground(f(G)).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="obvar"></a>obvar(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is an object variable.
<BR><KBD>mode obvar(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- obvar(Var).
<BR>
<BR>no
<BR>
<BR>| ?- obvar(!obvar).
<BR>
<BR>obvar = !obvar
<BR>
<BR>| ?- obvar([a/!x]!y).
<BR>
<BR>x = !x
<BR>y = !y
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="compound"></a>compound(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a structure or a list.
<BR><KBD>mode compound(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- compound(f(arg1, g(arg2))).
<BR>
<BR>yes
<BR>
<BR>| ?- compound([list1, list2]).
<BR>
<BR>yes
<BR>
<BR>| ?- compound(!!qant !x Var).
<BR>
<BR>no
<BR>
<BR>| ?- compound(atom).
<BR>
<BR>no
<BR>
<BR>| ?- compound(Var).
<BR>
<BR>no
<BR>
<BR>| ?- compound([a/!x]Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="list"></a>list(Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is a (possibly empty) list.
<BR><KBD>mode list(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- list(f(arg1, arg2)).
<BR>
<BR>no
<BR>
<BR>| ?- list([list1, list2]).
<BR>
<BR>yes
<BR>
<BR>| ?- list([a/!x]Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="string"></a>string(Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is a string.
<BR><KBD>mode string(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- string([40,41]).
<BR>
<BR>no
<BR>
<BR>| ?- string("ab").
<BR>
<BR>yes
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="quant"></a>quant(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a quantified term.
<BR><KBD>mode quant(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- quant(!!quant !x Var).
<BR>
<BR>x = !x
<BR>Var = Var
<BR>
<BR>| ?- quant(f(!!quant !x Var)).
<BR>
<BR>no
<BR>
<BR>| ?- quant([a/!x]Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sub"></a>sub(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> has a substitution at the outermost level.
<BR><KBD>mode sub(@term)</KBD>

<P>Example:

<KBD>
<BR>| ?- sub([a/!x]Var).
<BR>
<BR>x = !x
<BR>Var = Var
<BR>
<BR>| ?- sub(f([a/!x]Var)).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="std_var"></a>std_var(Term)</KBD>

<BLOCKQUOTE>
Equivalent to <KBD>var(Term), \+ sub(Term)</KBD> but faster.
<BR><KBD>mode std_var(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- std_var(Var).
<BR>
<BR>Var = Var
<BR>
<BR>| ?- std_var([A/!a]Var).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="std_nonvar"></a>std_nonvar(Term)</KBD>

<BLOCKQUOTE>
Equivalent to <KBD>nonvar(Term), \+ sub(Term)</KBD> but faster.
<BR><KBD>mode std_nonvar(@term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="std_compound"></a>std_compound(Term)</KBD>

<BLOCKQUOTE>
Term is compound with an atom as the functor.
<BR><KBD>mode std_compound(@term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="identical_or_apart"></a>identical_or_apart(Term1, Term2)</KBD>

<BLOCKQUOTE>
True when the terms <KBD>Term1</KBD> and <KBD>Term2</KBD> are either identical or non-unifiable.
<BR><KBD>mode identical_or_apart(@term, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- identical_or_apart(A, B).
<BR>
<BR>no
<BR>
<BR>| ?- A is 10, identical_or_apart(A,B).
<BR>
<BR>no                            
<BR>
<BR>| ?- A is 10, B is 10, identical_or_apart(A,B).
<BR>
<BR>A = 10
<BR>B = 10
<BR>
<BR>| ?- A is 10, B is 20, identical_or_apart(A,B).
<BR>
<BR>A = 10
<BR>B = 20
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="is_free_in"></a>is_free_in(ObVar, Term)</KBD>
<BR><KBD><a name="is_not_free_in"></a>is_not_free_in(ObVar, Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>ObVar</KBD> is known to be (not) free in <KBD>Term</KBD>.			

<P>Both <KBD>is_free_in</KBD> and <KBD>is_not_free_in</KBD> are infix operators.
<BR><KBD>mode is_free_in(@obvar, @term)</KBD>
<BR><KBD>mode is_not_free_in(@obvar, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- !x is_free_in f(!y, !x, !z).
<BR>
<BR>x = !x
<BR>y = !y
<BR>z = !z
<BR>
<BR>| ?- !x is_free_in f(!y, g(!x), !z).
<BR>
<BR>x = !x
<BR>y = !y
<BR>z = !z
<BR>
<BR>| ?- !x is_free_in f(X).
<BR>
<BR>no
<BR>
<BR>| ?- !x is_free_in atom.
<BR>
<BR>no
<BR>
<BR>| ?- !x is_free_in !!q !x B.
<BR>
<BR>no
<BR>
<BR>| ?- !x is_free_in [a/!x]B.
<BR>
<BR>no
<BR>
<BR>| ?- !x is_not_free_in f(!y, !x, !z).
<BR>
<BR>no
<BR>
<BR>| ?- !x is_not_free_in f(!y, g(!x), !z).
<BR>
<BR>no
<BR>
<BR>| ?- !x is_not_free_in f(X).
<BR>
<BR>no
<BR>
<BR>| ?- !x is_not_free_in atom.
<BR>
<BR>x = !x
<BR>
<BR>| ?- !x is_not_free_in !!q !x B.
<BR>
<BR>x = !x
<BR>B = B
<BR>
<BR>| ?- !x is_not_free_in [a/!x]B.
<BR>
<BR>x = !x
<BR>B = B
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="not_free_in"></a>not_free_in(ObVar, Term)</KBD>

<BLOCKQUOTE>
Apply the not free in constraint. <KBD>not_free_in</KBD> is an infix operator.
<BR><KBD>mode not_free_in(+obvar, +term)</KBD>

<P>Example:

<KBD>
<P>| ?- !x not_free_in f(!y, !x, !z).
<BR>
<BR>no
<BR>
<BR>| ?- !x not_free_in f(!y, !z).
<BR>
<BR>x = !x
<BR>y = !y
<BR>z = !z       
<BR>provided:
<BR>
<BR>!z not_free_in [!x]
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!z, !y]
<BR>
<BR>| ?- !x is_not_free_in f(!y, !z).
<BR>
<BR>no
<BR>
<BR>| ?- !x not_free_in !y, !x not_free_in !z, !x is_not_free_in f(!y, !z).
<BR>
<BR>x = !x
<BR>y = !y
<BR>z = !z
<BR>provided:
<BR>
<BR>!z not_free_in [!x]
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!z, !y]
</KBD>  
</BLOCKQUOTE>

<P><KBD><a name="is_distinct"></a>is_distinct(ObVar1, ObVar2)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>ObVar1</KBD> and <KBD>ObVar2</KBD> are known to represent different object-level variables.
<BR><KBD>mode is_distinct(@term, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- is_distinct(!x, !y).
<BR>
<BR>no
<BR>
<BR>| ?- !x not_free_in !y, is_distinct(!x, !y).
<BR>
<BR>x = !x
<BR>y = !y
<BR>provided:
<BR>
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!y]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="check_binder"></a>check_binder(VarList, DistinctList)</KBD>

<BLOCKQUOTE>
Check <KBD>VarList</KBD> is a valid bound variable list for a quantified term.  The check also ensures every object variable in the list is different from every other.  The variables in <KBD>VarList</KBD> are made distinct from the object variables in <KBD>DistinctList</KBD>, which is a closed list.  If <KBD>VarList</KBD> is an open list, the call will be delayed when the variable representing the open end of the list is reached.  This is not expected to be used directly. It is called automatically by the system when quantified terms are constructed.
</BLOCKQUOTE>



<!-- Section 3.4.3 -->
<H2>
<A NAME="Section3.4.3">3.4.3 Term Manipulation</A>
</H2>

<P>This set of meta-logical predicates perform various operations over the data objects.  These operations include composition/decomposition of terms, conversion of a data object from one form to another, and simplification.

<P>Predicates:

<P><KBD><a name="=.."></a>Term =..[Functor|Arguments]</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is a compound composed of <KBD>Functor</KBD> and <KBD>Arguments</KBD>.
<BR><KBD>mode +nonvar =.. ?cloded_list(term)</KBD>
<BR><KBD>mode -nonvar =.. @cloded_list(term)</KBD>

<P>Example:

<KBD>
<P>| ?- f(a, B, _C, !d, !_e) =.. List, write(List), nl, fail.
<BR>[f, a, B, _119, !d, !_x0]
<BR>
<BR>no
<BR>
<BR>| ?- Funct =.. [f, a, B, _C, !d, !_e], write(Funct), nl, fail.
<BR>f(a, B, _114, !d, !_x0)
<BR>
<BR>
<BR>no
<BR>
<BR>| ?- f(g(a), h(b)) =.. List, write(List), nl, fail.
<BR>[f, g(a), h(b)]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="functor"></a>functor(Term, Functor, Arity)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is compound with <KBD>Functor</KBD> and <KBD>Arity</KBD>.
<BR><KBD>mode functor(-compound, +term, +integer)</KBD>
<BR><KBD>mode functor(-atomic, +term, +integer)</KBD>
<BR><KBD>mode functor(+compound, ?term, ?integer)</KBD>
<BR><KBD>mode functor(@atomic, ?term, ?integer)</KBD>

<P>Example:

<KBD>
<P>| ?- functor(f(X), Funct, Arg).
<BR>
<BR>X = X
<BR>Funct = f
<BR>Arg = 1
<BR>
<BR>| ?- functor(Term, f(X), 1).
<BR>
<BR>Term = f(X)(A)
<BR>X = X
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="arg"></a>arg(N, Term, Argument)</KBD>

<BLOCKQUOTE>
The <KBD>N</KBD>-th argument of <KBD>Term</KBD> is <KBD>Argument</KBD>.
<BR><KBD>mode arg(@integer, +compound, +term)</KBD>

<P>If <KBD>Term</KBD> has no <KBD>N</KBD>-th argument then an out-of-range exception will occur.

<P>Example:

<KBD>
<P>| ?- arg(2, f(a, B, c), b).
<BR>
<BR>B = b
<BR>
<BR>| ?- arg(3, f(a, B, c), C).
<BR>
<BR>B = B
<BR>C = c
<BR>
<BR>| ?- arg(4, f(a, b, c), Arg).
<BR>Unrecoverable error: argument 1 of arg(4, f(a, b, c), _128) 
<BR>must be in range (see manual)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="same_args"></a>same_args(Term1, Term2, N1, N2)</KBD>

<BLOCKQUOTE>
Succeed when <KBD>Term1</KBD> and <KBD>Term2</KBD> are both atomic or compound and the arguments from position <KBD>N1</KBD> to <KBD>N2</KBD> in <KBD>Term1</KBD> and <KBD>Term2</KBD> are the same.
<BR><KBD>mode same_args(+compound, +compound, @integer, @integer)</KBD>
<BR><KBD>mode same_args(@atomic, @atomic, @integer, @integer)</KBD>
<BR><KBD>mode same_args(+compound, @atomic, @integer, @integer)</KBD>
<BR><KBD>mode same_args(@atomic, +compound, @integer, @integer)</KBD>
<P>Example:

<KBD>
<P>| ?- same_args(f(a,b,c,d), g(A,B,C), 1, 2).
<BR>
<BR>A = a
<BR>B = b
<BR>C = C
</KBD>
</BLOCKQUOTE>

<P><KBD>same_args(Term1, Term2, N1, N2, N3)</KBD>
<BLOCKQUOTE>
<P>Succeed when <KBD>Term1</KBD> and <KBD>Term2</KBD> are both atomic or compound and the arguments from position <KBD>N1</KBD> to <KBD>N2</KBD> of <KBD>Term1</KBD> are the same as the arguments from position <KBD>N3</KBD> to <KBD>N3-N1+N2</KBD> of <KBD>Term2</KBD>.
<BR><KBD>mode same_args(+compound, +compound, @integer, @integer, @integer)</KBD>
<BR><KBD>mode same_args(@atomic, @atomic, @integer, @integer, @integer)</KBD>
<BR><KBD>mode same_args(+compound, @atomic, @integer, @integer, @integer)</KBD>
<BR><KBD>mode same_args(@atomic, +compound, @integer, @integer, @integer)</KBD>			

</BLOCKQUOTE>

<P><KBD><a name="setarg"></a>setarg(N, Term, Argument)</KBD>

<BLOCKQUOTE>
The <KBD>N</KBD>-th argument of <KBD>Term</KBD> is replaced by <KBD>Argument</KBD>.
<BR><KBD>mode setarg(@integer, +compound, +term)</KBD>
<P> Warning: this predicate does a backtrackable destructive update of the structure.
<P>If <KBD>Term</KBD> has no <KBD>N</KBD>-th argument then an out-of-range exception will occur.


</BLOCKQUOTE>



<P><KBD><a name="atom_chars"></a>atom_chars(Atom, AtomList)</KBD>

<BLOCKQUOTE>
<KBD>AtomList</KBD> is the list of single character atoms corresponding to the successive characters of <KBD>Atom</KBD>.
<BR><KBD>mode atom_chars(@atom, ?closed_list(atom))</KBD>
<BR><KBD>mode atom_chars(-atom, @closed_list(atom))</KBD>

<P>Example:

<KBD>
<P>| ?- atom_chars(abc, Chars).
<BR>
<BR>Chars = [a, b, c]
<BR>
<BR>| ?- atom_chars(Atom,[a,b,c]).
<BR>
<BR>Atom = abc
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atom_codes"></a>atom_codes(Atom, CharCodeList)</KBD>

<BLOCKQUOTE>
<KBD>CharCodeList</KBD> is the list of character codes corresponding to the successive characters of <KBD>Atom</KBD>.
<BR><KBD>mode atom_codes(@atom, ?closed_list(integer))</KBD>
<BR><KBD>mode atom_codes(-atom, @closed_list(integer))</KBD>

<P>Example:

<KBD>
<P>| ?- atom_codes(atom, Chars).
<BR>
<BR>Chars = [97, 116, 111, 109]
<BR>
<BR>| ?- atom_codes(Atom, [97, 116, 111, 109]).
<BR>
<BR>Atom = atom
<BR>
<BR>| ?- atom_codes(Atom,"atom").
<BR>
<BR>Atom = atom
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="name"></a>name(Atom, CharCodeList)</KBD>

<BLOCKQUOTE>
<KBD>Atom</KBD> is made of the character codes in <KBD>CharCodeList</KBD>.
<BR><KBD>mode name(@atomic, ?closed_list(integer))</KBD>
<BR><KBD>mode name(-atomic, @closed_list(integer))</KBD>

<P>Example:

<KBD>
<P>| ?- name(atom, Chars).
<BR>
<BR>Chars = [97, 116, 111, 109]
<BR>
<BR>| ?- name(Atom, [97, 116, 111, 109]).
<BR>
<BR>Atom = atom
<BR>
<BR>| ?- name(Atom, "atom").
<BR>
<BR>Atom = atom
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="char_code"></a>char_code(Atom, CharCode)</KBD>

<BLOCKQUOTE>
<KBD>CharCode</KBD> is the character code for the single character atom <KBD>Atom</KBD>.
<BR><KBD>mode char_code(@atom, ?integer)</KBD>
<BR><KBD>mode char_code(-atom, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- char_code(a, Code).
<BR>
<BR>Code = 97
<BR>
<BR>| ?- char_code(Char,97).
<BR>
<BR>Char = a
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="number_chars"></a>number_chars(Integer, AtomList)</KBD>

<BLOCKQUOTE>
<KBD>AtomList</KBD> is the list of characters corresponding to the successive characters of <KBD>Integer</KBD>.
<BR><KBD>mode number_chars(@integer, ?closed_list(atom))</KBD>
<BR><KBD>mode number_chars(-integer, @closed_list(atom))</KBD>

<P>Example:

<KBD>
<P>| ?- number_chars(42, Chars).
<BR>
<BR>Chars = [4, 2]
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="number_codes"></a>number_codes(Integer, CharCodeList)</KBD>

<BLOCKQUOTE>
<KBD>CharCodeList</KBD> is the list of character codes corresponding to the successive characters of <KBD>Integer</KBD>.
<BR><KBD>mode number_codes(@integer, ?closed_list(integer))</KBD>
<BR><KBD>mode number_codes(-integer, @closed_list(integer))</KBD>

<P>Example:

<KBD>
<P>| ?- number_codes(42, Codes).
<BR>
<BR>Codes = [52, 50]
<BR>
<BR>| ?- number_codes(Num, [52, 50]).
<BR>
<BR>Num = 42
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atom_concat"></a>atom_concat(Atom1, Atom2, Atom3)</KBD>

<BLOCKQUOTE>
<KBD>Atom3</KBD> is the atom formed by concatenating the characters of <KBD>Atom1</KBD> and the characters of <KBD>Atom2</KBD>.
<BR><KBD>mode atom_concat(@atom, @atom, -atom)</KBD>
<BR><KBD>mode atom_concat(?atom, ?atom, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- atom_concat(ab, cd, Atom).
<BR>
<BR>Atom = abcd
<BR>
<BR>| ?- atom_concat(Atom1, Atom2, ab).
<BR>
<BR>Atom1 =          % the empty atom
<BR>Atom2 = ab;
<BR>
<BR>Atom1 = a
<BR>Atom2 = b;
<BR>
<BR>Atom1 = ab
<BR>Atom2 = ;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atom_concat2"></a>atom_concat2(Atom1, Atom2, Atom3)</KBD>

<BLOCKQUOTE>
<KBD>Atom3</KBD> is the atom formed by concatenating the characters of <KBD>Atom1</KBD> and the characters of <KBD>Atom2</KBD>. This is a faster version of
<KBD>atom_concat</KBD> because of its more restricted mode.
<BR><KBD>mode atom_concat2(@atom, @atom, ?atom)</KBD>
</BLOCKQUOTE>
<P><KBD><a name="atom_length"></a>atom_length(Atom, N)</KBD>

<BLOCKQUOTE>
<KBD>Length</KBD> is the number of characters in <KBD>Atom</KBD>.
<BR><KBD>mode atom_length(@atom, ?integer)</KBD>

<P>Example:

<KBD>
<P>| ?- atom_length(abc, Len).
<BR>
<BR>Len = 3
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="atom_search"></a>atom_search(Atom1, Location1, Atom2, Location2)</KBD>

<BLOCKQUOTE>
<KBD>Location2</KBD> is the position in <KBD>Atom1</KBD> for the first occurrence of <KBD>Atom2</KBD> with the search starting at <KBD>Location1</KBD> in <KBD>Atom1</KBD>.
<BR><KBD>mode atom_search(@atom, @integer, @atom, ?atom)</KBD>			

<P>Example:

<KBD>
<P>| ?- atom_search(abab, 1, b, N).
<BR>
<BR>N = 2
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="string_to_list"></a>string_to_list(String, List)</KBD>
<BLOCKQUOTE>
<KBD>List</KBD> is the ASCII list corresponding to <KBD>String</KBD>.
<BR><KBD>mode string_to_list(@string, ?list(integer))</KBD>
<BR><KBD>mode string_to_list(-string, @list(integer))</KBD>

<P>Example:

<KBD>
<P>| ?- string_to_list("ab", L).
<BR>
<BR>L = [97, 98]
<BR>
<BR>| ?- string_to_list(S, [97,98]).
<BR>
<BR>S = "ab"
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="string_to_atom"></a>string_to_atom(String, Atom)</KBD>
<BLOCKQUOTE>
<KBD>Atom</KBD> is the atom whose name is <KBD>String</KBD>.
<BR><KBD>mode string_to_list(@string, ?list(integer))</KBD>
<BR><KBD>mode string_to_list(-string, @list(integer))</KBD>

<P>Example:
<KBD>
<P>| ?- string_to_atom("ab", A).
<BR>
<BR>A = ab
<BR>
<BR>| ?- string_to_atom(S, ab).
<BR>
<BR>S = "ab"
<BR>
</KBD>
</BLOCKQUOTE>



<P><KBD><a name="string_concat"></a>string_concat(String1, String2, String3)</KBD>

<BLOCKQUOTE>
<KBD>String3</KBD> is the string formed by concatenating the characters of <KBD>String1</KBD> and the characters of <KBD>String2</KBD>.
<BR><KBD>mode string_concat(@string, @string, -string)</KBD>
<BR><KBD>mode string_concat(?string, ?string, @string)</KBD>

<P>Example:

<KBD>
<P>| ?- string_concat("ab", "cd", String).
<BR>
<BR>String = "abcd"
<BR>
<BR>| ?- string_concat(String1, String2, "ab").
<BR>
<BR>String1 = []
<BR>String2 = "ab";
<BR>
<BR>String1 = "a"
<BR>String2 = "b";
<BR>
<BR>String1 = "ab"
<BR>String2 = [];
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="string_length"></a>string_length(String, N)</KBD>

<BLOCKQUOTE>
<KBD>Length</KBD> is the number of characters in <KBD>String</KBD>.
<BR><KBD>mode string_length(@string, ?integer)</KBD>

<P>Example:

<KBD>
<P>| ?- string_length("abc", Len).
<BR>
<BR>Len = 3
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sub_string"></a>sub_string(String, Start, Length, After, SubString)</KBD>

<BLOCKQUOTE>
<KBD>SubString</KBD> is the substring of <KBD>String</KBD> starting at 
position <KBD>Start</KBD> and of length <KBD>Length</KBD>. 
<KBD>After</KBD> is the number of characters 
remaining in <KBD>String</KBD> after the end of <KBD>SubString</KBD>.
<BR><KBD>mode sub_string(@string, ?integer, ?integer, ?integer, ?string)</KBD>

<P>Example:

<KBD>
<P>| ?- sub_string("ab", S, L, A, SS).
<BR>
<BR>S = 0
<BR>L = 0
<BR>A = 2
<BR>SS = [];
<BR>
<BR>S = 0
<BR>L = 1
<BR>A = 1
<BR>SS = "a";
<BR>
<BR>S = 0
<BR>L = 2
<BR>A = 0
<BR>SS = "ab";
<BR>
<BR>S = 1
<BR>L = 0
<BR>A = 1
<BR>SS = [];
<BR>
<BR>S = 1
<BR>L = 1
<BR>A = 0
<BR>SS = "b";
<BR>
<BR>S = 2
<BR>L = 0
<BR>A = 0
<BR>SS = [];
<BR>
<BR>no
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="re_match"></a>re_match(REString, String, Match)</KBD>

  <BLOCKQUOTE>
    <KBD>Match</KBD> is a list of index ranges representing a match of the
    regular expression <KBD>REString</KBD> in the string <KBD>String</KBD>.
    On backtracking all matches will be found.
    <P> See <a href="http://www.pcre.org/current/doc/html/pcre2syntax.html">http://www.pcre.org/current/doc/html/pcre2syntax.html</a> for details of the syntax of the regular expression library PCRE2. NOTE: the pcre library needs to be installed before building QuProlog for this predicate to be accessable.

    <P>Example:
      <KBD>
        <P>| ?- re_match("(\\d*)(\\s*)", "12   3 45", R).
          <BR>
          <BR>R = [0 : 5, 0 : 2, 2 : 5];
          <BR>
          <BR>R = [5 : 7, 5 : 6, 6 : 7];
          <BR>
          <BR>R = [7 : 9, 7 : 9, 9 : 9];
          <BR>
          <BR>R = [9 : 9, 9 : 9, 9 : 9];
          <BR>
      </KBD>
      <P>
      Note that the backslash of the regular expression needs to be escaped.
      For the first answer, 0 is the index of the beginning of the match and
      5 is the index of the end of the overall match. The next two ranges give
      the matchs for the bracketed sub-RE: 0:2 matches the digits and 2:5 matches the spaces.
      <P>The range values in combination with the use of <KBD>sub_string</KBD> can be used to extract the required substring.
  </BLOCKQUOTE>
    


<P><KBD><a name="quantify"></a>quantify(Quantified, Quantifier, VarList, Body)</KBD>

<BLOCKQUOTE>
<KBD>Quantified</KBD> is a quantified term composed of <KBD>Quantifier</KBD>, <KBD>VarList </KBD>, and <KBD>Body</KBD>.
<BR><KBD>mode quantify(?quant, ?term, ?list(term), ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- quantify(!!integral(0, !x) !x f(!x), Quant, Var, Body).
<BR>
<BR>x = !x
<BR>Quant = integral(0, !x)
<BR>Var = [!x]
<BR>Body = f(!x)
<BR>
<BR>| ?- quantify(QT, lambda, Var, Body).
<BR>
<BR>QT = !!lambda Var Body
<BR>Var = Var
<BR>Body = Body
<BR>provided: 
<BR>
<BR>check_binder(Var, [])
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="quantifier"></a>quantifier(Quantified, Quantifier)</KBD>

<BLOCKQUOTE>
The quantifier of <KBD>Quantified</KBD> is <KBD>Quantifier</KBD>.
<BR><KBD>mode quantifier(+quant, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- quantifier(!!integral(0, !x) !x f(!x), Quant).
<BR>
<BR>x = !x
<BR>Quant = integral(0, !x)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="bound_var"></a>bound_var(Quantified, VarList)</KBD>

<BLOCKQUOTE>
<KBD>VarList</KBD> is the bound variable list of the quantified term <KBD>Quantified</KBD>.
<BR><KBD>mode bound_var(+quant, ?list(term))</KBD>

<P>Example.

<KBD>
<P>| ?- bound_var(!!q [!x:t, !y] f(A), Var).
<BR>
<BR>x = !x
<BR>y = !y
<BR>A = A
<BR>Var = [!x : t, !y]
<BR>provided:
<BR>
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!y]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="body"></a>body(Quantified, Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is the body of the quantified term <KBD>Quantified</KBD>.
<BR><KBD>mode body(+quant, ?term)</KBD>

<P>Example.

<KBD>
<P>| ?- body(!!q !x f(A), Body).
<BR>
<BR>x = !x
<BR>A = A
<BR>Body = f(A)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="collect_vars"></a>collect_vars(Term, VarList)</KBD>

<BLOCKQUOTE>
<KBD>VarList</KBD> is a list of all the variables in <KBD>Term</KBD>.
<BR><KBD>mode collect_vars(@term, -closed_list(anyvar))</KBD>

<P>Example.

<KBD>
<P>| ?- collect_vars(f(X, _Y, !x, !_y), VarList), 
<BR>write(VarList), nl, fail.
<BR>[!_x0, !x, _1C3, X]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="concat_atom"></a>concat_atom(AtomList, Atom)</KBD>
<BR><KBD>concat_atom(AtomList, Atom1, Atom2)</KBD>

<BLOCKQUOTE>
<KBD>Atom2</KBD> is the atom formed by concatenating the characters of all the atomics in <KBD>AtomList</KBD> with <KBD>Atom1</KBD> interleaving the atoms.
<BR><KBD>mode concat_atom(@closed_list(atomic), @atomic, ?atom)</KBD>

<P>Example.

<KBD>
<P>| ?- concat_atom([a, b, c], Atom).
<BR>
<BR>Atom = abc
<BR> 
<BR>| ?- concat_atom([a,b,c],'/', Atom).
<BR>
<BR>Atom = a/b/c
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="copy_term"></a>copy_term(Term1, Term2)</KBD>

<BLOCKQUOTE>
<KBD>Term2</KBD> is a copy of <KBD>Term1</KBD> with all the variables replaced by fresh variables.
<BR><KBD>mode copy_term(@term, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- copy_term(f(X,g(X,Y),Y), Term2).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Term2 = f(B, g(B, A), A)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_distinct"></a>get_distinct(ObVar, DistinctList)</KBD>

<BLOCKQUOTE>
<KBD>DistinctList</KBD> is the list of object variables known to be different from <KBD>ObVar</KBD>.
<BR><KBD>mode get_distinct(@obvar, ?closed_list(obvar))</KBD>

<P>Example.

<KBD>
<P>| ?- !x not_free_in f(!y, !z), get_distinct(!x, List).
<BR>
<BR>x = !x
<BR>y = !y
<BR>z = !z
<BR>List = [!z, !y]
<BR>
<BR>provided:
<BR>
<BR>!z not_free_in [!x]
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!z, !y]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="parallel_sub"></a>parallel_sub(TermList, ObVarList, SubList)</KBD>

<BLOCKQUOTE>
<KBD>SubList</KBD> is a list representing a single parallel substitution whose range elements are in <KBD>TermList</KBD> and whose domain elements are in <KBD>ObVarList</KBD>.
<BR><KBD>mode parallel_sub(@closed_list(term), @closed_list(obvar), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-closed_list(compound))</KBD>
<BR><KBD>mode parallel_sub(?closed_list(term), ?closed_list(obvar), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+closed_list(compound))</KBD>

<P>Example:

<KBD>
<P>| ?- parallel_sub([a, f(X)], [!x, !y], SubList).
<BR>
<BR>X = X
<BR>x = !x
<BR>y = !y
<BR>SubList = [a / !x, f(X) / !y]
<BR>
<BR>| ?- parallel_sub(TermList, ObVarList, [a / !x, f(X) / !y]).
<BR>
<BR>TermList = [a, f(X)]
<BR>ObVarList = [!x, !y]
<BR>x = !x
<BR>X = X
<BR>y = !y
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="simplify_term"></a>simplify_term(Term1, Term2)</KBD>
<BR><KBD>simplify_term(Term1, Term2, Atom)</KBD>

<BLOCKQUOTE>
<KBD>Term2</KBD> is the result of applying simplification to any substitution in <KBD>Term1</KBD>. <KBD>Atom</KBD> is set to <KBD>true</KBD> if any simplification is performed.  Otherwise <KBD>Atom</KBD> is set to <KBD>fail</KBD>.  Note that the Qu-Prolog interpreter calls <KBD>simplify_term</KBD> before printing answers.
<BR><KBD>mode simplify_term(@term, ?term)</KBD>
<BR><KBD>mode simplify_term(@term, ?term, -atom)</KBD>

<P>Example:

<KBD>
<P>| ?- simplify_term([a/!x]f(!x), Term2), write(Term2), nl, fail.
<BR>f(a)
<BR>
<BR>no
<BR>
<BR>| ?- simplify_term([a/!x]f(Var), Term2, Atom), write(Term2), 
<BR>nl, write(Atom), nl, fail.
<BR>f([a/!x]Var)
<BR>true
<BR>
<BR>no
<BR>
<BR>| ?- simplify_term([a/!x][b/!y]f(X, !x, !y), Term2), 
<BR>write(Term2), nl, fail.
<BR>f([a/!x, b/!y]X, [a/!x, b/!y]!x, b)
<BR>
<BR>no
<BR> 
<BR>| ?- simplify_term([a/!x, B/!y]f(X, !x, !y), Term2), 
<BR>write(Term2), nl, fail.
<BR>f([a/!x, B/!y]X, [a/!x, B/!y]!x, B)
<BR>
<BR>no
<BR>
<BR>| ?- simplify_term([a/!x]!!q !x B, Term2), write(Term2), nl, fail.
<BR>!!q !x B
<BR>
<BR>no
<BR>
<BR>| ?- simplify_term([a/!y]!!q !x B, Term2), write(Term2), nl, fail.
<BR>[a/!y](!!q !x B)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sub_atom"></a>sub_atom(Atom1, Location, N, Atom2)</KBD>

<BLOCKQUOTE>
<KBD>Atom2</KBD> is an atom which has <KBD>N</KBD> characters identical to the <KBD>N</KBD> characters of <KBD>Atom1</KBD> starting at <KBD>Location</KBD> in <KBD>Atom1</KBD>.
<BR><KBD>mode sub_atom(@atom, ?integer, ?integer, ?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- sub_atom(atom1, 2, 2, Atom2).
<BR>
<BR>Atom2 = to
<BR>
<BR>| ?- sub_atom(atom1, Loc, 2, Atom2).
<BR>
<BR>Loc = 1
<BR>Atom2 = at;
<BR>
<BR>Loc = 2
<BR>Atom2 = to;
<BR>
<BR>Loc = 3
<BR>Atom2 = om;
<BR>
<BR>Loc = 4
<BR>Atom2 = m1;
<BR>
<BR>no
<BR>
<BR>| ?- sub_atom(atat, Loc, Num, at).
<BR>
<BR>Loc = 1
<BR>Num = 2;
<BR>
<BR>Loc = 3
<BR>Num = 2;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sub_term"></a>sub_term(Substituted, Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is <KBD>Substituted</KBD> with the substitution removed.
<BR><KBD>mode sub_term(+term, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- sub_term([a/!x]f(A), Term).
<BR>
<BR>x = x
<BR>A = A
<BR>Term = f(A)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="substitution"></a>substitution(Substituted, Substitutions)</KBD>

<BLOCKQUOTE>
<KBD>Substitutions</KBD> is the list of parallel substitutions appearing at the top-level of <KBD>Substituted</KBD>.
<BR><KBD>mode substitution(@term, -closed_list(closed_list(compound)))</KBD>

<P>Example:

<KBD>
<P>| ?- substitution([x/!y, z/!x]f(X, g(Y), [y/!z]Z), Subs).
<BR>
<BR>y = !y
<BR>x = !x
<BR>X = X
<BR>Y = Y
<BR>z = !z
<BR>Z = Z
<BR>Subs = [[x / !y, z / !x]]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="substitute"></a>substitute(Substituted, Substitutions, Term)</KBD>

<BLOCKQUOTE>
<KBD>Substituted</KBD> has <KBD>Substitutions</KBD> applied to <KBD>Term</KBD>. See <KBD><a href="#substitution">substitution/2</a></KBD>.
<BR><KBD>mode substitute(+term, ?closed_list(closed_list(compound)), ?term)</KBD>
<BR><KBD>mode substitute(-term, @closed_list(closed_list(compound)), @term)</KBD>

<P>Example:

<KBD>
<P>| ?- substitute(T, [[a/!x1, b/!x2], [c/!x3]], f(X)), write(T),fail.
<BR>[a/x1, b/x2][c/x3]f(X)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="uncurry"></a>uncurry(HigherGoal, Goal)</KBD>

<BLOCKQUOTE>
Flatten a <KBD>HigherGoal</KBD> to a normal <KBD>Goal</KBD>.
<BR><KBD>mode uncurry(+term, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- uncurry(f(a)(b),X).
<BR>
<BR>X = f(a, b)
</KBD>
</BLOCKQUOTE>




<!-- Section 3.4.4 -->
<H2>
<A NAME="Section3.4.4" >3.4.4 List Processing</A>
</H2>

<P>This set of predicates provides some frequently used list operations.  The set can be divided into two parts according to the type of list on which the predicates operate.  The predicates which manipulate open lists (i.e. lists terminated with a variable) have a <KBD>open_</KBD> prefix in the name. Otherwise, closed (proper) lists are assumed.  When <KBD><a href="#==">==/2</a></KBD> is used for comparison instead of unification, the predicate name is suffixed with an <KBD>_eq</KBD>.

<P>Predicates:

<P><KBD><a name="open_list"></a>open_list(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is an open list.
<BR><KBD>mode open_list(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- open_list([a, b, c]).
<BR>
<BR>no
<BR>
<BR>| ?- open_list([a, b, c | Tail]).
<BR>
<BR>Tail = Tail
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="closed_list"></a>closed_list(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a closed (proper) list.
<BR><KBD>mode closed_list(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- closed_list([a, b, c]).
<BR>
<BR>yes
<BR>
<BR>| ?- closed_list([a, b, c | Tail]).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="closed_to_open"></a>closed_to_open(Closed, Open)</KBD>

<BLOCKQUOTE>
Convert a <KBD>Closed</KBD> list to an <KBD>Open</KBD> list by appending an unbound variable.
<BR><KBD>mode closed_to_open(+closed_list(term), ?list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- Closed = [a, b, c], closed_to_open([a, b, c], Open), 
<BR>write(Open), nl, fail.
<BR>[a, b, c|_1D0]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_to_closed"></a>open_to_closed(List)</KBD>

<BLOCKQUOTE>
Convert <KBD>List</KBD> from an open list to a closed list by binding the tail to <KBD>[]</KBD>.
<BR><KBD>mode open_to_closed(?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- Open = [a, b, c | Tail], open_to_closed(Open), 
<BR>write(Open), nl, fail.
<BR>[a, b, c]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="delete"></a>delete(Term, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is <KBD>List1</KBD> after deleting an instance of <KBD>Term</KBD>. The comparison is performed by unification.
<BR><KBD>mode delete(+term, +closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- delete(a, [a, b, d, a, c], List2).
<BR>
<BR>List2 = [b, d, a, c];
<BR>
<BR>List2 = [a, b, d, c];
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="delete_all"></a>delete_all(Term, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is <KBD>List1</KBD> after deleting all the instances of <KBD>Term</KBD>. The comparison is performed by unification.
<BR><KBD>mode delete_all(+term, +closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- delete_all(a, [a, b, d, a, c], List2).
<BR>
<BR>List2 = [b, d, c];
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="intersect_list"></a>intersect_list(List1, List2, List3)</KBD>

<BLOCKQUOTE>
<KBD>List3</KBD> contains all the elements which appear in both <KBD>List1</KBD> and <KBD>List2</KBD>.  The comparison is performed by <KBD>==/2</KBD>.
<BR><KBD>mode intersect_list(@closed_list(term), @closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- intersect_list([a, b, d, a, c], [c, b, e, a, f], List3).
<BR>
<BR>List3 = [a, b, a, c]
<BR>
<BR>| ?- intersect_list([a, B, d, a, C], [C, b, e, a, f], List3).
<BR>
<BR>B = B
<BR>C = C
<BR>List3 = [a, a, C]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="union_list"></a>union_list(List1, List2, List3)</KBD>

<BLOCKQUOTE>
<KBD>List3</KBD> contains all the elements which appear in either <KBD>List1</KBD> or <KBD>List2</KBD>.  The comparison is performed by <KBD>==/2</KBD>.
<BR><KBD>mode union_list(+closed_list(term), +closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?closed_list(term)</KBD>

<P>Example:

<KBD>
<P>| ?- union_list([a, b, d, a, c], [c, b, e, a, f], List3).
<BR>
<BR>List3 = [d, c, b, e, a, f]
<BR>
<BR>| ?- union_list([a, B, d, a, C], [C, b, e, a, f], List3).
<BR>
<BR>B = B
<BR>C = C
<BR>List3 = [B, d, C, b, e, a, f]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="diff_list"></a>diff_list(List1, List2, List3)</KBD>

<BLOCKQUOTE>
<KBD>List3</KBD> contains all those elements in <KBD>List1</KBD> but not in <KBD>List2</KBD>. 
The comparison is performed by <KBD>==/2</KBD>.  
<BR><KBD>mode diff_list(+closed_list(Term), +closed_list(Term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?closed_list(Term))</KBD>

<P>Example:

<KBD>
<P>| ?- diff_list([a, b, d, a, c], [c, b, e, a, f], List3).
<BR>
<BR>List3 = [d]
<BR>
<BR>| ?- diff_list([a, B, d, a, C], [C, b, e, a, f], List3).
<BR>
<BR>B = B
<BR>C = C
<BR>List3 = [B, d]
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="distribute"></a>distribute(Term, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is a list of pairs <KBD>(Term, X)</KBD> for each <KBD>X</KBD> in <KBD>List1</KBD>.
<BR><KBD>mode distribute(+term, +closed_list(term), ?closed_list(term))</KBD>
<BR><KBD>mode distribute(?term, ?closed_list(term), +closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- distribute(X, [a, b, c], List2).
<BR>
<BR>X = X
<BR>List2 = [(X , a), (X , b), (X , c)]
<BR>
<BR>| ?- distribute(Term, List1, [(A, 1), (A, 2), (A, 3)]).
<BR>
<BR>Term = A
<BR>List1 = [1, 2, 3]
<BR>A = A
<BR>
<BR>| ?- distribute(Term, List1, [(A, 1), (B, 2), (C, 3)]).
<BR>
<BR>Term = C
<BR>List1 = [1, 2, 3]
<BR>A = C
<BR>B = C
<BR>C = C
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="distribute_left"></a>distribute_left(Term, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is a list of pairs <KBD>(Term, X)</KBD> for each <KBD>X</KBD> in <KBD>List1</KBD>.
<BR><KBD>mode distribute_left(+term, +closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?closed_list(term))</KBD>
<BR><KBD>mode distribute_left(?term, ?closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- distribute_left(f(G), [a, b, c], List2).
<BR>
<BR>G = G
<BR>List2 = [(f(G) , a), (f(G) , b), (f(G) , c)]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="distribute_right"></a>distribute_right(Term, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is a list of pairs <KBD>(X, Term)</KBD> for each <KBD>X</KBD> in <KBD>List1</KBD>.
<BR><KBD>mode distribute_right(+term, +closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?closed_list(term))</KBD>
<BR><KBD>mode distribute_right(?term, ?closed_list(term), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- distribute_right(term, [a, b, c], List2).
<BR>
<BR>List2 = [(a , term), (b , term), (c , term)]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="append"></a>append(List1, List2, List3)</KBD>

<BLOCKQUOTE>
<KBD>List3</KBD> is <KBD>List1</KBD> appended to <KBD>List2</KBD>.
<BR><KBD>mode append(+closed_list(term), ?list(term), ?list(term))</KBD>
<BR><KBD>mode append(?list(term), ?list(term), +closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- append([a, b, c], [b, c, d], List3).
<BR>
<BR>List3 = [a, b, c, b, c, d]
<BR>
<BR>| ?- append([a, b, c], List2, List3).
<BR>
<BR>List2 = List2
<BR>List3 = [a, b, c|List2]
<BR>
<BR>| ?- append(List1, List2, [a, b, c, d]).
<BR>
<BR>List1 = []
<BR>List2 = [a, b, c, d];
<BR>
<BR>List1 = [a]
<BR>List2 = [b, c, d];
<BR>
<BR>List1 = [a, b]
<BR>List2 = [c, d];
<BR>
<BR>List1 = [a, b, c]
<BR>List2 = [d];
<BR>
<BR>List1 = [a, b, c, d]
<BR>List2 = [];
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="length"></a>length(List, N)</KBD>

<BLOCKQUOTE>
The length of <KBD>List</KBD> is <KBD>N</KBD>.
<BR><KBD>mode length(@closed_list(term), ?integer)</KBD>
<BR><KBD>mode length(-closed_list(term), @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- length([a, b, c], Length).
<BR>
<BR>Length = 3
<BR>
<BR>| ?- length(List, 3).
<BR>
<BR>List = [A, B, C]
<BR>
<BR>| ?- length([a, b, c |Rest], 5).
<BR>
<BR>Rest = [A, B]
<BR>
<BR>| ?- length(List, Length).
<BR>
<BR>List = []
<BR>Length = 0;
<BR>
<BR>List = [A]
<BR>Length = 1;
<BR>
<BR>List = [A, B]
<BR>Length = 2;
<BR>
<BR>List = [A, B, C]
<BR>Length = 3
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="member"></a>member(Term, List)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is an element of <KBD>List</KBD>.  The comparison is performed by unification.
<BR><KBD>mode member(?term, ?list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- member(b, [a, b, c]).
<BR>
<BR>yes
<BR>
<BR>| ?- member(A, [a, b, c]).
<BR>
<BR>A = a;
<BR>
<BR>A = b;
<BR>
<BR>A = c;
<BR>
<BR>no
<BR>
<BR>| ?- member(Term, List).
<BR>
<BR>List = [Term|A];
<BR>
<BR>List = [A, Term|B];
<BR>
<BR>List = [A, B, Term|C];
<BR>
<BR>List = [A, B, C, Term|D]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="member_eq"></a>member_eq(Term, List)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is an element of <KBD>List</KBD>. The comparison is performed by <KBD>==/2</KBD>.
<BR><KBD>mode member_eq(@term, @closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- member_eq(Term, [a, b, c]).
<BR>
<BR>no
<BR>
<BR>| ?- member_eq(b, [a, b, c]).
<BR>
<BR>yes
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="open_append"></a>open_append(Open, List)</KBD>

<BLOCKQUOTE>
Append an open list, <KBD>Open</KBD>, and a closed list, <KBD>Closed</KBD>, to produce a new open list by instantiating the tail of <KBD>Open</KBD>.
<BR><KBD>mode open_append(+open_list(term), @closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- List = [1, 2 | Tail], open_append(List, [3, 4]).
<BR>
<BR>List = [1, 2, 3, 4|A]
<BR>Tail = [3, 4|A]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_length"></a>open_length(List, N)</KBD>

<BLOCKQUOTE>
The length of the open <KBD>List</KBD> is <KBD>N</KBD>, ignoring the tail.
<BR><KBD>mode open_length(@open_list(term), -integer)</KBD>
<BR><KBD>mode open_length(?open_list(term), @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- open_length([a, b, c | Tail], Length).
<BR>
<BR>Tail = Tail
<BR>Length = 3
<BR>
<BR>| ?- open_length(List, 5).
<BR>
<BR>List = [A, B, C, D, E|F]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_member"></a>open_member(Term, Open)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is an element of <KBD>Open</KBD>. The comparison is performed by unification with existing elements only.
<BR><KBD>mode open_member(+term, +open_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- open_member(b, [a, b, c | Tail]).
<BR>
<BR>Tail = Tail
<BR>
<BR>| ?- open_member(Term, [a, b, c | Tail]).
<BR>
<BR>Term = a
<BR>Tail = Tail;
<BR>
<BR>Term = b
<BR>Tail = Tail;
<BR>
<BR>Term = c
<BR>Tail = Tail;
<BR>
<BR>no
<BR>
<BR>| ?- open_member(Term, List).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_member_eq"></a>open_member_eq(Term, Open)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is an element of <KBD>Open</KBD>. The comparison is performed by <KBD>==/2</KBD>.
<KBD>mode open_member_eq(@term, @open_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- open_member_eq(Term, [a, b, c | Tail]).
<BR>
<BR>no
<BR>
<BR>| ?- open_member_eq(b, [a, b, c | Tail]).
<BR>
<BR>Rest = Rest
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_tail"></a>open_tail(Open, Variable)</KBD>

<BLOCKQUOTE>
<KBD>Variable</KBD> is the tail of the open list, <KBD>Open</KBD>.
<P><KBD>mode open_tail(+open_list(term), -var)</KBD>

<P>Example:

<KBD>
<P>| ?- open_tail([a, b, c | Tail], Var).
<BR>
<BR>Tail = Var
<BR>Var = Var
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="remove_duplicates"></a>remove_duplicates(List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is <KBD>List1</KBD> without duplicates.
<BR><KBD>mode remove_duplicates(@closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- remove_duplicates([a, b, d, a, c], List2).
<BR>
<BR>List2 = [b, d, a, c]
<BR>
<BR>| ?- remove_duplicates([a, B, c, a, B, C], List2).
<BR>
<BR>B = B
<BR>C = C
<BR>List2 = [c, a, B, C]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="reverse"></a>reverse(List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is the reverse of <KBD>List1</KBD>. The comparison is performed by <KBD><a href="#==">==/2</a></KBD>.
<BR><KBD>mode reverse(+closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- reverse([a, b, d, a, c], List2).
<BR>
<BR>List2 = [c, a, d, b, a]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="search_insert"></a>search_insert(Term, Open)</KBD>

<BLOCKQUOTE>
Search through <KBD>Open</KBD> for <KBD>Term</KBD>. If not found, insert <KBD>Term</KBD>. The comparison is performed by <KBD><a href="#==">==/2</a></KBD>.
<BR><KBD>mode search_insert(@term, +open_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- List = [a, b, d, a, c | Tail], search_insert(d, List).
<BR>
<BR>List = [a, b, d, a, c|Tail]
<BR>Tail = Tail
<BR>
<BR>| ?- List = [a, b, d, a, c | Tail], search_insert(f, List).
<BR>
<BR>List = [a, b, d, a, c, f|A]
<BR>Tail = [f|A]
<BR>
<BR>| ?- List = [a, b, D, a, c | Tail], search_insert(D, List).
<BR>
<BR>List = [a, b, D, a, c|Tail]
<BR>D = D
<BR>Tail = Tail
<BR>
<BR>| ?- List = [a, b, D, a, c | Tail], search_insert(E, List).
<BR>
<BR>List = [a, b, D, a, c, E|A]
<BR>D = D
<BR>Tail = [E|A]
<BR>E = E
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sort"></a>sort(List1, List2)</KBD>

<BLOCKQUOTE>
List2 is the result of sorting <KBD>List1</KBD> into the standard order with duplicates removed.
<BR><KBD>mode sort(@closed_list(term), -closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- sort([a, b, d, a, c], List2).
<BR>
<BR>List2 = [a, b, c, d]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="sort"></a>sort(List1, List2, Order)</KBD>

<BLOCKQUOTE>
List2 is the result of sorting <KBD>List1</KBD> into the order defined by the predicate <KBD>Order</KBD> with duplicates removed. So
<BR>
<KBD>sort(List1, List2)</KBD>
is the same as
<KBD>sort(List1, List2, '@<')</KBD>

<BR><KBD>mode sort(@closed_list(term), -closed_list(term), @goal)</KBD>
</BLOCKQUOTE>
<P><KBD><a name="msort"></a>msort(List1, List2, Order), msort(List1, List2, Order)</KBD>
<BLOCKQUOTE>
The same as the above sorts but with duplicates not removed.
</BLOCKQUOTE>

<!-- Section 3.5 -->
<H2>
<A NAME="Section3.5">3.5 All Solutions</A>
</H2>

<P>All the solutions for <KBD>Goal</KBD> are collected into <KBD>List</KBD> according to the <KBD>Template</KBD> format.  The solutions are obtained via backtracking.
<BR>For the examples given for each predicate below, it is assummed that the following predicate definition has been added to the system.

<P><KBD>p(a, 1). p(a, 2). p(c, 1). p(b, 6). p(c, 4).</KBD>

<P>Predicates:

<P><KBD><a name="^"></a>Variable^Goal</KBD>

<BLOCKQUOTE>
Execute <KBD>Goal</KBD>.  It is treated the same as <KBD>call(Goal)</KBD>. It is expected to be used only inside <KBD><a href="#bagof">bagof/3</a></KBD>, <KBD><a href="#findall">findall/3</a></KBD>, and <KBD><a href="#setof">setof/3</a></KBD>, where it represents existential quantification.
<BR><KBD>mode +var ^ +goal</KBD>
</BLOCKQUOTE>

<P><KBD><a name="bagof"></a>bagof(Template, Goal, List)</KBD>

<BLOCKQUOTE>
<KBD>List</KBD> is the collection of instances of <KBD>Template</KBD>, which satisfy the <KBD>Goal</KBD>.
<BR><KBD>mode bagof(@term, @goal, ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- bagof(X, p(X,Y), R).
<BR>
<BR>X = X
<BR>Y = 1
<BR>R = [a, c];
<BR>
<BR>X = X
<BR>Y = 2
<BR>R = [a];
<BR>
<BR>X = X
<BR>Y = 4
<BR>R = [c];
<BR>
<BR>X = X
<BR>Y = 6
<BR>R = [b];
<BR>
<BR>no
<BR>
<BR>| ?- bagof(X, Y^p(X,Y), R).
<BR>
<BR>X = X
<BR>Y = Y
<BR>R = [a, a, c, b, c]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="setof"></a>setof(Template, Goal, List)</KBD>

<BLOCKQUOTE>
<KBD>List</KBD> is the collection of instances of <KBD>Template</KBD>, which satisfy the <KBD>Goal</KBD>.  Duplicates are removed and the result is sorted in the standard order. 
<BR><KBD>mode setof(@term, @goal, ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- setof(X, p(X,Y), R).
<BR>
<BR>X = X
<BR>Y = 1
<BR>R = [a, c];
<BR>
<BR>X = X
<BR>Y = 2
<BR>R = [a];
<BR>
<BR>X = X
<BR>Y = 4
<BR>R = [c];
<BR>
<BR>X = X
<BR>Y = 6
<BR>R = [b];
<BR>
<BR>no
<BR>
<BR>| ?- setof(X, Y^p(X,Y), R).
<BR>
<BR>X = X
<BR>Y = Y
<BR>R = [a, b, c]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="findall"></a>findall(Template, Goal, List)</KBD>

<BLOCKQUOTE>
<KBD>List</KBD> is the collection of instances of <KBD>Template</KBD>, which satisfy the <KBD>Goal</KBD>.  Unlike <KBD><a href="#bagof">bagof/3</a></KBD>, there is an implied existential quantification of all variables not in <KBD>Template</KBD>.
<BR><KBD>mode findall(@term, @goal, ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- findall(X, p(X,Y), R).
<BR>
<BR>X = X
<BR>Y = Y
<BR>R = [a, a, c, b, c]
<BR>
<BR>| ?- findall(R, setof(X, p(X,Y), R), S).
<BR>
<BR>R = R
<BR>X = X
<BR>Y = Y
<BR>S = [[a, c], [a], [c], [b]]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="forall"></a>forall(Goal, Test)</KBD>

<BLOCKQUOTE>
This predicate succeeds (without binding variables) iff whenever <KBD>Goal</KBD> succeeds, <KBD>Test</KBD> also succeeds.

<BR><KBD>mode forall(@goal, @goal)</KBD>

<P>Example:

<KBD>
<P>| ?- forall(member(X, [1,2,3]), integer(X)).
<BR>
<BR>X = X
<BR>
<BR>| ?- forall(member(X, [5,4,1,3,6]), X > 2).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<!-- Section 3.6 -->
<H2>
<A NAME="Section3.6">3.6 Arithmetic</A>
</H2>

<P>These predicates perform arithmetical operations on the arguments, which are arithmetic expressions.  Each expression can be a mixture of numbers, variables, and arithmetic functions.  The expression must be free of unbound variables when it is evaluated.

<P>Predicates:

<P><KBD><a name="=:="></a>	Expression1 =:= Expression2</KBD>

<BLOCKQUOTE>
<KBD>Expression1</KBD> is numerically equal to <KBD>Expression2</KBD>.
<BR><KBD>mode @ground =:= @ground</KBD>
</BLOCKQUOTE>

<P><KBD><a name="=\="></a>Term1 =\= Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> and <KBD>Term2</KBD> are not numerically equal.
<BR><KBD>mode @ground =\= @ground</KBD>
</BLOCKQUOTE>

<P><KBD><a name="<"></a>Expression1 &#60; Expression2</KBD>

<BLOCKQUOTE>
<KBD>Expression1</KBD> is numerically less than <KBD>Expression2</KBD>.
<BR><KBD>mode @ground &#60; @ground</KBD>
</BLOCKQUOTE>

<P><KBD><a name="=<"></a>Expression1 =&#60; Expression2</KBD>

<BLOCKQUOTE><KBD>Expression1</KBD> is numerically less than or equal to <KBD>Expression2</KBD>.
<BR><KBD>mode @ground =&#60; @ground</KBD>
</BLOCKQUOTE>

<P><KBD><a name=">"></a>Expression1 &#62; Expression2</KBD>

<BLOCKQUOTE>
<KBD>Expression1</KBD> is numerically greater than <KBD>Expression2</KBD>.
<BR><KBD>mode @ground &#62; @ground</KBD>
</BLOCKQUOTE>

<P><KBD><a name=">="></a>Expression1 &#62;= Expression2</KBD>

<BLOCKQUOTE>
<KBD>Expression1</KBD> is numerically greater than or equal to <KBD>Expression2</KBD>.
<BR><KBD>mode @ground &#62;= @ground</KBD>

<P>Example:

<KBD>
<P>| ?- 12 =:= 3 * 4.
<BR>
<BR>| ?- 12 =\= 14.
<BR>
<BR>| ?- -3 &#60; 3.
<BR>
<BR>| ?- 3*4 =&#60; 12.
<BR>
<BR>| ?- A = 12, A &#62; 8.
<BR>
<BR>| ?- A = 12, B = -2,  A &#62;= B.
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="between"></a>between(Integer1, Integer2, N)</KBD>

<BLOCKQUOTE>
<KBD>Integer1 &#60;= N &#60;= Integer2</KBD>. This predicate can generate <KBD>N</KBD>, and may be used to provide a "for loop" like iteration driven by failure.
<BR><KBD>mode between(@integer, @integer, ?integer)</KBD>

<P>Example: 

<KBD>
<P>| ?- between(1, 3, A).
<BR>
<BR>A = 1;
<BR>
<BR>A = 2;
<BR>
<BR>A = 3;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="is"></a>is(Value, Expression)</KBD>

<BLOCKQUOTE>
The result of evaulating <KBD>Expression</KBD> unifies with <KBD>Value</KBD>. The following operators are available.

<UL type="disc">
<LI>
<KBD>+</KBD>
<BR>Addition
<LI>
<KBD>-</KBD>
<BR>Subtraction/Negation
<LI>
<KBD>*</KBD>
<BR>Multiplication
<LI>
<KBD>//</KBD>
<BR>Integer division
<LI>
<KBD>/</KBD>
<BR>Division 
<LI>
<KBD>rem</KBD>
<BR>Reminder (It is currently the same as <KBD>mod</KBD>)
<LI>
<KBD>mod</KBD>
<BR>Modulus
<LI>
<KBD>**</KBD>
<BR>Power
<LI>
<KBD>&#62;&#62;</KBD>
<BR>Bitwise right shift.  Effectively divides by two and rounds towards negative infinity.
<LI>
<KBD>&#60;&#60;</KBD>
<BR>Bitwise left shift.  Effectively multiplies by two.
<LI>
<KBD>/\</KBD>
<BR>Bitwise AND
<LI>
<KBD>\/</KBD>
<BR>Bitwise OR
<LI>
<KBD>\</KBD>
<BR>Bitwise complement
<LI>
<KBD>abs</KBD>
<BR>Absolute value
<LI>
<KBD>sqrt</KBD>
<BR>Square root
<LI>
<KBD>exp</KBD>
<BR>Exponentiation
<LI>
<KBD>sin</KBD>
<BR>Sin
<LI>
<KBD>cos</KBD>
<BR>Cos
<LI>
<KBD>tan</KBD>
<BR>Tan
<LI>
<KBD>asin</KBD>
<BR>Asin
<LI>
<KBD>acos</KBD>
<BR>Acos
<LI>
<KBD>atan</KBD>
<BR>Atan
<LI>
<KBD>round</KBD>
<BR>Round to nearest integer
<LI>
<KBD>floor</KBD>
<BR>Floor
<LI>
<KBD>ceiling</KBD>
<BR>Ceiling
<KBD>truncate</KBD>
<BR>Truncate
</UL>

<P>
The atoms <KBD>pi</KBD> and <KBD>e</KBD> are also available for use in
arithmetic expressions.
<P><KBD>is</KBD> is an infix operator. 
<BR><KBD>mode is(?number, @gcomp)</KBD>
<BR><KBD>mode is(?number, @number)</KBD>

<P>Example: 

<KBD>
<P>| ?- A is 3 + 5.
<BR>
<BR>A = 8
<BR>
<BR>| ?- A is 7 / 4.
<BR>
<BR>A = 1
<BR>
<BR>| ?- A is 9 // 2.
<BR>
<BR>A = 4
<BR>
<BR>| ?- A is 7 mod 4.
<BR>
<BR>A = 3
<BR>
<BR>| ?- A is 2'1010 /\ 2'1001.
<BR>
<BR>A = 8
<BR>
<BR>| ?- A is 10 \/ 9.
<BR>
<BR>A = 11
<BR>
<BR>| ?- A is pi*3.5**2.
<BR>
<BR>A = 38.4845
</KBD>
</BLOCKQUOTE>

<P>The following predicates provide uniformly distributed pseudo-random numbers.

<P>Predicates:

<P><KBD><a name="srandom"></a>srandom(Seed)</KBD>

<BLOCKQUOTE>
Initialize the random numbers with a seed. If <KBD>Seed</KBD> is supplied
then that seed is used for initialization. Otherwise, a seed is generated from the current time and that seed is used for initialization and <KBD>Seed</KBD>
is instantiated to that value.
<BR><KBD>mode srandom(?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="random"></a>random(R)</KBD>

<BLOCKQUOTE>
<KBD>R</KBD> is 
unified with a random double between 0 and 1.
<BR><KBD>mode random(?double)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="randomi"></a>random(Lower, Upper, I)</KBD>

<BLOCKQUOTE>
<KBD>I</KBD> is 
unified with a random integer in the range <KBD>[Lower, Upper]</KBD>.
<BR><KBD>mode random(@integer, @integer, ?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="irandom"></a>irandom(I)</KBD>

<BLOCKQUOTE>
<KBD>I</KBD> is 
unified with a random integer.
<BR><KBD>mode irandom(?integer)</KBD>
</BLOCKQUOTE>




<!-- Section 3.7 -->
<H2>
<A NAME="Section3.7">3.7 Term Expansion</A>
</H2>

<P>When a file is consulted or compiled, every clause, fact and query within it is subject to term expansion.  User term expansions are installed by defining clauses for <KBD>term_expansion/2,3</KBD>; the <KBD>add_</KBD> and <KBD>del_</KBD> predicates are provided to assist with this. <KBD>Goal</KBD> is a higher-order goal that will be called with two or three extra arguments: the input and output terms (<KBD>Term1</KBD>, <KBD>Term2</KBD>), and perhaps a list <KBD>VariableNames</KBD> of <KBD>(Variable=Name)</KBD> pairs for the input clause (as in <KBD><a href="#read_term">read_term/[2,3]</a></KBD>).  Definite Clause Grammar (DCG) expansions are carried out automatically after user expansions.

<P>Multi-term expansion is defined using term expansion.  When multi-term expansion is active, the current set of multi-expansions will be applied repeatedly to each clause until none succeeds.  It is the user's responsibility to avoid cycles; a depth limit helps identify these.	

<P>Subterm expansion is defined using term expansion.  When subterm expansion is active, the current set of subterm expansions will be applied to every subterm of every clause until none succeeds.  It is the user's responsibility to avoid cycles; a depth limit helps identify these.

<P>The output of term expansion and multi-term expansion (but not of subterm expansion) may be a single term or a list of terms.

<P>Predicates:

<P><KBD><a name="list_expansions"></a>list_expansions</KBD>

<BLOCKQUOTE>
List all current term expansions, multi-term expansions and subterm expansions.
</BLOCKQUOTE>

<P><KBD><a name="add_expansion"></a>add_expansion(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the definition of <KBD>term_expansion/2</KBD>. <KBD>Goal</KBD> will be called with two extra arguments: the input term and the output term (or list of terms).
<BR><KBD>mode add_expansion(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_expansion_vars"></a>add_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the definition of <KBD>term_expansion/3</KBD>. <KBD>Goal</KBD> will be called with three extra arguments: the input term and the output term (or list of terms), and a list of <KBD>Variable=Name</KBD> pairs for the term being expanded.
<BR><KBD>mode add_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_multi_expansion"></a>add_multi_expansion(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the current set of multi-term expansions. 
<BR>Also add <KBD><a href="#multi_expand_term">multi_expand_term/2</a></KBD> to the definition of <KBD>term_expansion/2</KBD> if necessary. <KBD>Goal</KBD> will be called with two extra arguments: the input term and the output term (or list of terms).
<BR><KBD>mode add_multi_expansion(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_multi_expansion_vars"></a>add_multi_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the current set of multi-term expansions with variables and add <KBD><a href="#multi_expand_term">multi_expand_term/3</a></KBD> to the definition of <KBD>term_expansion/3</KBD> if necessary.  <KBD>Goal</KBD> will be called with three extra arguments: the input term and the output term (or list of terms), and a list of <KBD>Variable=Name</KBD> pairs for the term being expanded.
<BR><KBD>mode add_multi_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_subterm_expansion"></a>add_subterm_expansion(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the current set of subterm expansions.
<BR>Also add <KBD><a href="#expand_subterms">expand_subterms/2</a></KBD> to the definition of <KBD>term_expansion/2</KBD> if necessary. <KBD>Goal</KBD> will be called with two extra arguments: the input subterm and the output subterm.
<BR><KBD>mode add_subterm_expansion(@goal)</KBD>

<P>Examples (See end of section):

<KBD>
<P>| ?- assert(macro_eg(append3(A,B,C,D), 
<BR>(append(A,X,D), append(B,C,X)))).
<BR>
<BR>| ?- add_subterm_expansion(macro_eg).
<BR>
<BR>yes
<BR>
<BR>| ?- list_expansions.
<BR>term_expansion(B, A) :-
<BR>    macro_eg(B, A).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_subterm_expansion_vars"></a>add_subterm_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> to the current set of subterm expansions with variables, and add <KBD><a href="#expand_subterms">expand_subterms/3</a></KBD> to the definition of <KBD>term_expansion/3</KBD> if necessary. <KBD>Goal</KBD> will be called with three extra arguments: the input subterm and the output subterm, and a list of <KBD>Variable=Name</KBD> pairs for the term being expanded.
<P><KBD>mode add_subterm_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_expansion"></a>del_expansion(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the definition of <KBD>term_expansion/2</KBD>.
<BR><KBD>mode del_expansion(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_expansion_vars"></a>del_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the definition of <KBD>term_expansion/3</KBD>.
<BR><KBD>mode del_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_multi_expansion"></a>del_multi_expansion(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the current set of multi-term expansions, and delete <KBD><a href="#multi_expand_term">multi_expand_term/2</a></KBD> from the definition of <KBD>term_expansion/2</KBD> if it is no longer necessary.
<BR><KBD>mode del_multi_expansion(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_multi_expansion_vars"></a>del_multi_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the current set of multi-term expansions with variables, and delete <KBD><a href="#multi_expand_term">multi_expand_term/3</a></KBD> from the definition of <KBD>term_expansion/3</KBD> if it is no longer necessary.
<BR><KBD>mode del_multi_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_subterm_expansion"></a>del_subterm_expansion(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the current set of subterm expansions, and delete <KBD><a href="#expand_subterms">expand_subterms/2</a></KBD> from the definition of <KBD>term_expansion/2</KBD> if it is no longer necessary.
<BR><KBD>mode del_subterm_expansion(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_subterm_expansion_vars"></a>del_subterm_expansion_vars(Goal)</KBD>

<BLOCKQUOTE>
Delete <KBD>Goal</KBD> from the current set of subterm expansions with variables, and delete <KBD><a href="#expand_subterms">expand_subterms/3</a></KBD> from the definition of <KBD>term_expansion/3</KBD> if it is no longer necessary.
<BR><KBD>mode del_subterm_expansion_vars(@goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="'C'"></a>'C'(List1, Term, List2)</KBD>

<BLOCKQUOTE>
<KBD>List1</KBD> is connected by <KBD>Term</KBD> to <KBD>List2</KBD>.
<BR>This predicate typically appears only in preprocessed DCG rules.
<BR><KBD>mode 'C'(?list(term), ?term, ?list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- 'C'([a,b,c],Y,Z).
<BR>
<BR>Y = a
<BR>Z = [b, c]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="dcg"></a>dcg(Rule, Clause)</KBD>

<BLOCKQUOTE>
<KBD>Clause</KBD> is the expansion of Definite Clause Grammars <KBD>Rule</KBD>.
<BR><KBD>mode dcg(@nonvar, ?nonvar)</KBD>

<P>Examples (See end of section):

<KBD>
<P>| ?- dcg((pairing(P1 + P2) --&#62; filler, pair(P1), pairing(P2)), X),
<BR>portray_clause(X),fail.
<BR>
<BR>pairing(P1 + P2, D, A) :- 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(D, C), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pair(P1, C, B), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pairing(P2, B, A).
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="expand_term"></a>expand_term(Term1, Term2)</KBD>
<BR><KBD>expand_term(Term1, Term2, VariableNames)</KBD>

<BLOCKQUOTE>
<KBD>Term2</KBD> is the result of applying term expansions to <KBD>Term1</KBD>. 
<BR><KBD>VariableNames</KBD> is a list of variables and their names.
<BR><KBD>mode expand_term(+term, ?term)</KBD>
<BR><KBD>mode expand_term(+term, ?term, ?closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="multi_expand_term"></a>multi_expand_term(Term1, Term2)</KBD>
<BR><KBD>multi_expand_term(Term1, Term2, VariableNames)</KBD>

<BLOCKQUOTE>
<KBD>Term2</KBD> is the result of applying multi-term expansions to <KBD>Term1</KBD>. 
<BR><KBD>VariableNames</KBD> is a list of variables and their names.
<BR><KBD>mode multi_expand_term(+term, ?term)</KBD>
<BR><KBD>mode multi_expand_term(+term, ?term, ?closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="expand_subterms"></a>expand_subterms(Term1, Term2)</KBD>
<BR><KBD>expand_subterms(Term1, Term2, Vars)</KBD>

<BLOCKQUOTE>
<KBD>Term2</KBD> is the result of applying subterm expansions to <KBD>Term1</KBD>. <KBD>VariableNames</KBD> is a list of variables and their names.
<BR><KBD>mode expand_subterms(+term, ?term)</KBD>
<BR><KBD>mode expand_subterms(+term, ?term, ?closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="multi_expand_depth_limit"></a>multi_expand_depth_limit(Limit)</KBD>

<BLOCKQUOTE>
The depth limit for multi-term expansion is <KBD>Limit</KBD>. Multi-term expansion will stop and a warning (<KBD>range_exception</KBD>) will be generated if this limit is exceeded in any one term.  This built-in can be used to query the current limit or set a new one.  The default depth is 100.
<BR><KBD>mode multi_expand_depth_limit(?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="subterm_expand_depth_limit"></a>subterm_expand_depth_limit(Limit)</KBD>

<BLOCKQUOTE>
The depth limit for subterm expansion is <KBD>Limit</KBD>.  Subterm expansion will stop and a warning (<KBD>range_exception</KBD>) will be generated if this limit is exceeded in any one subterm.  This built-in can be used to query the current limit or set a new one. The default depth is 100.
<BR><KBD>mode subterm_expand_depth_limit(?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="phrase"></a>phrase(Rule, List1)</KBD>
<BR><KBD>phrase(Rule, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List1</KBD> is parsed according to the DCG <KBD>Rule</KBD>.  <KBD>List2</KBD> is the remaining symbols from <KBD>List1</KBD> after the parsing.
<BR><KBD>mode phrase(+nonvar, +closed_list(term))</KBD>
<BR><KBD>mode phrase(+nonvar, +closed_list(term), ?closed_list(term))</KBD>

<P>Examples (See end of section):

<KBD>
<P>| ?- phrase(pairing(T), "a(b(c())e)f").
<BR>
<BR>T = pair(pair(pair))
<BR>
<BR>| ?- phrase(pairing(T), "a(b(c())e)f(").
<BR>
<BR>no
<BR>
<BR>| ?- phrase(pairing(T), "a(b(c())e)f(", R).
<BR>
<BR>T = pair(pair(pair))
<BR>R = [40]
</KBD> 
</BLOCKQUOTE>

<P>The following example uses subterm expansion to achieve macro expansion.

<P>One way to append three lists together is to write and use a predicate that appends the lists. Another way is to think of <KBD>append3/4</KBD> as a macro for a pair of appends. Term expansion can then be used to expand occurrences of <KBD>append3/4</KBD> within programs.

<P>This can be achieved by first declaring the term expansion rule in a file (say <KBD>expand.ql</KBD>) as follows.

<KBD>
<P>macro_eg(append3(A,B,C,D), (append(A,X,D), append(B,C,X))).
<BR>
<P>?-add_subterm_expansion(macro_eg).
</KBD>

<P>This file can then be supplied to the Qu-Prolog compiler to term expand supplied programs. For example, assume the file <KBD>expand_eg.ql</KBD> contains the following definition.

<KBD>
<P>p(Term, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;extract_lists(Term, L1, L2, L3),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;append3(L1, L2, L3, L),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;process_lists(L, Result).
</KBD>

<P>The compiler can then be invoked to carry out term expansion as in the following example.

<KBD>
<P>qc -G -R expand expand_eg.ql
</KBD>

<P>The <KBD>-R</KBD> switch tells the compiler to use <KBD>expand.ql</KBD> (or <KBD>expand.qo</KBD> if it is compiled) for the term expansion rules and the <KBD>-G</KBD> switch tells the compiler to stop after term expansion. The result is that a file <KBD>expand_eg.qg</KBD> will be generated that is an encoded and term expanded version of <KBD>expand_eg.ql</KBD>. 

<KBD>
<P>p(Term, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;extract_lists(Term, L1, L2, L3),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;append(L1, A, L),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;append(L2, L3, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;process_lists(L, Result).
</KBD>

<P>The example given below uses a Definite Clause Grammar to determine the bracket pairing structure of a string of characters.

<P>The following rules define the grammar.

<KBD>
<P>pairing(P1 + P2) --&#62; filler, pair(P1), pairing(P2).
<BR>pairing(P) --&#62; filler, pair(P), filler.
<BR>
<BR>pair(pair) --&#62; [0'(], filler, [0')].
<BR>pair(pair(P)) --&#62; [0'(], pairing(P), [0')].
<BR>
<BR>filler --&#62; [X], {X \= 0'(, X \= 0')}, filler.
<BR>filler --&#62; [].
</KBD>

<P>When this grammar is compiled or consulted the DCG expansion will transform the grammar rules into the following Qu-Prolog rules. Note that Qu-Prolog code may appear within grammar rules as long as it is enclosed by parentheses (for example <KBD>{X \= 0'(, X \= 0')}</KBD>) and in this case the DCG expansion will leave this code untouched.

<KBD>
<P>pairing(D + C, B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(B, E),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pair(D, E, F),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pairing(C, F, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>pairing(C, B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(B, D),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pair(C, D, E),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(E, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>
<BR>filler(B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'C'(B, D, C),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;D \= 40,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;D \= 41,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(C, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>filler(A, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>
<BR>pair(pair, B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'C'(B, 40, C),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;filler(C, D),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'C'(D, 41, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>pair(pair(C), B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'C'(B, 40, D),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;pairing(C, D, E),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'C'(E, 41, A),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;true.
<BR>
</KBD>

<P>Once this grammar is consulted or loaded then <KBD><a href="#phrase">phrase/2</a></KBD> may be used to parse strings as in the following example.

<KBD>
<P>| ?- phrase(pairing(T), "a(b(c())()e)f()g").
<BR>
<BR>T = pair(pair(pair) + pair) + pair
</KBD>


<!-- Section 3.8 -->
<H2>
<A NAME="Section3.8">3.8 Database</A>
</H2>

<P>The system includes three non-backtrackable databases: the dynamic database, the record database, and the global state database.


<!-- Section 3.8.1 -->
<H3>
<A NAME="Section3.8.1">3.8.1 Dynamic Database</A>
</H3>

<P>Changes to the dynamic database can be achieved 
with the following predicates. 
The dynamic database is composed entirely of interpreted clauses. 
Clauses can be added to (asserted) or removed from (retracted) the 
dynamic database.  The predicates cannot be applied to compiled clauses.
<P>Clause indexing information is stored in a dynamic hash table that grows as more clauses are added. Consequently, if a dynamic predicate has many clauses
then it is more efficient to declare the expected size of the predicate so that
extending and rehashing is avoided. This is done with the <KBD>dynamic</KBD>
predicate.

<P>Predicates:

<P><KBD><a name="dynamic"></a>dynamic(PredicateName/Arity)</KBD>
<BR><KBD>dynamic(PredicateName/Arity, Index)</KBD>
<BR><KBD>dynamic(PredicateName/Arity, Index, Size)</KBD>

<BLOCKQUOTE>
<KBD>PredicateName</KBD> with <KBD>Arity</KBD> is declared to be an interpreted predicate, initially with no clauses.
<BR>The second argument determines the index argument - first argument indexing is the default.
<BR>The third argument declares the size of the indexing hash table for the predicate (default 4).
<BR><KBD>mode dynamic(@compound)</KBD>
<BR><KBD>mode dynamic(@compound,@integer)</KBD>
<BR><KBD>mode dynamic(@compound,@integer,@integer)</KBD>

<P>Example:

<KBD>
<P>| ?- p(A, B).
<BR>no definition for p/2
<BR>
<BR>no
<BR> 
<BR>| ?- dynamic(p/2).
<BR>
<BR>yes
<BR>
<BR>| ?- p(A, B).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="multifile"></a>multifile(PredicateName/Arity)</KBD>

<BLOCKQUOTE>
Esentially the same as <KBD>dynamic(PredicateName/Arity)</KBD> and is to provide an
approximation to multifile as used in other Prologs.
</BLOCKQUOTE>

<P><KBD><a name="assert"></a>assert(Clause)</KBD>

<BLOCKQUOTE>
Add the <KBD>Clause</KBD> to the end of the
current interpreted program. 
<BR><KBD>mode assert(@term)</KBD>

<P>Example:

<KBD>
<P>| ?- assert((p(X) :- q(X))).
<BR>
<BR>X = X
<BR>
</KBD>
</BLOCKQUOTE>


<P><KBD><a name="asserta"></a>asserta(Clause)</KBD>
<P><KBD><a name="assertz"></a>assertz(Clause)</KBD>

<BLOCKQUOTE>
Add the <KBD>Clause</KBD> to the beginning (end) of the current 
interpreted program. 

<P>Example:

<KBD>
<P>| ?- asserta((p(X,Y) :- q(X,Z), r(Z,Y))).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Z = Z
<BR>
<BR>| ?- assertz((p(X,Y) :- p(Y,X)), Ref).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Ref = 324747
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_name"></a>get_name(Clause, PredicateName/Arity)</KBD>

<BLOCKQUOTE>
The head of <KBD>Clause</KBD> has <KBD>PredicateName</KBD> and <KBD>Arity</KBD>.
<BR><KBD>mode get_name(@goal, ?gcomp)</KBD>

<P>Example:

<KBD>
<P>| ?- get_name((p(X,Y) :- q(X,Y)), Pred).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Pred = p / 2
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_predicate_timestamp"></a>get_predicate_timestamp(Predicates, StampedPredicates)</KBD>

<BLOCKQUOTE>
<KBD>Predicates</KBD> is a list of the form <KBD>P/N</KBD>
and
<KBD>StampedPredicates</KBD> is a list of the form <KBD>P/N-Stamp</KBD>.
The stamp is a number representing the number of times this predicate has been modified and
is useful for <KBD>thread_wait_on_goal</KBD> to prevent an unnecessary initial call of the goal. 
As with <KBD>thread_wait_on_goal</KBD>, the predicates can be prefixed with a <KBD>+</KBD> or a  <KBD>-</KBD> and in which case the stamp will be for a timestamp for asserting or retracting.
<BR><KBD>mode get_predicate_timestamp(@list, -list)</KBD>
</BLOCKQUOTE>
<P><KBD><a name="update_predicate_timestamp"></a>update_predicate_timestamp(OldStampedPredicates, StampedPredicates)</KBD>

<BLOCKQUOTE>
<KBD>OldStampedPredicates</KBD> and <KBD>StampedPredicates</KBD> are lists of the form <KBD>P/N-Stamps</KBD>.
This is like <KBD>get_predicate_timestamp</KBD> except that stamped predicates are used rather than predicates.
<BR><KBD>mode update_predicate_timestamp(@list, -list)</KBD>

</BLOCKQUOTE>
<P><KBD><a name="changed_predicates"></a>changed_predicates(StampedPredicates, SPredicates)</KBD>
<BLOCKQUOTE>
<KBD>StampedPredicates</KBD> is a list of the form <KBD>P/N-Stamp</KBD>
and
<KBD>Predicates</KBD> is a list of the form <KBD>P/N</KBD>.
<KBD>Predicates</KBD> is the list of all predicates from <KBD>StampedPredicates</KBD> that have more recent timestamps than those given.
<BR>Typically this is used in conjunction with <KBD>get_predicate_timestamp/2</KBD> above to determine what predicates have changed since the last call to <KBD>get_predicate_timestamp/2</KBD>.
<BR><KBD>mode changed_predicates(@list, -list)</KBD>


</BLOCKQUOTE>

<P><KBD><a name="clause"></a>clause(Head, Body)</KBD>

<BLOCKQUOTE>
There is an existing clause with the given <KBD>Head</KBD> and <KBD>Body</KBD>.
<BR><KBD>mode clause(+goal, ?goal)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- clause((p(A,B)), Body).
<BR>
<BR>A = A
<BR>B = B
<BR>Body = q(A, C) , r(C, B);
<BR>
<BR>A = A
<BR>B = B
<BR>Body = p(B, A);
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="listing"></a>listing</KBD>
<BR><KBD>listing(PredicateList)</KBD>

<BLOCKQUOTE>
List all interpreted predicates or only those given in <KBD>PredicateList</KBD>.

<P>Examples (Continued from last):

<KBD>
<P>| ?- listing.
<BR>p(A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;q(A).
<BR>p(B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;q(B, C),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;r(C, A).
<BR>p(B, A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;p(A, B).
<BR>
<BR>yes
<BR>
<BR>| ?- listing(p/1).
<BR>p(A) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;q(A).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>


<P><KBD><a name="retract"></a>retract(Clause)</KBD>

<BLOCKQUOTE>
Remove the first clause that matches <KBD>Clause</KBD>.
<BR><KBD>mode retract(+nonvar)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- retract((p(X) :- q(X))).
<BR>
<BR>X = X
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="retractall"></a>retractall(Head)</KBD>

<BLOCKQUOTE>
Remove all the clauses whose heads match <KBD>Head</KBD>.
<BR><KBD>mode retract(@goal)</KBD>

<P>Example: (Continued from last):

<KBD>
<P>| ?- retractall((p(A,B))).
<BR>
<BR>A = A
<BR>
<BR>| ?- clause((p(A,B)), Body).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="abolish"></a>abolish(PredicateName/Arity)</KBD>

<BLOCKQUOTE>
Make <KBD>PredicateName/Arity</KBD> undefined. This does not work on compiled code.
<BR><KBD>mode abolish(@gcomp)</KBD>

<P>Example:

<KBD>
<P>| ?- abolish(p/2).
<BR>
<BR>yes 
<BR>
<BR>| ?- p(A, B).
<BR>no definition for p/2
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_linking_clause"></a>add_linking_clause(HigherHead, HigherBody, Arity)</KBD>

<BLOCKQUOTE>
A collection of <KBD>Arity</KBD> new variables is added to the end of <KBD>HigherHead</KBD> and to the end of <KBD>HigherBody</KBD> to form <KBD>Head</KBD> and <KBD>Body</KBD> respectively.  The clause <KBD>Head :- Body</KBD> is then added to the database.
<BR><KBD>mode add_linking_clause(@nonvar, @nonvar, @integer)</KBD>

<P>Example:

<P>Linking clauses may be used for connecting data stored in the static code area with data stored in the dynamic database.

<P>Assume that there is a table of facts <KBD>compiled_facts/2</KBD> in the static code area and a table of facts <KBD>dynamic_facts/2</KBD> in the dynamic database. These facts can be linked together by executing the following goals. 

<P><KBD>add_linking_clause(all_facts, compiled_facts, 2)</KBD>
<BR><KBD>add_linking_clause(all_facts, dynamic_facts, 2)</KBD>

<P>This asserts the following rules to the dynamic database.

<P><KBD>all_facts(X,Y) :- compiled_facts(X,Y).</KBD>
<BR><KBD>all_facts(X,Y) :- dynamic_facts(X,Y).</KBD>

<P>The combined rules can then be queried via the <KBD>all_facts/2</KBD> predicate.		
</BLOCKQUOTE>

<P><KBD><a name="get_linking_clause"></a>get_linking_clause(HigherHead, HigherBody, Arity)</KBD>

<BLOCKQUOTE>
A collection of <KBD>Arity</KBD> new variables is added to the end of <KBD>HigherHead</KBD> and to the end of <KBD>HigherBody</KBD> to form <KBD>Head</KBD> and <KBD>Body</KBD> respectively.  The clause <KBD>Head :- Body</KBD> is then retrieved from the database.
<BR><KBD>mode get_linking_clause(+goal, ?goal, @integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- get_linking_clause(all_facts, Body, 2).
<BR>
<BR>Body = compiled_facts;
<BR>
<BR>Body = dynamic_facts;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="del_linking_clause"></a>del_linking_clause(HigherHead, HigherBody, Arity)</KBD>

<BLOCKQUOTE>
A collection of <KBD>Arity</KBD> new variables is added to the end of <KBD>HigherHead</KBD> and to the end of <KBD>HigherBody</KBD> to form <KBD>Head</KBD> and <KBD>Body</KBD> respectively.  The clause <KBD>Head :- Body</KBD> is then deleted from the database.
<BR><KBD>mode del_linking_clause(@goal, @goal, @integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- del_linking_clause(all_facts, dynamic_facts, 2).
<BR>
<BR>yes
<BR>
<BR>| ?- clause(all_facts(A,B), Body).
<BR>
<BR>A = A
<BR>B = B
<BR>Body = compiled_facts(A, B);
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="index"></a>index(PredicateName, Arity, N)</KBD>

<BLOCKQUOTE>
Index <KBD>PredicateName/Arity</KBD> with the <KBD>N</KBD>-th argument. 
The default is the first argument. 
This is used as a directive to the compiler to produce clause indexing 
for static code.
<BR><KBD>mode index(@atom, @integer, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- index(all_facts, 2, 2).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>


<!-- Section 3.8.2 -->
<H3>
<A NAME="Section3.8.2">3.8.2 Record Database</A>
</H3>

<P>The record database associates terms with atoms. 
Terms can be added to (<KBD>recorda/3</KBD>,<KBD>recordz/3</KBD>) or removed from (<KBD>erase/1</KBD>) the record database.		

<P>Predicates:

<P><KBD><a name="recorda"></a>recorda(Atom, Term, Reference)</KBD>
<BR><KBD><a name="recordz"></a>recordz(Atom, Term, Reference)</KBD>

<BLOCKQUOTE>
Record <KBD>Term</KBD> as the first (last) term associated with <KBD>Atom</KBD> in the record database. <KBD>Reference</KBD> is the reference to this entry.
<BR><KBD>mode recorda(@atom, @term, -integer)</KBD>
<BR><KBD>mode recordz(@atom, @term, -integer)</KBD>

<P>Example:

<KBD>
<P>| ?- recorda(colour, sky(blue), Ref).
<BR>
<BR>Ref = 70
<BR>
<BR>| ?- recorda(colour, sun(yellow), Ref).
<BR>
<BR>Ref = 72
<BR>
<BR>| ?- recordz(colour, grass(green), Ref).
<BR>
<BR>Ref = 74
<BR>
<BR>| ?- recordz(colour, ocean(blue), Ref).
<BR>
<BR>Ref = 76
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="recorded"></a>recorded(Atom, Term, Reference)</KBD>

<BLOCKQUOTE>
Lookup <KBD>Term</KBD> associated with <KBD>Atom</KBD> in the record database at <KBD>Reference</KBD>.
<BR><KBD>mode recorded(@atom, ?term, ?integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- recorded(colour, grass(Colour), Ref).
<BR>
<BR>Colour = green
<BR>Ref = 74
<BR>
<BR>| ?- recorded(colour, Object(blue), Ref).
<BR>
<BR>Object = sky
<BR>Ref = 70;
<BR>
<BR>Object = ocean
<BR>Ref = 76;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="instance"></a>instance(Reference, Term)</KBD>

<BLOCKQUOTE>
Unifies <KBD>Term</KBD> with the term at <KBD>Reference</KBD> in the record database.  This call does not instantiate variables in the term at <KBD>Reference</KBD>.
<BR><KBD>mode instance(@integer, +term)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- instance(70, Term).
<BR>
<BR>Term = sky(blue)
<BR>
<BR>| ?- instance(72, Object(Colour)).
<BR>
<BR>Object = sun
<BR>Colour = yellow
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="erase"></a>erase(Reference)</KBD>

<BLOCKQUOTE>
Erase the record database entry at <KBD>Reference</KBD>.
<BR><KBD>mode erase(@integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- erase(74).
<BR>
<BR>yes
<BR>
<BR>| ?- recorded(colour, Term, Ref).
<BR>
<BR>Term = sun(yellow)
<BR>Ref = 72;
<BR>
<BR>Term = sky(blue)
<BR>Ref = 70;
<BR>
<BR>Term = ocean(blue)
<BR>Ref = 76;
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>


<!-- Section 3.8.3 -->
<H3>
<A NAME="Section3.8.3">3.8.3 Global State Database</A>
</H3>

<P>The global state database associates atoms/integers with atoms. It is designed to give efficient (non-backtrackable) access/update of atom/integer values and increment/decrement of integer values.

<P>Predicates:

<P><KBD><a name="global_state_set"></a>global_state_set(Atom, AtomOrInt)</KBD>

<BLOCKQUOTE>
The value of the global state associated with <KBD>Atom</KBD> is set to <KBD>AtomOrInt</KBD>.
<BR><KBD>mode global_state_set(@atom, @atom)</KBD>
<KBD>mode global_state_set(@atom, @integer)</KBD>

<P>Example:

<KBD>
<P>| ?- global_state_set(year, 1999).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="global_state_lookup"></a>global_state_lookup(Atom, AtomOrInt)</KBD>

<BLOCKQUOTE>
The current value of the global state associated with <KBD>Atom</KBD> is unified with <KBD>AtomOrInt</KBD>. Fails if the global state associated with <KBD>Atom</KBD> has not been given a value.
<BR><KBD>mode global_state_lookup(@atom, ?atom)</KBD>
<KBD>mode global_state_lookup(@atom, ?integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- global_state_lookup(year, Term).
<BR>
<BR>Term = 1999
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="global_state_increment"></a>global_state_increment(Atom, Integer)</KBD>

<BLOCKQUOTE>
The integer stored in the global state associated with <KBD>Atom</KBD> is incremented and the new value is returned in <KBD>Integer</KBD>. Fails if the global state associated with <KBD>Atom</KBD> does not contain an integer.
<BR><KBD>mode global_state_increment(@atom, -integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- global_state_increment(year, Value).
<BR>
<BR>Value = 2000
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="global_state_decrement"></a>global_state_decrement(Atom, Integer)</KBD>

<BLOCKQUOTE>
The integer stored in the global state associated with <KBD>Atom</KBD> is decremented and the new value is returned in <KBD>Integer</KBD>. Fails if the global state associated with <KBD>Atom</KBD> does not contain an integer.			
<BR><KBD>mode global_state_decrement(@atom, -integer)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- global_state_decrement(year, 1999).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<!-- Section 3.8.4 -->
<H3>
<A NAME="Section3.8.4">3.8.4 Hash Table</A>
</H3>

<P> The hash table is a table of terms (global to all threads), with two-level
indexing: the first index being an atom and the second being an atomic. The
hash table provides efficient (non-backtrackable) access/update of terms
associated with index pairs.

<P>Predicates:

<P><KBD><a name="hash_table_insert"></a>hash_table_insert(Atom, Atomic, Term)</KBD>

<BLOCKQUOTE>
The term of the hash table associated with the index pair (<KBD>Atom</KBD>, <KBD>Atomic</KBD>) is set to <KBD>Term</KBD>.
<BR><KBD>mode hash_table_insert(@atom, @atomic, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- hash_table_insert(student, 1234567, info('Fred', 'Bloggs', 'BSc')).
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="hash_table_lookup"></a>hash_table_lookup(Atom, Atomic, Term)</KBD>

<BLOCKQUOTE>
The current value indexed by (<KBD>Atom</KBD>, <KBD>Atomic</KBD>) in the hash table is unified with <KBD>Term</KBD>. Fails if the term associated with the index pair has not been given a value.
<BR><KBD>mode hash_table_lookup(@atom, @atomic, ?term)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- hash_table_lookup(student, 1234567, Term).
<BR>
<BR>Term =  info(Fred, Bloggs, BSc)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="hash_table_remove"></a>hash_table_remove(Atom, Atomic)</KBD>

<BLOCKQUOTE>
The current value (if any) indexed by (<KBD>Atom</KBD>, <KBD>Atomic</KBD>) in the hash table is removed. 
<BR><KBD>mode hash_table_remove(@atom, @atomic)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- hash_table_remove(student, 1234567).
<BR>
<BR>yes
<BR>
<BR>| ?- hash_table_lookup(student, 1234567, Term).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="hash_table_search"></a>hash_table_search(Fst, Snd, Term)</KBD>

<BLOCKQUOTE>
Return, on backtracking, each entry in the hash table that has an index pair
that unifies with
(<KBD>Fst</KBD>, <KBD>Snd</KBD>) and corresponding value that 
unifies with <KBD>Term</KBD>. 
There is no guarantee about the order in which answers are returned.
<BR><KBD>mode hash_table_search(?atom, ?atomic, ?term)</KBD>

</BLOCKQUOTE>

<!-- Section 3.9 -->
<H2>
<A NAME="Section3.9">3.9 Loading Programs</A>
</H2>

<P>Programs can be loaded into Qu-Prolog in a number of ways.  If the source of the program is available, <KBD><a href="#consult">consult/1</a></KBD> can be used.  If the program has been compiled, it can be loaded with <KBD><a href="#load">load/1</a></KBD>.

<P>Predicates:

<P><KBD><a name="[]"></a>[Files]</KBD>

<BLOCKQUOTE>
A synonym for <KBD>consult(Files)</KBD>.  
</BLOCKQUOTE>

<P><KBD><a name="consult"></a>consult(Files)</KBD>

<BLOCKQUOTE>
Read the clauses from <KBD>Files</KBD> into the dynamic database.  Predicate definitions in <KBD>Files</KBD> replace all current definitions of the same name and arity.  The <KBD>.ql</KBD> extension is added to the file name only after <KBD>consult</KBD> fails to locate <KBD>File</KBD>. <KBD>consult</KBD> also accepts <KBD>.qle</KBD>, <KBD>.qg</KBD> and <KBD>.qge</KBD> files as input. The <KBD>.qle</KBD> files are encoded files, the <KBD>.qg</KBD> files are term-expanded files and the <KBD>.qge</KBD> files are encoded files after term-expansion has been carried out.
</BLOCKQUOTE>

<P><KBD><a name="reconsult"></a>reconsult(Files)</KBD>

<BLOCKQUOTE>
Read the clauses from <KBD>Files</KBD> into the current interpreted program.  Predicate definitions in <KBD>Files</KBD> replace all current definitions of the same name and arity.  The <KBD>.ql</KBD> extension is added to the file name only after <KBD>reconsult</KBD> fails to locate <KBD>File</KBD>.
</BLOCKQUOTE>

<P><KBD><a name="fcompile"></a>fcompile(Files)</KBD>
<BR><KBD>fcompile(Files, OptionList)</KBD>

<BLOCKQUOTE>
Compile the code in <KBD>Files</KBD>, using the compiler options given in <KBD>OptionList</KBD>.  A <KBD>.ql</KBD> extension is added, if needed, to each file name in <KBD>Files</KBD> to give the source file while the corresponding object file has a <KBD>.qo</KBD> extension.  The behaviour is similar to that of <KBD>qc</KBD>. The options fall into three categories: those that affect the behaviour of the compiler; those that affect the storage allocated to the compiler; and those that affect the storage allocated to the executable.

<OL>
<LI>
Compiler Behaviour options:
<BR><KBD>define(AtomList)</KBD>

<BLOCKQUOTE>
The preprocessor behaves as if a line of the form

<BLOCKQUOTE>
	<KBD>#define A </KBD>
</BLOCKQUOTE>

had been added to the input files for each atom <KBD>A</KBD> in <KBD>AtomList</KBD>. 
<BR>(Default: <KBD>[]</KBD>.)
</BLOCKQUOTE>

<KBD>preprocess_only(Boolean)</KBD>

<BLOCKQUOTE>
Stop processing after the preprocessor phase. 
<BR>(Default: <KBD>false</KBD>.)
</BLOCKQUOTE>

<KBD>expand_only(Boolean)</KBD>

<BLOCKQUOTE>
Stop processing after the term expansion phase. 
<BR>(Default: <KBD>false</KBD>.)
</BLOCKQUOTE>

<KBD>compile_only(Boolean)</KBD>

<BLOCKQUOTE>
Stop processing after the compilation phase.
<BR>(Default: <KBD>false</KBD>.)
</BLOCKQUOTE>

<KBD>assemble_only(Boolean)</KBD>

<BLOCKQUOTE>
Stop processing after the assembly phase.
<BR>(Default: <KBD>false</KBD>.)
</BLOCKQUOTE>

<KBD>object_file(File)</KBD>

<BLOCKQUOTE>
If the <KBD>assemble_only</KBD> flag is <KBD>true</KBD>, then the output of the assembly phase, a <KBD>.qo</KBD> file, is placed in this <KBD>File</KBD>. Otherwise a pair of files are created to hold the final executable.  These files are the result of linking.  The first file's name is given by <KBD>File</KBD>, the other file's name is given by appending <KBD>.qx</KBD> to <KBD>File</KBD>.
<BR>(Default: No default.)
</BLOCKQUOTE>

<KBD>term_expand_file(File)</KBD>

<BLOCKQUOTE>
Term expansion rules are given in <KBD>File</KBD>.
<BR>(Default: <KBD>'/dev/null'</KBD>.)
</BLOCKQUOTE>

<KBD>verbose(Boolean)</KBD>

<BLOCKQUOTE>
Produce diagnostic output during processing.
<BR>(Default: <KBD>false</KBD>.)
</BLOCKQUOTE>
<LI>
Compiler Storage Options:
<BR><KBD>compiler_binding_trail(Integer)</KBD>
<BLOCKQUOTE>
The size in kilobytes of the  binding trail used by the compiler.
<BR>(Default: 32.)
</BLOCKQUOTE>

<BR><KBD>compiler_other_trail(Integer)</KBD>
<BLOCKQUOTE>
The size in kilobytes of the  other trail used by the compiler.
<BR>(Default: 32.)
</BLOCKQUOTE>

<BR><KBD>compiler_choice_point_stack(Integer)</KBD>
<BLOCKQUOTE>
The size in kilobytes of the choice point stack used by the compiler.
<BR>(Default: 64.)
</BLOCKQUOTE>


<KBD>compiler_environment_stack(Integer)</KBD>

<BLOCKQUOTE>
The size in kilobytes of the environment stack used by the compiler.
<BR>(Default: 64.)
</BLOCKQUOTE>

<KBD>compiler_heap(Integer)</KBD>

<BLOCKQUOTE>
The size in kilobytes of the heap storage used by the compiler.
<BR>(Default: 100.)
</BLOCKQUOTE>

<KBD>compiler_scratchpad(Integer)</KBD>

<BLOCKQUOTE>
The size in kilobytes of the scratchpad storage used by the compiler.
<BR>(Default: 2.)
</BLOCKQUOTE>

<KBD>compiler_name_table(Integer)</KBD>

<BLOCKQUOTE>
The number of entries in the compiler's name table.
<BR>(Default: 10000.)
</BLOCKQUOTE>

<KBD>compiler_ip_table(Integer)</KBD>

<BLOCKQUOTE>
The number of entries in the compiler's implicit parameter table.
<BR>(Default: 10000.)
</BLOCKQUOTE>


<LI>
Executable Storage Options:
<BR><KBD>executable_atom_table(Integer)</KBD>

<BLOCKQUOTE>
The number of entries in the executable's atom table.
<BR>(Default: 10000.)
</BLOCKQUOTE>

<KBD>executable_code_area(Integer)</KBD>

<BLOCKQUOTE>
The size in kilobytes of the executable's code area.
<BR>(Default: 400.)
</BLOCKQUOTE>

<KBD>executable_predicate_table(Integer)</KBD>

<BLOCKQUOTE>
The number of entries in the executable's predicate table.
<BR>(Default: 10000.)
</BLOCKQUOTE>		

<LI>
Options Affecting Both Compiler and Executable:
<BR><KBD>string_table(Size_in_k)</KBD>

<BLOCKQUOTE>
The size in kilobytes of the string table.
<BR>(Default: 64.)
</BLOCKQUOTE>				
</OL>
</BLOCKQUOTE>

<P><KBD><a name="load"></a>load(File)</KBD>

<BLOCKQUOTE>
Load the object file <KBD>File</KBD>. Paths from <KBD>QPLIBPATH</KBD> and the suffix `<KBD>.qo</KBD>' are added to the file name.
</BLOCKQUOTE>

<P><KBD><a name="define_dynamic_lib"></a>define_dynamic_lib(Library, PredicateList)</KBD>

<BLOCKQUOTE>
The predicates in <KBD>PredicateList</KBD> are defined in <KBD>Library</KBD>.
<BR>The declaration 
<BR><KBD>define_dynamic_lib(mylib, [p/1, q/2])</KBD>
<BR> 
<BR>will cause the file <KBD>mylib.qo</KBD> to be loaded when a call to an undefined <KBD>p/1</KBD> or <KBD>q/2</KBD> is made.
<BR><KBD>mode define_dynamic_lib(@atom, @list(compound))</KBD>
</BLOCKQUOTE>



<!-- Section 3.10 -->
<H2>
<A NAME="Section3.10">3.10 Debugging</A>
</H2>

<P>The debugger is based on the Procedure Box model of execution, which views program control flow in terms of movement about the program text.  The debugger prints out the instantiation states of the goals being debugged at different points of interest (also known as ports).  The ports are as follows:

<BLOCKQUOTE>
<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>call</KBD></TD>
<TD>The initial invocation of a predicate for a given goal.</TD>
</TR>
<TR>
<TD><KBD>exit</KBD></TD>
<TD>A successful termination from the predicate.</TD>
</TR>
<TR>
<TD><KBD>redo</KBD></TD>
<TD>Backtracking into the predicate.</TD>
</TR>
<TR>
<TD><KBD>fail</KBD></TD>
<TD>Failure of the predicate with respect to the initial goal.</TD>
</TR>
<TR>
<TD><KBD>throw</KBD></TD>
<TD>A <KBD><a href="#throw">throw/1</a></KBD> occurs out of the predicate.</TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P>Through these five ports, information about the initial call and its outcome can be obtained without knowledge of the internal processing of the predicate being debugged.

<P>Interaction is allowed at a port if 

<UL type="disc">
<LI>
The debugger is in <KBD>trace</KBD> mode and leashing is set for that port; or			
<LI>
The debugger is in <KBD>debug</KBD> mode, there is a spy point on the current predicate, and there are no spy conditions associated with the predicate; or
<LI>
The debugger is in <KBD>debug</KBD> mode, there is a spy point on the current predicate, and some spy condition associated with the predicate succeeds. 
</UL>

<P>A spy condition <KBD><a href="#spy_cond">spy_cond</a>(Goal1, Port, Goal2)</KBD> succeeds only if <KBD>Goal1</KBD> and <KBD>Port</KBD> unify with the debugger goal and port and <KBD>Goal2</KBD> succeeds. Any bindings for variables in the debugger goal are discarded after unification with <KBD>Goal1</KBD> and execution of <KBD>Goal2</KBD>.

<P>It is impractical to trace through a big program step by step.  Spy points provide a method to skip over part of the program and interact with the debugger at predicates which are of interest.  A spy point is placed at the predicate where the control flow will be viewed.

<P>At each port, a message in the format below is displayed.

<P><KBD>Spy Id Depth Port: Goal ?</KBD>

<BLOCKQUOTE>
<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>Spy</KBD></TD>
<TD>A `<KBD>+</KBD>' indicates that there is a spy point at this predicate.</TD>
</TR>
<TR>
<TD><KBD>Id</KBD></TD>
<TD>An unique identifier for this invocation.</TD>
</TR>
<TR>
<TD><KBD>Depth</KBD></TD>
<TD>The number of ancestors for the current search path.</TD>			
</TR>
<TR>
<TD><KBD>Port</KBD></TD>
<TD>The name of the port.</TD>			
</TR>
<TR>
<TD><KBD>Goal</KBD></TD>
<TD>The goal.</TD>
</TR>			
</TABLE>
</BLOCKQUOTE>

<P>If an interaction is allowed at a port, a `<KBD>?</KBD>' is printed and the debugger waits for a command.  The available commands are given below.

<BLOCKQUOTE>
<KBD>c</KBD>
<BLOCKQUOTE>
Creep. Take a single step to the next port.
</BLOCKQUOTE>

<KBD>&#60;RETURN&#62;</KBD>
<BLOCKQUOTE>
<TD>The same as <KBD>c</KBD>.
</BLOCKQUOTE>

<KBD>l</KBD>
<BLOCKQUOTE>
Leap. Continue the execution until a spy point is reached 
or the program terminates.
</BLOCKQUOTE>


<KBD>s</KBD>
<BLOCKQUOTE>
Skip. Jump to the <KBD>exit</KBD> or the <KBD>fail</KBD> port of this predicate.  This is valid at the <KBD>call</KBD> or the <KBD>redo</KBD> ports only.
</BLOCKQUOTE>


<KBD>f [id]</KBD>
<BLOCKQUOTE>
Fail. Fail this predicate or fail the execution to the goal given in <KBD>id</KBD>.
</BLOCKQUOTE>


<KBD>r [id]</KBD>
<BLOCKQUOTE>
Retry. Retry this predicate or the goal given in <KBD>id</KBD>.
</BLOCKQUOTE>


<KBD>&#60; n</KBD>
<BLOCKQUOTE>
Print depth. Set the print depth to <KBD>n</KBD> (10, by default). The print depth is used to control the amount of detail printed for each goal.
</BLOCKQUOTE>


<KBD>d</KBD>
<BLOCKQUOTE>
Display. Display the current message again without using any operator property.
</BLOCKQUOTE>


<KBD>w</KBD>
<BLOCKQUOTE>
Write. Display the current message again using the available operator property.
</BLOCKQUOTE>


<KBD>p [n]</KBD>
<BLOCKQUOTE>
Print. Display the current message again using <KBD>n</KBD> or the default as the temporary print depth.
</BLOCKQUOTE>


<KBD>g [n]</KBD>
<BLOCKQUOTE>
Goals. Print the last <KBD>n</KBD> or all the ancestors of the current goal.
</BLOCKQUOTE>


<KBD>+ [arg]</KBD>
<BLOCKQUOTE>
Spy. Add a spy point to the current predicate. With an argument, read and add a spy condition.
</BLOCKQUOTE>


<KBD>-</KBD>
<BLOCKQUOTE>
Nospy. Remove the spy point and any conditions from the current predicate.
</BLOCKQUOTE>


<KBD>=</KBD>
<BLOCKQUOTE>
Print the current debugging status.
</BLOCKQUOTE>


<KBD>n</KBD>
<BLOCKQUOTE>
Nodebug. Switch off the debugger.
</BLOCKQUOTE>


<KBD>@</KBD>
<BLOCKQUOTE>
Read and execute a goal.
</BLOCKQUOTE>


<KBD>b</KBD>
<BLOCKQUOTE>
Break. Start another invocation of the interpreter.
</BLOCKQUOTE>


<KBD>a</KBD>
<BLOCKQUOTE>
Abort. Abort the current execution.
</BLOCKQUOTE>


<KBD>h</KBD>
<BLOCKQUOTE>
Help. Display a help message.
</BLOCKQUOTE>


<KBD>?</KBD>
<BLOCKQUOTE>
The same as <KBD>h</KBD>.
</BLOCKQUOTE>

</BLOCKQUOTE>

<P>The user can tailor the actions of the debugger by defining clauses for the hook predicates <KBD><a href="#debugger_hook">debugger_hook/4</a></KBD> (called at every port) and <KBD><a href="#debugger_cmd_hook">debugger_cmd_hook/5</a></KBD> (called after reading a debugger command).  The <KBD>Goal</KBD> and <KBD>Port</KBD> arguments of these hooks are unified with the debugger goal and port respectively.  Note that unification can bind variables in the debugger goal, as well as in <KBD>Goal</KBD>, so hooks can affect the execution of the program being debugged. <KBD>DebugState</KBD> captures the current debugger state in a structure 
<BR><KBD>debug_state(Spy, Id, Depth, Leash, PrintOptions)</KBD>. 
<BR><KBD>Spy</KBD>, <KBD>Id</KBD> and <KBD>Depth</KBD> give further information about the port; <KBD>Leash</KBD> gives the current leash state; and <KBD>PrintOptions</KBD> is a list of options (see <KBD><a href="#write_term">write_term/[2,3]</a></KBD>) that should be used for any output.  If the hook succeeds, <KBD>Action</KBD> should be an atom controlling the next action of the debugger.  Possible values for <KBD>Action</KBD> are listed below.

<BLOCKQUOTE>
<KBD>interact</KBD>
<BLOCKQUOTE>
Continue with the normal interaction for the current port.
</BLOCKQUOTE>

<KBD>creep</KBD>
<BLOCKQUOTE>
Set the debugger mode to <KBD>trace</KBD> and continue execution to the next port (as if by the <KBD>c</KBD> command).
</BLOCKQUOTE>

<KBD>continue</KBD>
<BLOCKQUOTE>
Continue execution in the current debugger mode.
</BLOCKQUOTE>

<KBD>fail</KBD>
<BLOCKQUOTE>
Fail the current predicate (as if by the <KBD>f</KBD> command).
</BLOCKQUOTE>

</BLOCKQUOTE>

<P>If the hook fails, the debugger interacts normally.

<P>To aid debugging of multiple threads, debugging is turned on/off for each thread independently.

<P>Further, if the process (typically <KBD>qp</KBD>) is named then a single debugger GUI will appear for each thread for which debugging is enabled.

<P>All examples are based on debugging a simple ancestor program.

<P>Predicates:

<P><KBD><a name="debugging"></a>debugging</KBD>

<BLOCKQUOTE>
Display status information about the debugger.

<P>Example:

<KBD>
<P>| ?- debugging.
<BR>The debugger is switched to off.
<BR>Leashing at [call exit redo fail exception ] ports.
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="spy"></a>spy PredicateList</KBD>

<BLOCKQUOTE>
Add spy points at <KBD>PredicateList</KBD>, removing any associated conditions.
<BR><KBD>mode spy @closed_list(gcomp)</KBD>
<BR><KBD>mode spy @gcomp</KBD>

<P>Example:

<KBD>
<P>| ?- spy [male/1].
<BR>
<BR>yes
<BR>
<BR>| ?- debugging.
<BR>The debugger is switched to off
<BR>Spy points:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;male/1
<BR>Leashing at [call exit redo fail exception ] ports.
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="spy_cond"></a>spy_cond(Goal1, Port, Goal2)</KBD>

<BLOCKQUOTE>
Add a condition to the spypoint for <KBD>Goal1</KBD>'s predicate; if there is no spypoint, create one.
<BR><KBD>mode spy_cond(@goal, @atom, @goal)</KBD>
<BR><KBD>mode spy_cond(@goal, @var, @goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="nospy"></a>nospy PredicateList</KBD>

<BLOCKQUOTE>
Remove spy points and conditions at <KBD>PredicateList</KBD>. 
<BR><KBD>mode nospy @closed_list(gcomp)</KBD>
<BR><KBD>mode nospy @gcomp</KBD>
</BLOCKQUOTE>

<P><KBD><a name="nospyall"></a>nospyall</KBD>

<BLOCKQUOTE>
Remove all the spy points and conditions.
</BLOCKQUOTE>

<P><KBD><a name="debug"></a>debug</KBD>

<BLOCKQUOTE>
Switch on the debugger.  Produce trace at spy points only. If <KBD>xdebug</KBD> is used instead then the debug GUI will start - see <A HREF="SEC3.html#Section3.21">Graphical User Interface</A>.

<P>Example:

<KBD>
<P>| ?- debug.
<BR>
<BR>yes
<BR>
<BR>| ?- debugging.
<BR>The debugger is switched to debug.
<BR>Spy points:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;male/1
<BR>Leashing at [call exit redo fail exception ] ports.
<BR>
<BR>yes
<BR> 
<BR>| ?- father(john, X).
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;call: male(john) ? l
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;exit: male(john) ? l
<BR>
<BR>X = george;
<BR>
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;redo: male(john) ? l
<BR>+ 1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;fail: male(john) ? l
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;call: male(john) ? l
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;exit: male(john) ? l
<BR>
<BR>X = anne;
<BR>
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;redo: male(john) ? l
<BR>+ 1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;fail: male(john) ? l
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="trace"></a>trace</KBD>

<BLOCKQUOTE>
Switch on the debugger. Produce trace at every interpreted clause. If <KBD>xtrace</KBD> is used instead then the debug GUI will start - see <A HREF="SEC3.html#Section3.21">Graphical User Interface</A>.

<P>Example:

<KBD>
<P>| ?- trace.
<BR>
<BR>yes
<BR>
<BR>| ?- debugging.
<BR>The debugger is switched to trace.
<BR>Spy points:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;male/1
<BR>Leashing at [call exit redo fail exception ] ports.
<BR>
<BR>yes
<BR>
<BR>| ?- father(john, X).
<BR>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;call: father(john, X) ?
<BR>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;call: parent(john, X) ?
<BR>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;exit: parent(john, george) ?
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;call: male(john) ?
<BR>+ 3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;exit: male(john) ?
<BR>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;exit: father(john, george) ?
<BR>
<BR>X = george
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="leash"></a>leash(Mode)</KBD>

<BLOCKQUOTE>
Set leashing at the list of ports given in <KBD>Mode</KBD>.  The available ports are: <KBD>call</KBD>, <KBD>exit</KBD>, <KBD>redo</KBD>, <KBD>fail</KBD>, <KBD>exception</KBD>.

<P><KBD>Mode</KBD> can also be one of the following:

<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>none</KBD></TD>
<TD></TD>
</TR>
<TR>
<TD><KBD>loose</KBD></TD>
<TD><KBD>call</KBD></TD>
</TR>
<TR>
<TD><KBD>half</KBD></TD>
<TD><KBD>call</KBD>, <KBD>redo</KBD></TD>
</TR>
<TR>
<TD><KBD>tight</KBD></TD>
<TD><KBD>call</KBD>, <KBD>redo</KBD>, <KBD>fail</KBD>, <KBD>exception</KBD></TD>
</TR>
<TR>
<TD><KBD>full</KBD></TD>
<TD><KBD>call</KBD>, <KBD>exit</KBD>, <KBD>redo</KBD>, <KBD>fail</KBD>, <KBD>exception</KBD></TD>
</TR>
</TABLE>

<BR><KBD>mode leash(@atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="nodebug"></a>nodebug</KBD>

<BLOCKQUOTE>
Switch off the debugger. 
</BLOCKQUOTE>

<P><KBD><a name="notrace"></a>notrace</KBD>

<BLOCKQUOTE>
Switch off the debugger. It is the same as <KBD><a href="#nodebug">nodebug/0</a></KBD>.
</BLOCKQUOTE>

<P><KBD><a name="with_debugging_off"></a>with_debugging_off(Goal)</KBD>		

<BLOCKQUOTE>
Execute the <KBD>Goal</KBD> with the debugger (<KBD><a href="#debug">debug/0</a></KBD> and <KBD><a href="#trace">trace/0</a></KBD>) turned off.
<BR><KBD>mode with_debugging_off(+goal)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="debugger_hook"></a>debugger_hook(Goal, Port, DebugState, Action)</KBD>

<BLOCKQUOTE>
A user-defined predicate that is called (if it exists) on every debugger port.

<P>Example:

<KBD>
<P>| ?- assert((debugger_hook(male(X), call, D, continue) :- 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(X), nl, write(D), nl)).
<BR>
<BR>X = X
<BR>D = D
<BR> 
<BR>| ?- father(john, X).
<BR>john
<BR>debug_state(spy, 4, 2, _125, [])
<BR>+ 4&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;exit: male(john) ? l
<BR>
<BR>X = george
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="debugger_cmd_hook"></a>debugger_cmd_hook(DebugCmd, DebugArg, Goal, Port, Action)</KBD>

<BLOCKQUOTE>
A user-defined predicate that is called (if it exists) after reading a debugger command. <KBD>DebugCmd</KBD> and <KBD>DebugArg</KBD> are the command and argument (as atoms) to be processed.
</BLOCKQUOTE>



<!-- Section 3.11 -->
<H2>
<A NAME="Section3.11">3.11 Foreign Language Interface</A>
</H2>

<P>This interface enables procedures/functions written in another programming language to be called from Qu-Prolog. Currently, it supports <KBD>C</KBD> and <KBD>C++</KBD>.  The interface can be divided into two levels as described below.

<!-- Section 3.11.1 -->
<H3>
<A NAME="Section3.11.1">3.11.1 High Level Foreign Language Interface.</A>
</H3>

<P>With this high level interface, arguments and function values are automatically converted between the representations in Qu-Prolog and the types used in the foreign language.  The conversion is carried out by <KBD><a href="#foreign">foreign/3</a></KBD>. 

<P>Predicates:

<P><KBD><a name="foreign_file"></a>foreign_file(ObjectFile, ForeignFns)</KBD>

<BLOCKQUOTE>
The list of foreign functions, <KBD>ForeignFns</KBD>, which are callable from Qu-Prolog, are stored in <KBD>ObjectFile</KBD>.  Any function that cannot be accessed should not appear in <KBD>ForeignFns</KBD>. The <KBD>ObjectFile</KBD> must have the <KBD>.o</KBD> extension.  The file supplying this information cannot be compiled.
</BLOCKQUOTE>

<P><KBD><a name="foreign"></a>foreign(ForeignFn, ForeignSpec)</KBD>
<BR><KBD>foreign(ForeignFn, Language, ForeignSpec)</KBD>

<BLOCKQUOTE>
The foreign function, <KBD>ForeignFn</KBD>, is written in <KBD>Language</KBD>, which default is <KBD>C</KBD>. <KBD>ForeignSpec</KBD> specifies the name of the predicate that will call <KBD>ForeignFn</KBD>.  The arguments of  <KBD>ForeignSpec</KBD> indicate how the arguments are transferred between the predicate and <KBD>ForeignFn</KBD>.  Each of these arguments is declared by a combination of mode and a type given below.

<P>Allowable modes

<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>+</KBD></TD>
<TD>An argument to the function.</TD>
</TR>
<TR>
<TD><KBD>-</KBD></TD>
<TD>A reference (pointer) argument to the function.</TD>
</TR>
<TR>
<TD><KBD>[-]</KBD></TD>
<TD>The function returns this argument.</TD>
</TR>
</TABLE>

<P>Allowable types

<TABLE border="0" cellspacing="0" cellpadding="10">
<TR>
<TD><KBD>integer</KBD></TD>
<TD><KBD>long</KBD></TD>
</TR>
<TR>
<TD><KBD>float</KBD></TD>
<TD><KBD>double</KBD></TD>
</TR>
<TR>
<TD><KBD>atom</KBD></TD>
<TD><KBD>char *</KBD></TD>
</TR>
<TR>
<TD><KBD>string</KBD></TD>
<TD><KBD>char *</KBD></TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P><KBD><a name="load_foreign_files"></a>load_foreign_files(ObjectFiles)</KBD>
<BR><KBD>load_foreign_files(ObjectFiles, Libraries)</KBD>

<BLOCKQUOTE>
Link the <KBD>ObjectFiles</KBD> written in another language with the support <KBD>Libraries</KBD>.  This "high level foreign language interface" generates interface functions between Qu-Prolog and the foreign language.  The <KBD>.o</KBD> extension in <KBD>ObjectFiles</KBD> is optional. 
<BR><KBD>mode load_foreign_files(@atom)</KBD>
<BR><KBD>mode load_foreign_files(@closed_list(atom))</KBD>
<BR><KBD>mode load_foreign_files(@atom, closed_list(atom))</KBD>
<BR><KBD>mode load_foreign_files(@closed_list(atom), closed_list(atom))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="generate_foreign_interface"></a>generate_foreign_interface(ObjectFiles, Interface)</KBD>
<BR><KBD>generate_foreign_interface(ObjectFiles, Libraries, Interface)</KBD>

<BLOCKQUOTE>
This predicate is used to generate low-level interface files. <KBD>Interface</KBD> is the root name of the interface. This predicates generates a <KBD>.cc</KBD>
and <KBD>.ql</KBD> file with root <KBD>Interface</KBD>. The <KBD>.cc</KBD>
file is compiled. <KBD>ObjectFiles</KBD> and <KBD>Libraries</KBD> are as above.
It requires definitions for <KBD>foreign_file/2</KBD> and <KBD>foreign/3</KBD>.
<BR><KBD>mode generate_foreign_interface(@atom, @atom)</KBD>
<BR><KBD>mode generate_foreign_interface(@closed_list(atom), @atom)</KBD>
<BR><KBD>mode generate_foreign_interface(@atom, closed_list(atom), @atom)</KBD>
<BR><KBD>mode generate_foreign_interface(@closed_list(atom), closed_list(atom), @atom)</KBD>
</BLOCKQUOTE>

<P>Consider the following example code in `test.cc'.

<KBD>
<P>//
<BR>// foreign(twice, c, twice(+ integer, [- integer])).
<BR>//
<BR>extern "C" long
<BR>twice(long a)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;return(2 * a);
<BR>}
<BR>
<BR>//
<BR>// foreign(triple, c++, triple(+ float, - float)).
<BR>//
<BR>void
<BR>triple(double x, double *a)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;*a = (x * 3);
<BR>}
<BR>
<BR>//
<BR>// foreign(mkfoo, 'c++', mkfoo(- atom)).
<BR>//
<BR>void mkfoo(char** a)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;*a = (char *)"foo";
<BR>}
</KBD>

<P>The file is compiled with the appropriate compiler to obtain the object file.

<KBD>
<P>g++ -c -fPIC test.cc
</KBD>

<P>The interface is defined in <KBD>test.ql</KBD> with the following clauses.

<KBD>
<P>foreign_file('test.o', [twice, triple, mkfoo]).
<BR>
<BR>foreign(twice, c, twice(+ integer, [- integer])).
<BR>foreign(triple, 'c++', triple(+ float, - float)).
<BR>foreign(mkfoo, 'c++', mkfoo(- atom)).
</KBD>

<P>When <KBD>test.ql</KBD> and the object file <KBD>test.o</KBD> is loaded, interface functions, such as those below, are generated for each function.  These interface functions perform the necessary type checking and conversion.


<KBD>
<BR>#include "QuProlog.h"
<BR>
<BR>extern "C" long twice(long);
<BR>extern  void triple(double, double*);
<BR>extern  void mkfoo(char **);

<BR>extern "C" bool
<BR>twice_interface(ForeignInterface* fi)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool result = true;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long integer0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long integer1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* object0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* object1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* outarg1;
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object0 = fi->getXReg(0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!object0->isInteger())
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer0 = object0->getNumber();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object1 = fi->getXReg(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer1 = twice(integer0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outarg1 = fi->makeInteger(integer1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = result && fi->unify(object1, outarg1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(result);
<BR>}
<BR>
<BR>extern "C" bool
<BR>triple_interface(ForeignInterface* fi)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool result = true;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double float0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double float1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* object0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* object1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* outarg1;
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object0 = fi->getXReg(0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!object0->isNumber())
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(false);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (object0->isInteger())
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float0 = object0->getNumber();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float0 = object0->getDouble();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object1 = fi->getXReg(1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triple(float0, &float1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outarg1 = fi->makeDouble(float1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = result && fi->unify(object1, outarg1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(result);
<BR>}

<BR>extern "C" bool
<BR>mkfoo_interface(ForeignInterface* fi)
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool result = true;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char * atom0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* object0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object* outarg0;
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object0 = fi->getXReg(0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkfoo(&atom0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outarg0 = fi->makeAtom(atom0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = result && fi->unify(object0, outarg0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(result);
<BR>}
</KBD>

<P>Here is a sample Qu-Prolog session using these foreign functions.

<KBD>
<P>| ?- consult('test.ql'),
<BR>load_foreign_files('test.o'),
<BR>abolish(foreign_file/2),
<BR>abolish(foreign/3).
<BR>
<BR>yes
<BR>
<BR>| ?- twice(2, N).
<BR>
<BR>N = 4;
<BR>
<BR>no
<BR>
<BR>| ?- triple(3.1, N).
<BR>
<BR>N = 9.3;
<BR>
<BR>no
<BR>
<BR>| ?- mkfoo(X).
<BR>
<BR>X = foo;
<BR>
<BR>no
<BR>
<BR>| ?- generate_foreign_interface('test.o', test_interface).
<BR>
<BR>yes
</KBD>
<P> The files <KBD>test_interface.cc</KBD>, <KBD>test_interface.o</KBD> and
<KBD>test_interface.ql</KBD> are generated by the above call. <KBD>test_interface.ql</KBD> contains the required query to <KBD>load_foreign/2</KBD> to
initialize the low-level interface.



<!-- Section 3.11.2 -->
<H3>
<A NAME="Section3.11.2">3.11.2 Low Level Foreign Language Interface</A>
</H3>

<P>Interface functions are not generated for this interface. Operations such as dereferencing, type checking and conversions, and unification, are the responsibility of the user.

<P>Predicates:

<P><KBD><a name="load_foreign"></a>load_foreign(ObjectFiles, PredicateList)</KBD>
<BR><KBD>load_foreign(ObjectFiles, PredicateList, Libraries)</KBD>

<BLOCKQUOTE>
Link the <KBD>ObjectFiles</KBD> written in another language with the support <KBD>Libraries</KBD>.  
The <KBD>ObjectFiles</KBD> contains the predicates specified in 
<KBD>PredicateList</KBD>.  Each element in <KBD>PredicateList</KBD> must be in either <KBD>Name/Arity</KBD> or <KBD>Name/Arity=Function</KBD> format.  <KBD>Name/Arity</KBD> specifies the predicate that will call <KBD>Function</KBD>.  The default name for <KBD>Function</KBD> is <KBD>Name</KBD>.  This "low level foreign language interface" does not generate any additional interface functions. The <KBD>ObjectFiles</KBD> must have the <KBD>.o</KBD> extension.
<BR><KBD>mode load_foreign(@atom, @closed_list(gcomp))</KBD>
<BR><KBD>mode load_foreign(@closed_list(atom), @closed_list(gcomp))</KBD>
<BR><KBD>mode load_foreign(@atom, @closed_list(gcomp), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closed_list(atom))</KBD>
<BR><KBD>mode load_foreign(@closed_list(atom), @closed_list(gcomp), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closed_list(atom))</KBD>
</BLOCKQUOTE>

<P>Using the interface functions in the above example, the following line will produce the same effect as <KBD><a href="#load_foreign_files">load_foreign_files</a>('test.o')</KBD>.


<KBD>
<P>| ?- load_foreign(['test_interface.o', 'test.o'],
<BR>[twice/2=twice_interface,
<BR>triple/2=triple_interface,
<BR>mkfoo/1 = mkfoo_interface]).
</KBD>


<!-- Section 3.12 -->
<H2>
<A NAME="Section3.12">3.12 Macros</A>
</H2>

<P>The effect of macro expansions can be achieved in two ways. 
One is by using <KBD><a href="#Section3.7">term expansion</a></KBD>. 
The other is by using the inline declaration. 
The inline declarations are used by the compiler to inline code. 
Inlining is applied recursively by the compiler. 
The same directive to the runtime system also gives the interpreted code access to inline definitions.

<P>The main difference between using term expansions and inlining is that term expansion is run as a preprocessor of the compiler, whereas inlining is done during compilation. It is therefore possible to, for example, inline code after higer-order goal unfolding and other compiler transformations.

<P>Predicates:

<P><KBD><a name="inline"></a>inline(Goal1, Goal2)</KBD>
<BR><KBD>inline(Goal1, Goal2, Code)</KBD>

<BLOCKQUOTE>
Declares <KBD>Goal2</KBD> to be the inline expansion of <KBD>Goal1</KBD>. <KBD>Code</KBD> is code typically used to construct <KBD>Goal2</KBD> from <KBD>Goal1</KBD>. <KBD>Goal1</KBD> can be a special term of the form <KBD>Term @ ArgList</KBD> where <KBD>Term</KBD> is a term applied to the list of terms in <KBD>ArgList</KBD>.
<P>The semantics for inlining is the same as for a call to <KBD>Goal1</KBD> with definition <KBD>Goal1 :- Goal2</KBD>. For compiled code this predicate call is avoided (and <KBD>Goal2</KBD> replaces <KBD>Goal1</KBD>) where the semantics is not affected.

<P>WARNING: For effeciency reasons, an inlined goal that is also defined as a predicate has a different behaviour for compiled and interpreted code. It is therefore best to avoid using the same name for an inlined goal and a predicate. 
<BR><KBD>mode inline(@nonvar, @goal)</KBD>
<BR><KBD>mode inline(@nonvar, @term, @goal)</KBD>
</BLOCKQUOTE>

<P>The following examples illustrate the use of <KBD>inline</KBD> to add two lists of numbers pairwise.

<P>One way to do this is to define <KBD>add/3</KBD> as a predicate and then define <KBD>add_lists/3</KBD> as follows.		

<KBD>
<P>add_lists(L1, L2, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;map(add, [L1, L2, Result]).
</KBD>

<P>A slight inefficiency of this approach is that a call from <KBD>add/3</KBD> to <KBD><a href="#is">is/2</a></KBD> is made on each recursive call for <KBD><a href="#map">map</a></KBD>.

<P>On the other hand, if <KBD>add/3</KBD> is defined using inlining as below then this overhead is avoided.

<KBD>
<P>?- inline(add(X,Y,Z), Z is X+Y).
</KBD>

<P>Note that, in this case, the compiler unfolds <KBD>add_lists/3</KBD> to the following (up to the choice of the introduced predicate name).

<KBD>
<P>add_lists(L1, L2, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'$add_lists_1'(L1, L2, Result).
<BR>
<BR>'$add_lists_1'([], [], []).
<BR>'$add_lists_1'([H1|T1], [H2|T2], [H3|T3]) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;H3 is H1 + H2,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'$add_lists_1'(T1, T2, T3).
</KBD>

<P>This example can be further extended in a generic way by using inlining to define `anonymous' (or `lambda') predicates as below. Once this is done <KBD>add_lists/3</KBD> may be defined as follows.

<KBD>
<P>add_lists(L1, L2, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;map(!!lambda [!x, !y, !z] (!z is !x + !y), [L1, L2, Result]).
</KBD>

<P>The compiler will also unfold this to the code given earlier.

<P>Anonymous predicates can be defined as follows.

<KBD>
<P>:- inline(nfi_rev(X,Y), Y not_free_in X).
<BR>
<BR>:- inline(!!lambda X B  @ ArgList, C,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( collect_vars(B, BVars),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff_list(BVars, X, BFreeVars),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map(nfi_rev(BFreeVars), [X]),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parallel_sub(ArgList, X, Sub),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;substitute(Call, [Sub], B),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplify_term(Call, C)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)).
</KBD>

<P>The inlining of lambda terms defines beta reduction. The first three goals in the third argument of the inline declaration make the bound variables not free in each free variable occurring in the body of the lambda term. The last three goals carry out the beta reduction by constructing the required substitution, applying it, and simplifying the result.


<!-- Section 3.13 -->
<H2>
<A NAME="Section3.13">3.13 Higher-Order Predicates</A>
</H2>

<P>The first argument of each of these higher-order predicates is a goal with zero or more arguments missing. These arguments are filled in during processing from components of the remaining arguments of the higher-order predicate.  The order of arguments is the same as the order of the remaining arguments in the higher-order predicate. 

<P>Note that any variable in <KBD>HigherGoal</KBD> instantiated during a call to a higher-order predicate remains instantiated throughout the computation. 

<P>Predicates:

<P><KBD><a name="front_with"></a>front_with(HigherGoal, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is the longest initial segment of <KBD>List1</KBD>, which satisfies <KBD>HigherGoal</KBD>. 
<BR><KBD>mode front_with(+goal, +closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- front_with(atom, [a,b,1,c,d],R).
<BR>
<BR>R = [a, b]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="after_with"></a>after_with(HigherGoal, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> is <KBD>List1</KBD> without the longest initial segment, whose elements satisfy <KBD>HigherGoal</KBD>.
<BR><KBD>mode after_with(+goal, +closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- after_with(atom, [a,b,1,c,d],R).
<BR>
<BR>R = [1, c, d]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="build_structure"></a>build_structure(Functor, Arity, HigherGoal, Term)</KBD>

<BLOCKQUOTE>
<KBD>Term</KBD> is the structure with functor <KBD>Functor</KBD> and arity <KBD>Arity</KBD> and whose arguments are constructed using the higher order goal <KBD>HigherGoal</KBD>.  <KBD>HigherGoal</KBD> is missing two arguments. The first is the position of the argument to be constructed and the second is the constructed argument. This method is preferred for constructing compound terms rather than using <KBD><a href="#functor">functor</a></KBD> and <KBD><a href="#arg">arg</a></KBD> because it avoids unnecessary occurs checks, and because it fills in the arguments with values directly (rather than by creating a structure whose arguments are new variables and then instantiating them).
<BR><KBD>mode build_structure(+term, @integer, +goal, ?compound)</KBD>

<P>Example:

<KBD>
<P>| ?- inline(rev_arg(F,N,A), arg(N,F,A)).
<BR>
<BR>F = F
<BR>N = N
<BR>A = A
<BR>
<BR>| ?- build_structure(f, 3, rev_arg(g(a,b,c,d)),R).
<BR>
<BR>R = f(a, b, c)
<BR>
<BR>| ?- inline(gen_args(Prefix, Number, Result), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number_codes(Number, NumberCodes), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atom_codes(Atom, NumberCodes), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atom_concat(Prefix, Atom, Result) )).
<BR>
<BR>Prefix = Prefix
<BR>Number = Number
<BR>Result = Result
<BR>NumberCodes = NumberCodes
<BR>Atom = Atom
<BR>
<BR>| ?- gen_args(arg, 2, R).
<BR>
<BR>R = arg2
<BR>
<BR>| ?- build_structure(g, 4, gen_args(arg), R).
<BR>
<BR>R = g(arg1, arg2, arg3, arg4)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="filter"></a>filter(HigherGoal, List1, List2)</KBD>

<BLOCKQUOTE>
<KBD>List2</KBD> contains all the elements from <KBD>List1</KBD> which satisfy <KBD>HigherGoal</KBD>.
<BR><KBD>mode filter(+goal, +closed_list(term), ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- filter(atom, [a,X,1,b],R).
<BR>
<BR>X = X
<BR>R = [a, b]
<BR>
<BR>| ?- filter('<'(3), [-2, 8, 1, 2, 4], R).
<BR>
<BR>R = [8, 4]

</KBD>
</BLOCKQUOTE>

<P><KBD><a name="fold"></a>fold(HigherGoal, Identity, List, Result)</KBD>

<BLOCKQUOTE>
Summarise the <KBD>List</KBD> with <KBD>HigherGoal</KBD> to give <KBD>Result</KBD>.  
<KBD>Identity</KBD> is the value used if <KBD>List</KBD> is an empty list. 
<P>The same as <KBD>fold_right(HigherGoal, Identity, List, Result)</KBD>.
<BR><KBD>mode fold(+goal, +term, +closed_list(term), ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- inline(p(X,Y,Z), Z = X + Y).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Z = Z
<BR>
<BR>| ?- fold(p, 0, [1,2,3],R).
<BR>
<BR>R = 1 + (2 + (3 + 0))
</KBD>

</BLOCKQUOTE>

<P><KBD><a name="fold_left"></a>fold_left(HigherGoal, Identity, List, Result)</KBD>

<BLOCKQUOTE>
Summarise the <KBD>List</KBD> with <KBD>HigherGoal</KBD> to give <KBD>Result</KBD>.  <KBD>Identity</KBD> is the value used if <KBD>List</KBD> is an empty list.  The evaluation is performed on the head of the list before the tail of the list.
<BR><KBD>mode fold_left(+goal, +term, +closed_list(term), ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- inline(p(X,Y,Z), Z = X + Y).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Z = Z
<BR>
<BR>| ?- fold_left(p, 0, [1,2,3],R).
<BR>
<BR>R = ((0 + 1) + 2) + 3
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="fold_right"></a>fold_right(HigherGoal, Identity, List, Result)</KBD>

<BLOCKQUOTE>
Summarise the <KBD>List</KBD> with <KBD>HigherGoal</KBD> to give <KBD>Result</KBD>.  <KBD>Identity</KBD> is the value used if <KBD>List</KBD> is an empty list.  The evaluation is performed on the tail of the list before the head of the list. 
<BR><KBD>mode fold_right(+goal, +term, +closed_list(term), ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- inline(p(X,Y,Z), Z = X + Y).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Z = Z
<BR>
<BR>| ?- fold_right(p, 0, [1,2,3],R).
<BR>
<BR>R = 1 + (2 + (3 + 0))
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="map"></a>map(HigherGoal, List)</KBD>

<BLOCKQUOTE>
<KBD>List</KBD> is a list of lists of arguments to <KBD>HigherGoal</KBD>. <KBD>HigherGoal</KBD> is applied in turn to the argument list constructed from the n'th elements of each list of arguments.
<BR><KBD>mode map(+goal, +closed_list(list(term)))</KBD>

<P>Example:

<KBD>
<P>| ?- inline(add(X,Y,Z), Z is X + Y).
<BR>
<BR>X = X
<BR>Y = Y
<BR>Z = Z
<BR>
<BR>| ?- map(add, [[1, 2, 3], [2, 4, 0], R]).
<BR>
<BR>R = [3, 6, 3]
<BR>
<BR>| ?- map(add(2), [[1, 2, 3], R]).
<BR>
<BR>R = [3, 4, 5]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="collect_simple_terms"></a>collect_simple_terms(HigherGoal, Term, Term1, Term2)</KBD>

<BLOCKQUOTE>
Summarise the simple terms (atomic or any variable) of <KBD>Term</KBD> into <KBD>Term2</KBD> by carrying out a top-down, left-right pass over <KBD>Term</KBD>. <KBD>Term1</KBD> is used as an initial value for the summarisation. Any simple terms that cause <KBD>HigherGoal</KBD> to fail are ignored.
<BR><KBD>mode collect_simple_terms(+goal, +term, +term, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- inline(sum(A,B,C), (integer(A), C is A+B)).
<BR>
<BR>A = A
<BR>B = B
<BR>C = C
<BR>
<BR>| ?- collect_simple_terms(sum, f(g(2), a, 5), 0, X).
<BR>
<BR>X = 7
<BR>
<BR>| ?- inline(collect_var(A,B,C), (var(A), C = [A|B])).
<BR>
<BR>A = A
<BR>B = B
<BR>C = C
<BR>
<BR>| ?- collect_simple_terms(collect_var, f(g(X),a,Y), [], R).
<BR>
<BR>X = X
<BR>Y = Y
<BR>R = [Y, X]
<BR>
<BR>| ?- inline(build(New, Current, List), (atom(New), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concat_atom([Current, '-', New], List))).
<BR>
<BR>New = New
<BR>Current = Current
<BR>List = List
<BR>
<BR>| ?- collect_simple_terms(build, foo(g(2), a, h(bar), c), 
<BR>start, R).
<BR>
<BR>R = start-foo-g-a-h-bar-c
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="transform_simple_terms"></a>transform_simple_terms(HigherGoal, Term1, Term2)</KBD>

<BLOCKQUOTE>
This generates a sequence of calls <KBD>HigherGoal(T1, T2)</KBD>. <KBD>T1</KBD> is instantiated to each simple term in <KBD>Term1</KBD>, and the result of the transformation should be stored in <KBD>T2</KBD>. <KBD>Term2</KBD> is the overall result of the transformation of <KBD>Term1</KBD>. 
<BR><KBD>mode transform_simple_terms(+goal, +term, ?term)</KBD>

<P>Example.

<KBD>
<P>| ?- inline(inc(X,Y), (integer(X) -&#62; Y is X+1; Y=X)).
<BR>
<BR>X = X
<BR>Y = Y
<BR>
<BR>| ?- transform_simple_terms(inc, f(X,1,g(2)), R).
<BR>
<BR>X = X
<BR>R = f(X, 2, g(3))
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="transform_subterms"></a>transform_subterms(HigherGoal, Term1, Term2)</KBD>

<BLOCKQUOTE>
This generates a sequence of calls <KBD>HigherGoal(T1, T2)</KBD>. <KBD>T1</KBD> is instantiated to each non-variable subterm of <KBD>Term1</KBD> in turn, iterating from the bottom up (so arguments are transformed before structures and quantifications).  <KBD>Term2</KBD> is the overall result of the transformation of <KBD>Term1</KBD>. 
<BR><KBD>mode transform_subterms(+goal, +term, ?term)</KBD>

<P>Example.

<KBD>
<P>| ?- inline(change(X,Y), (X = a -&#62; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y = f(a); X = f(T) -&#62; Y = f(T, T); Y = X)).
<BR>
<BR>X = X
<BR>Y = Y
<BR>T = T
<BR>
<BR>| ?- transform_subterms(change, g(f(f(a))), R).
<BR>
<BR>R = g(f(f(f(a), f(a)), f(f(a), f(a))))
</KBD>
</BLOCKQUOTE>


<!-- Section 3.14 -->
<H2>
<A NAME="Section3.14">3.14 Implicit Parameters</A>
</H2>

<P>Consider applications that manage internal state.  Such applications include, for example, Definite Clause Grammars processors and theorem provers.  In ordinary Prolog implementations, the state is typically handled by including arguments to predicates that represent input and output state information.  For some applications where the state is simple, such as Definite Clause Grammars programming, these extra arguments are added by preprocessing the input program.  In theorem proving applications the state is usually complex and is typically handled either by including many input/output state pairs to predicates, or by imbedding the state in a data structure for inclusion in predicates.

<P>For processing complex states the above approaches are often clumsy and inefficient.  Also, for applications such as interactive theorem provers, it is difficult to hide the internal state from users and from user tactics.  Implicit parameters avoid these problems completely by providing an efficient and logically sound solution to the management of internal state.

<P>The declarative semantics of implicit parameters can be explained in terms of a transformed program where a collection of input/output pairs of explicit parameters are added to predicates.  The efficient implementation of implicit parameters is achieved via a form of backtrackable assignment.

<P>Predicates:

<P><KBD><a name="ip_set"></a>ip_set(Name, Term)</KBD>
<BR><KBD>ip_set(Name1, Name2, Term)</KBD>

<BLOCKQUOTE>
The value <KBD>Term</KBD> is stored in the implicit parameter <KBD>Name</KBD>. The value <KBD>Term</KBD> is stored in the implicit parameter array <KBD>Name1</KBD> at offset <KBD>Name2</KBD>. <KBD>Name2</KBD> is atomic.
<BR><KBD>mode ip_set(@atom, @term)</KBD>			
<BR><KBD>mode ip_set(@atom, @atomic, @term)</KBD>

<P>Example:

<KBD>
<P>| ?- ip_set(language, english).
<BR>
<BR>yes
<BR>
<BR>| ?- ip_set(weekday, 0, 'Sunday').
<BR>
<BR>yes
<BR>
<BR>| ?- ip_set(weekday, 1, Day), Day = 'Monday'.
<BR>
<BR>Day = Monday
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ip_lookup"></a>ip_lookup(Name, Term)</KBD>
<BR><KBD>ip_lookup(Name1, Name2, Term)</KBD>

<BLOCKQUOTE>
The implicit parameter <KBD>Name</KBD> contains <KBD>Term</KBD>.  If <KBD>Name</KBD> is initially unset, the value <KBD>Term</KBD> is stored in it. Note that variables occurring in the implicit parameter may be instantiated by the unification with <KBD>Term</KBD>. The implicit parameter array <KBD>Name1</KBD> contains <KBD>Term</KBD> at offset <KBD>Name2</KBD>. <KBD>Name2</KBD> is atomic.
<BR><KBD>mode ip_lookup(@atom, ?term)</KBD>
<BR><KBD>mode ip_lookup(@atom, @atomic, ?term)</KBD>

<P>Example:

<KBD>
<P>| ?- ip_set(language, english), ip_lookup(language, Lang).
<BR>
<BR>Lang = english
<BR>
<BR>| ?- ip_set(weekday, 0, Day), ip_lookup(weekday, 0, 'Sunday').
<BR>
<BR>Day = Sunday
<BR>
<BR>| ?- ip_set(weekday, 1, 'Monday'), ip_lookup(weekday, 1, 'Tuesday').
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ip_array_clear"></a>ip_array_clear(Name)</KBD>

<BLOCKQUOTE>
Clear the implicit parameter array associated with <KBD>Name</KBD> 
<BR><KBD>mode ip_array_clear(@atom)</KBD>

<P>Example:

<KBD>
<P>| ?- ip_set(weekday, 0, 'Sunday'),
<BR>ip_set(weekday, 1, 'Monday'),
<BR>ip_set(weekday, 2, 'Tuesday'),
<BR>ip_lookup(weekday, 1, Day1),
<BR>ip_array_clear(weekday),
<BR>ip_lookup(weekday, 1, Day2).
<BR>
<BR>Day1 = Monday
<BR>Day2 = Day2
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ip_array_init"></a>ip_array_init(Name, Size)</KBD>

<BLOCKQUOTE>
Initialize the implicit parameter array associated with <KBD>Name</KBD>
giving it a size that is the smallest power of two greater 
or equal to <KBD>Size</KBD> (the default size is 128). 
This is typically used when it is expected that the implicit parameter 
array will be used to store a large number of data items. If the default size
is used then access/update performance will degrade as the number of entries
gets large. If the array is initialized to a size that is greater of equal to
the expected maximum number of data items then the time to access/update 
entries will remain constant.
<BR><KBD>mode ip_array_init(@atom, @integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ip_array_get_entries"></a>ip_array_get_entries(Name, Entries)</KBD>
<P> This predicate returns a list of the ip array indices that have a corresponding value. The entries can then be used to interate through the ip array
and extract all the stored values.

<P>The following predicates define `methods' for a stack whose state is stored in an implicit parameter with name <KBD>stack</KBD>.

<KBD>
<P>init_stack :- ip_set(stack, []).
<BR>
<BR>push_stack(X) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ip_lookup(stack, S),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ip_set(stack, [X|S]).
<BR>
<BR>pop_stack(X) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ip_lookup(stack, [X|S]),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ip_set(stack, S).
<BR>
<BR>empty_stack :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ip_lookup(stack, []).
</KBD>

<P>The stack should then behave as follows:

<KBD>
<P>| ?- init_stack,
<BR>push_stack(4), push_stack(3), push_stack(5),
<BR>pop_stack(X), pop_stack(Y), pop_stack(Z),
<BR>write_term_list([w(X), tab(3), w(Y), tab(3), w(Z), nl]), fail.
<BR>5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4
<BR>
<BR>no
</KBD>



<!-- Section 3.15 -->
<H2>
<A NAME="Section3.15">3.15 Unification Control</A>
</H2>

<P>Many applications need to control unifications.  For example, some theorem provers apply rewrite rules to carry out expression simplification. Such rules are often applied repeatedly until no further rewrites are applicable.  Consider a rewrite system that includes the rule <KBD>X and true -&#62; X</KBD>. If this rewrite rule is naively applied to the term <KBD>A</KBD> then infinite recursion will result. This problem can be controlled by implementing a form of one-sided unification. Applications written in Qu-Prolog can implement one-sided unification and other more sophisticated constrained unifications by `freezing' variables. When a variable is frozen, it cannot be instantiated.  Rewrite rules can be controlled by freezing the variables in the term to be simplified.  This implements one-sided unification. 

<P>There are other reasons for controlling unifications in the 
implementation of theorem provers.  
One important example is when users wish to prove schematic theorems.  
It is usually the case that the user does not want variables 
appearing in the statement of the theorem to be instantiated 
during the proof.  On the other hand, users may be happy if 
variables introduced during the proof (by the application of inference rules) 
are instantiated.  Terms appearing in a proof often contain a 
mixture of the two kinds of variables described above.  
It is therefore critical that the instantiation of variables be 
controlled during rule applications.  
This is particularly important when executing tactics.  
Frozen variables can be used in this situation to achieve the desired result.

<P>The "temperatures" of variables are reset on backtracking.		

<P>Predicates:

<P><KBD><a name="="></a>Term1 = Term2</KBD>

<BLOCKQUOTE>
Unify <KBD>Term1</KBD> and <KBD>Term2</KBD>.
<BR><KBD>mode +term = +term</KBD>

<P>Example:

<KBD>
<P>| ?- A is 10, A = B.
<BR>
<BR>A = 10
<BR>B = 10
<BR>
<BR>| ?- A is 10, B is 20, A = B.
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="unify_with_occurs_check"></a>unify_with_occurs_check(Term1, Term2)</KBD>
 
<BLOCKQUOTE>
This is not really needed because Qu-Prolog's unification always carries out 
occurs checking. It is included for compatibility with the ISO standard.

</BLOCKQUOTE>

<P><KBD><a name="structural_unify"></a>structural_unify(Term1, Term2)</KBD>
 
<BLOCKQUOTE>
Unify <KBD>Term1</KBD> and <KBD>Term2</KBD> as structures.
Quantified terms and terms with substitutions are treated like
compound terms.
<BR><KBD>mode structural_unify(+term, +term)</KBD>
 
<P>Example:
 
<KBD>
<P>| ?- structural_unify([A/!x]B, [C/!y]D).
<BR>
<BR>A = C
<BR>x = !y
<BR>B = D
<BR>C = C
<BR>y = !y
<BR>D = D  
<BR>
</KBD>
</BLOCKQUOTE>  

<P><KBD><a name="?="></a>Term1 ?= Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> and <KBD>Term2</KBD> are unifiable.
<BR><KBD>mode @term ?= @term</KBD>

<P>Example:

<KBD>
<P>| ?- A is 10, A ?= B.
<BR>
<BR>A = 10
<BR>B = B
<BR>
<BR>| ?- A is 10, B is 20, A ?= B.
<BR>
<BR>no
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="\="></a>Term1 \= Term2</KBD>

<BLOCKQUOTE>
<KBD>Term1</KBD> cannot unify with <KBD>Term2</KBD>.
<BR><KBD>mode @term \= @term</KBD>

<P>Example:

<KBD>
<P>| ?- A is 10, A \= B.
<BR>
<BR>no
<BR>
<BR>| ?- A is 10, B is 20, A \= B.
<BR>
<BR>A = 10
<BR>B = 20
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="freeze_term"></a>freeze_term(Term)</KBD>
<BR><KBD>freeze_term(Term, VarList)</KBD>

<BLOCKQUOTE>
Freeze all the variables in <KBD>Term</KBD>, returning the list of newly frozen variables in <KBD>VarList</KBD>.
<BR><KBD>mode freeze_term(@term)</KBD>
<BR><KBD>mode freeze_term(@term, ?closed_list(anyvar))</KBD>

<P>Example:	

<KBD>
<P>| ?- Term1 = f(A, B), Term2 = f(C, D), 
<BR>Term1 = Term2,
<BR>write(Term1), nl, write(Term2), nl, fail.
<BR>f(C, D)
<BR>f(C, D)
<BR>
<BR>no
<BR>
<BR>| ?- Term1 = f(A, B), Term2 = f(C, D), 
<BR>freeze_term(Term1, VarList), Term1 = Term2, 
<BR>write(Term1), nl, write(Term2), nl,
<BR>write(VarList), nl, fail.
<BR>f(A, B),
<BR>f(A, B),
<BR>[A, B]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thaw_term"></a>thaw_term(Term)</KBD>
<BR><KBD>thaw_term(Term, VarList)</KBD>

<BLOCKQUOTE>
Thaw all the variables in <KBD>Term</KBD> and return the newly thawed variables in <KBD>VarList</KBD>.			
<BR><KBD>mode thaw_term(+term)</KBD>
<BR><KBD>mode thaw_term(+term, -closed_list(anyvar))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="freeze_var"></a>freeze_var(Variable)</KBD>

<BLOCKQUOTE>
Freeze <KBD>Variable</KBD>.
<BR><KBD>mode freeze_var(+anyvar)</KBD>

<P>Example:

<KBD>
<P>| ?- Term1 = f(A, B), Term2 = f(C, D), freeze_var(A), Term1 = Term2,
<BR>write(Term1), nl, write(Term2), nl, fail.
<BR>f(A, D)
<BR>f(A, D)
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thaw_var"></a>thaw_var(Variable)</KBD>

<BLOCKQUOTE>
Thaw a <KBD>Variable</KBD>.
<BR><KBD>mode thaw_var(+anyvar)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="frozen_var"></a>frozen_var(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a frozen variable.
<BR><KBD>mode frozen_var(@term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thawed_var"></a>thawed_var(Term)</KBD>

<BLOCKQUOTE>
Succeed if <KBD>Term</KBD> is a thawed variable.
<BR><KBD>mode thawed_var(@term)</KBD>
</BLOCKQUOTE>

<P>One-sided unification may be implemented as follows.

<KBD>
<P>one_sided_unify(T1, T2) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;freeze_term(T1, FrozenVars),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;T1 = T2,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;thaw_term(FrozenVars).
</KBD>		



<!-- Section 3.16 -->
<H2>
<A NAME="Section3.16">3.16 Delayed Problem Handling</A>
</H2>

<P>The delay mechanism suspends the execution of a goal until the variable given in <KBD><a href="#delay">delay/2</a></KBD> is instantiated.  When the variable is bound, all the goals associated with this variable are woken up and made ready for execution.  The woken goals are executed automatically at the next goal or cut. As well as the automatic retry mechanism, the delayed problems, both woken and suspended goals, can be retried manually by one of the <KBD>retry_</KBD> calls.  Qu-Prolog may generate its own unification, <KBD><a href="#not_free_in">not_free_in</a></KBD>, and <KBD><a href="#check_binder">check_binder</a></KBD> delayed problems.

<P>Predicates:

<P><KBD><a name="delay"></a>delay(Variable, Goal)</KBD>

<BLOCKQUOTE>
<KBD>Goal</KBD> is delayed until <KBD>Variable</KBD> is instantiated. If <KBD>Variable</KBD> is not a variable or object variable at the time of call then <KBD>Goal</KBD> will be called immediately.
<BR><KBD>mode delay(+term, +goal)</KBD>

<P>Example:

<KBD>
<P>| ?- delay(X, write(X)), write(b), X=a, write(c), nl, fail.
<BR>bac
<BR>
<BR>no
<BR>
<BR>| ?- X=a, delay(X, write(X)), write(b), write(c), nl, fail.
<BR>abc
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="delay_until"></a>delay_until(Term, Goal)</KBD>

<BLOCKQUOTE>
<KBD>Goal</KBD> is delayed until the delay condition <KBD>Term</KBD> is satisfied.
<P>The possible values of <KBD>Term</KBD> are given below.

<UL type="disc">
<LI>
<KBD>nonvar(X)</KBD>
<BR>Satisfied when <KBD>X</KBD> becomes a non-variable.
<LI>
<KBD>ground(X)</KBD>
<BR>Satisfied when <KBD>X</KBD> becomes ground.
<LI>
<KBD>bound(X)</KBD>
<BR>Satisfied when the variable (or object variable) <KBD>X</KBD> is bound to a term (including another variable or object variable).
<LI>
<KBD>identical_or_apart(X, Y)</KBD>
<BR>Satisfied when <KBD>identical_or_apart/2</KBD> succeeds.
<LI>
<KBD>or(A,B)</KBD>
<BR>Satisfied when either of the delay conditions <KBD>A</KBD> or <KBD>B</KBD> is satisfied.
<LI>
<KBD>and(A,B)</KBD>
<BR>Satisfied when both of the delay conditions <KBD>A</KBD> or <KBD>B</KBD> are satisfied.
</UL>

<BR><KBD>mode delay_until(+compound, +goal)</KBD>

<P>Example:

<KBD>
<P>| ?- delay_until(bound(X), write(X)), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(a), X = Y, write(b), Y = f(Z), write(c), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z=a, write(d), nl, fail.
<BR>aYbcd
<BR>
<BR>no
<BR> 
<BR>| ?- delay_until(nonvar(X), write(X)), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(a), X = Y, write(b), Y = f(Z), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(c), Z=a, write(d), nl, fail.
<BR>abf(Z)cd
<BR>
<BR>no
<BR> 
<BR>| ?- delay_until(ground(X), write(X)), 
<BR>write(a), X = Y, write(b), Y = f(Z), write(c), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z=a, write(d), nl, fail.
<BR>abcf(a)d
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_delays"></a>get_delays(DelayList)</KBD>

<BLOCKQUOTE>
<KBD>DelayList</KBD> is the list of delayed problems.
<BR><KBD>mode get_delays(?closed_list(goal))</KBD>

<P>Example:

<KBD>
<P>| ?- delay_until(ground(X), write(X)), get_delays(L).
<BR>
<BR>X = X
<BR>L = [delay_until(ground(X), write(X))]
<BR>provided:
<BR>
<BR>delay_until(ground(X), write(X))
<BR>
<BR>| ?- [A/!x]B = 3, get_delays(L).
<BR>
<BR>A = A
<BR>x = !x
<BR>B = B
<BR>L= [[A/!x]B = 3]
<BR>provided: 
<BR>
<BR>[A/!x]B = 3
</KBD>

<P>Note from this example that the interpreter displays all delays related to the query in the <KBD>provided</KBD> section.
</BLOCKQUOTE>
<P><KBD><a name="get_var_delays"></a>get_var_delays(Var, DelayList)</KBD>

<BLOCKQUOTE>
<KBD>DelayList</KBD> is the list of delayed problems associated with 
<KBD>Var</KBD>.
<BR><KBD>mode get_var_delays(@var, ?closed_list(goal))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_unify_delays"></a>get_unify_delays(DelayList)</KBD>

<BLOCKQUOTE>
<KBD>DelayList</KBD> is the list of delayed unification problems.
<BR><KBD>mode get_unify_delays(?closed_list(goal))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_unify_delays_avoid"></a>get_unify_delays_avoid(DelayList, Avoid)</KBD>

<BLOCKQUOTE>
<KBD>DelayList</KBD> is the list of delayed unification problems other
than those in <KBD>Avoid</KBD>. This predicate is useful for situations
where some computation might generate new delayed unification problems.
This predicate can be used to extract any new problems.

<BR><KBD>mode get_unify_delays_avoid(?closed_list(goal), +closed_list(goal))</KBD>
<P>Example:

<KBD>
<P>| ?- get_unify_delays(Old), some_computation, get_unify_delays_avoid(New, Old).
<BR>
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="retry_delays"></a>retry_delays</KBD>

<BLOCKQUOTE>
Retry all the unsolved delayed problems.

<P>Example:

<KBD>
<P>| ?- delay(X, write(X)), write(b), retry_delays, 
<BR>write(c), nl, fail.
<BR>bXc
<BR>
<BR>no
<BR>
<BR>| ?- [A/!x]B = 3, retry_delays, get_delays(L).
<BR>
<BR>A = A
<BR>x = !x
<BR>B = B
<BR>L = [[A/!x]B = 3]
<BR>provided:
<BR>
<BR>[A/!x]B = 3
<BR>
<BR>| ?- [A/!x]B = 3, A = 2, retry_delays, get_delays(L).
<BR>
<BR>A = 2
<BR>x = !x
<BR>B = 3
<BR>L = []
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="retry_var_delays"></a>retry_var_delays(Var)</KBD>

<BLOCKQUOTE>
Retry all the delayed problems associated with <KBD>Var</KBD>.
</BLOCKQUOTE>

<P><KBD><a name="retry_woken_delays"></a>retry_woken_delays</KBD>
<BR><KBD>retry_woken_delays(Goal)</KBD>

<BLOCKQUOTE>
Retry all the delayed problems which are woken up by unification and then execute <KBD>Goal</KBD>. 
These predicates are generally not needed in applications as woken delays will be automatically retried at the next call.
</BLOCKQUOTE>

<P><KBD><a name="collect_constraints"></a>collect_constraints(VarList, List1, List2, List3)</KBD>

<BLOCKQUOTE>
<KBD>List1</KBD>, <KBD>List2</KBD>, and <KBD>List3</KBD> contain lists 
of constraints associated with the variables in <KBD>VarList</KBD>. 
<KBD>List1</KBD> gives the distinctness information as 
<KBD><a href="#not_free_in">not_free_in/2</a></KBD> goals, 
while other delayed <KBD>not_free_in/2</KBD> 
goals are in <KBD>List2</KBD>.  
<KBD>List3</KBD> contains all the remaining delayed problems.
<P><KBD>mode collect_constraints(@closed_list(anyvar), -closed_list(goal), </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-closed_list(goal), -closed_list(goal))</KBD>

<P>Example:

<KBD>
<P>| ?- [A/!x]B = 3, !x not_free_in f(A, !y), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_until(ground(C), A = 2),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;collect_constraints([C, !x, !y], List1, List2, List3).
<BR>
<BR>A = A
<BR>x = !x
<BR>B = B
<BR>y = !y
<BR>C = C
<BR>List1 = [!x not_free_in [!y], !y not_free_in [!x]]
<BR>List2 = [!x not_free_in A]
<BR>List3 = [[A/!x]B = 3, delay_until(ground(C), A = 2)]
<BR>provided:
<BR>
<BR>[A/!x]B = 3
<BR>delay_until(ground(C), A = 2)
<BR>!x not_free_in A
<BR>!y not_free_in [!x]
<BR>!x not_free_in [!y]
</KBD>
</BLOCKQUOTE>


<!-- Section 3.17 -->
<H2>
<A NAME="Section3.17">3.17 Program State</A>
</H2>

<P>Information about the program state can be obtained via the following predicates.

<P>Predicates:

<P><KBD><a name="current_atom"></a>current_atom(Atom)</KBD>

<BLOCKQUOTE>
<KBD>Atom</KBD> is a currently defined atom.
<BR><KBD>mode current_atom(?atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="current_predicate"></a>current_predicate(PredicateName/Arity)</KBD>

<BLOCKQUOTE>
<KBD>PredicateName</KBD> with <KBD>Arity</KBD> is a currently defined predicate.
<BR><KBD>mode current_predicate(?compound)</KBD>

<P>Example:

<KBD>
<P>| ?- current_predicate(foobar/1).
<BR>
<BR>no
<BR>
<BR>| ?- current_predicate(current_predicate/1).
<BR>
<BR>yes
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="get_args"></a>get_args(List)</KBD>

<BLOCKQUOTE>
<KBD>List</KBD> is the list of arguments supplied at the invocation of the application.
<BR><KBD>mode get_args(?closed_list(ground))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="main"></a>main(List)</KBD>

<BLOCKQUOTE>
A user defined predicate. It is the default entry point for applications.  
<KBD>List</KBD> is the list of command line arguments given at the 
invocation of the application. These are arguments other than the arguments
used to set the area sizes and name the process. The command line arguments
are the arguments following '--' or arguments without a preceding '-'.
</BLOCKQUOTE>

<P><KBD><a name="predicate_property"></a>predicate_property(Head, Property)</KBD>

<BLOCKQUOTE>
The predicate specified by <KBD>Head</KBD> has <KBD>Property</KBD> (<KBD>built_in<KBD>, <KBD>multifile<KBD>,<KBD>dynamic</KBD>, <KBD>static</KBD>, <KBD>foreign</KBD>).
<BR><KBD>mode predicate_property(?goal, ?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- predicate_property(true, Value).
<BR>
<BR>Value = built_in
<BR>
<BR>| ?- assert((father(A, B) :- male(A), parent(A, B))).
<BR>
<BR>A = A
<BR>B = B
<BR>
<BR>| ?- predicate_property(father(A, B), Value).
<BR>
<BR>A = A
<BR>B = B
<BR>Value = dynamic
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="statistics"></a>statistics</KBD>
<BR><KBD>statistics(Key, Value)</KBD>
<BR><KBD>statistics(ThreadID, Key, Value)</KBD>

<BLOCKQUOTE>
The first predicate displays a summary of the statistical information on the current output.

<P>The remaining two predicates return in <KBD>Value</KBD> the statistics for <KBD>Key</KBD>. If <KBD>ThreadID</KBD> is given then that
statistic for that thread is returned. 
The three argument version is of most use for gathering thread specific
statistics of another thread. 
Fails if <KBD>ThreadID</KBD> is not a current thread.
<P>The possible values for  <KBD>Key</KBD> are given below.

<UL type="disc">
<LI>
<KBD>global_stack</KBD>
<BR>Value: <KBD>[Used, Free, MaxUsage]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the global stack (heap).
<LI>
<KBD>scratchpad</KBD>
<BR>Value: <KBD>[Used, Free, MaxUsage]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the scratchpad stack.
<LI>
<KBD>local_stack</KBD>
<BR>Value: <KBD>[Used, Free, MaxUsage]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the local (environment) stack.
<LI>
<KBD>choice</KBD>
<BR>Value: <KBD>[Used, Free, MaxUsage]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the choice point stack.
<LI>
<KBD>binding_trail</KBD>
<BR>Value: [Used, Free, MaxUsage].
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the binding trail.
<LI>
<KBD>other_trail</KBD>
<BR>Value: [Used, Free, MaxUsage].
<BR>Unit: words.
<BR>Meaning: Used and free space and the maximum usage in the other trail.
<LI>
<KBD>code</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space in the code area.
<LI>
<KBD>string</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free space in the string area.
<LI>
<KBD>name</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free entries in the name table.
<LI>
<KBD>ip_table</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free entries in the implicit parameter table.
<LI>
<KBD>atom</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>.
<BR>Unit: words.
<BR>Meaning: Used and free entries in the atom table.
<LI>
<KBD>predicate</KBD>
<BR>Value: <KBD>[Used, Free]</KBD>
<BR>Unit: words.
<BR>Meaning: Used and free entries in the predicate table.
<LI>
<KBD>runtime</KBD>
<BR>Value: <KBD>[Start, Last]</KBD>.
<BR>Unit: milliseconds.
<BR>Meaning: Runtime since the start, and last runtime <KBD>statistics/2</KBD> call.
</UL>

<P>Example:

<KBD>
<P>| ?- statistics.
<BR>Data&nbsp;Area&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;&nbsp;&nbsp;Used&nbsp;&nbsp;&nbsp;&nbsp;Free&nbsp;&nbsp;&nbsp;&nbsp;Max&nbsp;Usage
<BR>global&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;102400&nbsp;&nbsp;161&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;102239&nbsp;&nbsp;717
<BR>scratchpad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2560&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2560&nbsp;&nbsp;&nbsp;&nbsp;0
<BR>local&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65536&nbsp;&nbsp;&nbsp;101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65435&nbsp;&nbsp;&nbsp;107
<BR>choice&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;65536&nbsp;&nbsp;&nbsp;107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65429&nbsp;&nbsp;&nbsp;171
<BR>binding&nbsp;trail&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;3
<BR>other&nbsp;trail&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;0
<BR>code&nbsp;area&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;409600&nbsp;&nbsp;321343&nbsp;&nbsp;88257&nbsp;&nbsp;&nbsp;321343
<BR>string&nbsp;area&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65536&nbsp;&nbsp;&nbsp;51337&nbsp;&nbsp;&nbsp;14199&nbsp;&nbsp;&nbsp;51337
<BR>number&nbsp;table&nbsp;&nbsp;&nbsp;&nbsp;4096&nbsp;&nbsp;&nbsp;&nbsp;840&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3256
<BR>name&nbsp;table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768
<BR>IP&nbsp;table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32765
<BR>atom&nbsp;table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32768&nbsp;&nbsp;&nbsp;3301&nbsp;&nbsp;&nbsp;&nbsp;29467
<BR>predicate&nbsp;table&nbsp;32768&nbsp;&nbsp;&nbsp;2286&nbsp;&nbsp;&nbsp;&nbsp;30482
<BR>
<BR>runtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;120&nbsp;ms
<BR>
<BR>yes
<BR>
<BR>| ?- statistics(code, Value).
<BR>
<BR>Value = [321343, 88257]
</KBD>
</BLOCKQUOTE>



<!-- Section 3.18 -->
<H2>
<A NAME="Section3.18">3.18 Exception Handling</A>
</H2>

<P>There are two kinds of exception handlers: local and global.  
When an exception is raised (whether by the system or by user code), 
the current handler state is checked.  
If a local handler for that exception is in scope, 
the innermost such handler is called; 
if the handler returns, execution continues after the 
<KBD><a href="#with_local_exception_handler">with_local_exception_handler/3</a></KBD> call. 
Otherwise, if a global handler for the exception has been defined, 
the most recent matching handler is called.  
If the handler returns, execution continues after the goal that raised 
the exception (unless the severity of the exception forbids that).  
If neither a local or global handler for the exception is defined, 
the default action is taken: this default action is to throw an exception term.

<P> Because of problems with signal handling in POSIX threads the only signal
that is caught by Qu-Prolog is <KBD>SIGINT</KBD>. All other signals have
their default behaviour. The <KBD>SIGINT</KBD> signal	
is passed to <KBD><a href="#exception">exception/1</a></KBD> for handling.  
<P> When a <KBD>SIGINT</KBD> is detected the system forks a Qu-Prolog thread to 
handle the signal.
<P> Because local exception handlers are thread specific then a local
exception handler cannot trap <KBD>SIGINT</KBD> signals.

The Qu-Prolog interpreter catches thrown exceptions 
(printing a suitable error message) and also catches 
<KBD>ctrlC_reset</KBD> thrown by a reset in the
default <KBD>SIGINT</KBD> handler.

<P>Predicates:

<P><KBD><a name="exception"></a>exception(Data)</KBD>

<BLOCKQUOTE>
Raise an exception.  Exceptions are represented by terms of the form 
<BR><KBD>ExceptionKind(Severity, Goal, Message, ...)</KBD>.

<P><KBD>Severity</KBD> is an atom indicating how severe the exception is (which determines the default and minimum actions for that exception): 
<BR>see <KBD><a href="#exception_severity">exception_severity/3</a></KBD>.  <KBD>Goal</KBD> is the goal being executed when the exception happened.   <KBD>Message</KBD> determines the message to display by default when that error happens: see <KBD><a href="#get_exception_message">get_exception_message/2</a></KBD>.  Each <KBD>ExceptionKind</KBD> will have other arguments giving information specific to that kind.  The following built-in exceptions have been defined.

<UL type="disc">				
<LI>
<KBD>context_error(Severity, Goal, Message)</KBD>
<BR><KBD>Goal</KBD> appeared in the wrong context.
<LI>
<KBD>declaration_error(Severity, Goal, Message)</KBD>
<BR>A missing declaration.
<LI>
<KBD>dynamic_code_error(Severity, Goal, Message)</KBD>
<BR>An attempt to assert a clause for a static predicate.
<LI>
<KBD>exception_error(Severity, Goal, Message)</KBD>
<BR>A problem was detected with an exception handler. <KBD>Goal</KBD> is the exception call that lead to the problem.
<LI>
<KBD>instantiation_error(Severity, Goal, Message, ArgNo, Modes)</KBD>
<BR><KBD>ArgNo</KBD> is the argument number (of <KBD>Goal</KBD>) where the error was detected.  <KBD>Modes</KBD> is a list of mode declarations giving the allowable modes for <KBD>Goal</KBD>.
<LI>
<KBD>permission_error(Severity, Goal, Message)</KBD>
<BR>A permission error occurred when opening a stream.
<LI>
<KBD>range_error(Severity, Goal, Message, ArgNo, Range)</KBD>
<BR><KBD>ArgNo</KBD> is the argument number (of <KBD>Goal</KBD>) where the error was detected.  <KBD>Range</KBD> is a term indicating the expected range.
<LI>
<KBD>signal(Severity, Goal, Message, Name)</KBD>
<BR><KBD>Name</KBD> is the name of the signal.  Under Unix, this is an atom like 'SIGINT', 'SIGXCPU' etc.
<LI>
<KBD>stream_error(Severity, Goal, Message, Stream)</KBD>
<BR><KBD>Stream</KBD> is the stream being manipulated by the erroneous goal.
<LI>
<KBD>syntax_error(Severity, Goal, Message, Stream, StreamPos0,</KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;StreamPosN, LineNo0, LineNoN, Tokens, TokensPos) </KBD>				 
<BR><KBD>Stream</KBD> is the stream with the syntax error. 
<BR><KBD>StreamPos0</KBD> and <KBD>StreamPosN</KBD> give the stream position at the start and end of the term with the syntax error.  
<BR><KBD>LineNo0</KBD> and <KBD>LineNoN</KBD> give the line number at the start and end of the term with the syntax error.  
<BR><KBD>Tokens</KBD> is the list of tokens that could not be parsed.  
<BR><KBD>TokensPos</KBD> is the index into Tokens where the error was detected.
<LI>
<KBD>type_error(Severity, Goal, Message, ArgNo, Modes)</KBD>
<BR><KBD>ArgNo</KBD> is the argument number (of <KBD>Goal</KBD>) where the error was detected.  <KBD>Modes</KBD> is a list of mode declarations giving the allowable modes for <KBD>Goal</KBD>.
<LI>
<KBD>undefined_predicate(Severity, Goal, Message)</KBD>
<BR>The called predicate is undefined.
</UL>

The possible values for <KBD>Severity</KBD> are given below. The default action will be done (after printing a message) if no handler is found. The minimum action will be done if the user handler returns. 

<UL type="disc">
<LI>
<KBD>information</KBD>
<BR>Default: <KBD>true</KBD>. Minimum: <KBD>true</KBD>.
<LI>
<KBD>warning</KBD>
<BR>Default: <KBD>true</KBD>. Minimum: <KBD>true</KBD>.
<LI>
<KBD>recoverable</KBD>
<BR>Default: <KBD>fail</KBD>. Minimum: <KBD>true</KBD> (Note 1).
<LI>
<KBD>unrecoverable</KBD>
<BR>Default: <KBD>fail</KBD>. Minimum: <KBD>fail</KBD> (Note 2).
<LI>
<KBD>fatal</KBD>
<BR>Default: <KBD>halt</KBD>. Minimum: <KBD>halt</KBD> (Note 3).
</UL>

Notes:

<OL>
<LI>
A handler for a recoverable error should succeed only if it has achieved the effect of <KBD>Goal</KBD> in some way. 
<LI>
A handler for an unrecoverable error may <KBD>fail</KBD> or <KBD>throw</KBD>.
<LI>
A handler for a fatal error may <KBD>throw</KBD>, but should normally <KBD>halt</KBD> the program.
</OL>
<P>
<KBD>Messsage</KBD> is typically a list of the form used for <KBD>write_term_list</KBD>.

<BR><KBD>mode exception(+compound)</KBD>

<P>Example:

<KBD>
<P>| ?- exception(declaration_error(recoverable, Goal, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;'some silly type')).
<BR>Recoverable error: missing declaration for some silly type
<BR>
<BR>no
<BR>
<BR>| ?- exception(type_error(fatal, dwarf(happy), default, 1, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;[dwarf(+grumpy)])).
<BR>Fatal error: type error in dwarf(happy) at argument 1
<BR>&nbsp;&nbsp;allowable modes are [dwarf(+ grumpy)]
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="exception_exception"></a>exception_exception(Goal)</KBD>

<BLOCKQUOTE>
Raise an <KBD>exception_error</KBD> exception for <KBD>Goal</KBD>. The same as 
<BR><KBD><a href="#exception">exception</a>(exception_error(unrecoverable, Goal, default))</KBD>.
<BR><KBD>mode exception_exception(+goal)</KBD>

<P>Example:

<KBD>
<P>| ?- exception_exception(Goal).
<BR>Unrecoverable error: exception error while handling Goal
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="instantiation_exception"></a>instantiation_exception(Goal, N, PredicateMode)</KBD>
<BR><KBD>instantiation_exception(Goal, N, PredicateMode, AbstractType)</KBD>

<BLOCKQUOTE>
Raise an <KBD>instantiation_error</KBD> exception for <KBD>Goal</KBD> with <KBD>PredicateMode</KBD> at argument <KBD>N</KBD>.  The type of this argument should be <KBD>AbstractType</KBD>.
<BR><KBD>mode instantiation_exception(+goal, @integer, </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@closed_list(gcomp))</KBD>
<BR><KBD>mode instantiation_exception(+goal, @integer, </KBD>
<BR><KBD>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@closed_list(gcomp), @ground)</KBD>

<P>Example:

<KBD>
<P>| ?- instantiation_exception(goal(Arg1, Arg2), 2, 
<BR>[goal(-integer, +goal), goal(+integer, -goal)]).
<BR>Recoverable error: instantiation error in goal(Arg1, Arg2) at argument 2
<BR>&nbsp;&nbsp;allowable modes are [goal(- integer, + goal), goal(+ integer, - goal)]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="type_exception"></a>type_exception(Goal, N, PredicateMode)</KBD>
<BR><KBD>type_exception(Goal, N, PredicateMode, AbstractType)</KBD>

<BLOCKQUOTE>
Raise a <KBD>type_error</KBD> exception for <KBD>Goal</KBD> with <KBD>PredicateMode</KBD> at argument <KBD>N</KBD>.  The type of this argument should be <KBD>AbstractType</KBD>.
<BR><KBD>mode type_exception(+goal, @integer, @closed_list(compound))</KBD>
<BR><KBD>mode type_exception(+goal, @integer, @closed_list(compound), @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- type_exception(dwarf(2), 1, [dwarf(+dwarf_type)], dwarf_type).
<BR>Unrecoverable error: type error in dwarf(happy) at argument 1
<BR>&nbsp;&nbsp;expected type dwarf_type
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="exception_severity"></a>exception_severity(Data, Action1, Action2)</KBD>

<BLOCKQUOTE>
The default and minimum actions for exception <KBD>Data</KBD> are <KBD>Action1</KBD> and <KBD>Action2</KBD>, respectively.
<BR><KBD>mode exception_severity(+compound, ?atom, ?atom)</KBD>

<P>Example:

<KBD>
<P>| ?- exception_severity(exception_error(recoverable, G, M), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Min, Max).
<BR>
<BR>G = G
<BR>M = M
<BR>Min = fail
<BR>Max = true
<BR>
<BR>| ?- exception_severity(exception_error(fatal, G, M), Min, Max).
<BR>
<BR>G = G
<BR>M = M
<BR>Min = halt
<BR>Max = halt
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="get_exception_message"></a>get_exception_message(Data, Msg)</KBD>

<BLOCKQUOTE>
The default message for exception <KBD>Data</KBD> is <KBD>Msg</KBD>.  
<P>If <KBD>user_exception_message(Data, Msg)</KBD> succeeds, 
the result is used as the message.  
If the <KBD>Msg</KBD> argument of <KBD>Data</KBD> is a list of terms, 
it is used as the message.  
Otherwise, a message is constructed according to the particular exception type. In any case the resulting <KBD>Msg</KBD> is a suitable second argument for <KBD><a href="#write_term_list">write_term_list/[1,2]</a></KBD>.
<BR><KBD>mode get_exception_message(+compound, ?closed_list(term))</KBD>

<P>Example:

<KBD>
<P>| ?- get_exception_message(type_error(Sev, Goal, Msg, Arg, Mode), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Message), write_term_list(Message).
<BR>Information: type error in Goal at argument Arg
<BR>&nbsp;&nbsp;allowable modes are Mode
<BR>
<BR>Sev = information
<BR>Goal = Goal
<BR>Msg = default
<BR>Arg = Arg
<BR>Mode = Mode
<BR>Message = [Information: , type error in , w(Goal),  
<BR>at argument , w(Arg), nl,   allowable modes are , w(Mode), nl]
</KBD> 
</BLOCKQUOTE>

<P><KBD><a name="with_local_exception_handler"></a>with_local_exception_handler(Goal1, Data, Goal2)</KBD>

<BLOCKQUOTE>
Set up <KBD>Goal2</KBD> as a local handler for exception <KBD>Data</KBD>, then call <KBD>Goal1</KBD>.
<BR><KBD>mode with_local_exception_handler(+goal, +compound, +goal)</KBD>

<P>Consider an application where certain arithmetic evaluations are to recover from such errors by returning 0. This can be achieved using the following definition. 

<P>Example (assuming the following predicate definition): 

<KBD>
<P>eval(Expr, Result) :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;with_local_exception_handler(Result is Expr,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;instantiation_error(_, is(_,_),_,_,_),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Result = 0).
<BR>
<BR>| ?- X is Y+1.
<BR>Recoverable error: instantiation error in _FA is Y + 1 at argument 2
<BR>&nbsp;&nbsp;allowable modes are [? number is @ gcomp, ? number is @ number]
<BR>
<BR>no
<BR>
<BR>| ?- eval(Y+1,X).
<BR>
<BR>Y = Y
<BR>X = 0
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="add_global_exception_handler"></a>add_global_exception_handler(Data, Goal)</KBD>

<BLOCKQUOTE>
Add <KBD>Goal</KBD> as a global handler for exception <KBD>Data</KBD>. If an exception matching <KBD>Data</KBD> happens and is not caught by any local handler or any later global handler, <KBD>Goal</KBD> will be called (with no arguments).  See <A HREF="#Section3.7">Term Expansion</A>.
<BR><KBD>mode add_global_exception_handler(@compound, @goal)</KBD>

<P>Example:

<KBD>
<P>?- add_global_exception_handler(
<BR>&nbsp;&nbsp;instantiation_error(_, is(R,_),_,_,_), R = 0).
<BR>
<BR>| ?- X is Y+1.
<BR>
<BR>Y = Y
<BR>X = 0
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="remove_global_exception_handler"></a>remove_global_exception_handler(Data, Goal)</KBD>

<BLOCKQUOTE>
Remove the most recent global exception handler matching <KBD>Data</KBD> and <KBD>Goal</KBD>.
<BR><KBD>mode remove_global_exception_handler(?compound, ?goal)</KBD>

<P>Example (Continued from last):

<KBD>
<P>| ?- remove_global_exception_handler(instantiation_error(_, 
<BR>&nbsp;&nbsp;is(_,_),_,_,_), _).
<BR>
<BR>| ?- Y is X +1.
<BR>Recoverable error: instantiation error in _103 is X + 1 at argument 2
<BR>&nbsp;&nbsp;allowable modes are [? integer is @ gcomp, ? integer is @ integer]
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="default_exception_handler"></a>default_exception_handler(Data)</KBD>

<BLOCKQUOTE>
Perform the default exception handler for <KBD>Data</KBD> 
(see <KBD><a href="#exception">exception/1</a></KBD> for the possible values 
for <KBD>Data</KBD>). The default handler typically throws an exception term.
<BR><KBD>mode default_exception_handler(+compound)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="default_exception_error"></a>default_exception_error(Data)</KBD>

<BLOCKQUOTE>
Write the default error message for the given exception data to standard error.
<BR><KBD>mode default_exception_error(+compound)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="default_signal_handler"></a>default_signal_handler(Signal)</KBD>

<BLOCKQUOTE>
Execute the default handler for <KBD>Signal</KBD>.
In the current implementation, if the signal is SIGINT then the default
handler produces a menu of choices for how to proceed. 
<BR><KBD>mode default_signal_handler(@atom)</KBD>
</BLOCKQUOTE>

<P>The following example shows how to declare a signal handler that responds to a SIGINT signal by displaying a message and continuing.

<P>
<KBD>
<BR>?- add_global_exception_handler(signal(recoverable, _, _, 'SIGINT'), 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;write_msg).
<BR>
<BR>write_msg :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;write('You can''t kill me'),nl.
</KBD>

<P> Because the signal handler executes in a special thread it does not
have access to the state of any of the other threads. The following example
shows how to declare a signal handler that is specific to the main thread
(thread 0). It is assumed that <KBD>my_handler</KBD> is a defined
predicate to be called in the main thread when SIGINT is detected.

<P>
<KBD>
<BR>?- add_global_exception_handler(signal(recoverable, _, _, 'SIGINT'),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;thread_push_goal(0, my_handler)). 
</KBD>

<P> It is possible to write the SIGINT handler so that local exception
handlers can be used to indirectly trap SIGINT signals. For example, the
predicate <KBD>my_handler</KBD> could be defined as follows.
<P>
<KBD>
<BR>my_handler :-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;exception(my_exception(_,_,_)).
</KBD>
<P>
If the following call is made then the local exception handler will 
respond to SIGINT.
<P>
<KBD>
<BR>with_local_exception_handler(MyGoal, my_exception(_,_,_), ExceptGoal)
</KBD>

<!-- Section 3.19 -->
<H2> 
<a name="Section3.19">3.19 Multiple Threads</a>
</H2>

This section describes predicates for creating and managing threads within a 
single Qu-Prolog process. All threads have a symbolic name (an atom).

<P>Predicates:

<P><KBD><a name="thread_set_symbol"></a>thread_set_symbol(Name)</KBD>
<BLOCKQUOTE>
<P>Set the symbolic name for this thread to <KBD>Name</KBD>.  Fails if the name is already taken or is <KBD>self</KBD> or <KBD>pedro</KBD>.  
<BR><KBD>mode thread_set_symbol(@atom)</KBD>
<P>Example:

<KBD>
<P>| ?- thread_set_symbol(foo).
<BR>
</KBD>

</BLOCKQUOTE>

<P><KBD><a name="thread_symbol"></a>thread_symbol(Name)</KBD>
<BLOCKQUOTE>
<P>Returns the symbolic <KBD>Name</KBD> of the current thread.
<BR><KBD>mode thread_symbol(-atom)</KBD>

<P>Example (Continued from last):

<KBD>
<P>| ?- thread_symbol(Symbol).
<BR>
<BR>Symbol = foo
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_fork"></a>thread_fork(ThreadName, Goal)</KBD>	
<BR><KBD>thread_fork(ThreadName, Goal, RootName)</KBD>
<BR><KBD>thread_fork(ThreadName, Goal, Sizes)</KBD>
<BR><KBD>thread_fork(ThreadName, Goal, Rootname, Sizes)</KBD>
<BLOCKQUOTE>
<P>Creates a new thread called <KBD>ThreadName</KBD> and sets its goal 
to be <KBD>Goal</KBD>. <KBD>ThreadName</KBD> cannot be the name of any existing threads and cannot use the names <KBD>self</KBD> or <KBD>pedro</KBD>.  
Use the current defaults for the sizes of the data areas 
unless otherwise specified in <KBD>Sizes</KBD>.  
The call will fail if the thread cannot be created, 
if the name is unavailable, if the goal cannot be set or if the 
supplied sizes are erroneous.  
Note that the new thread is placed just before the creator thread in the run queue and so does not obtain a timeslice until just before the creator thread gets its next turn.
<P>
If <KBD>ThreadName</KBD> is a variable at the time of call then the system
will generate a name. If you wish to generate your own thread names based on a root name then
use the <KBD>RootName</KBD> (an atom). The system will generate a name which is the root name
followed by an integer. Note that such names will be reused (i.e. the name given to a now-terminated
thread can be given to a new thread). You need to be careful because the thread handle will be
reused and so messages to the terminated thread will be picked up by the new thread with
the same handle. 

<P>Possible items for inclusion in <KBD>Sizes</KBD> are:

<UL type="disc">
<LI>
<KBD>choice_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the choice stack in K words.  
<BR>Default: <KBD>64</KBD>
<LI>
<KBD>env_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the environment stack in K words.
<BR>Default: <KBD>64</KBD>
<LI>
<KBD>heap_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the heap in K words.
<BR>Default: <KBD>400</KBD>
<LI>
<KBD>binding_trail_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the binding trail in K words.
<BR>Default: <KBD>32</KBD>
<LI>
<KBD>other_trail_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the other trail in K words.
<BR>Default: <KBD>32</KBD>
<LI>
<KBD>scratchpad_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the scratchpad heap in K words.
<BR>Default: <KBD>100</KBD>
<LI>
<KBD>name_table_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the name table.
<BR>Default: <KBD>10000</KBD>
<LI>
<KBD>ip_table_size(Integer)</KBD>
<BR><KBD>Integer</KBD> is the size of the IP table.
<BR>Default: <KBD>10000</KBD>
</UL>

<BR><KBD>thread_fork(?atom, @gcomp)</KBD>
<BR><KBD>thread_fork(?atom, @gcomp, @closed_list(compound)</KBD>

<P>Example:

<KBD>
<P>| ?- thread_fork(myThread, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(repeat, Msg &#60;&#60;- Addr:_, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;write_term_list(['Recieved: ', w(Msg), ' from: ', 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w(Addr), nl]), fail)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;).
<BR>
<BR>Msg = Msg
<BR>Addr = Addr
<BR>
<BR>| ?- 'hello world' -&#62;&#62; myThread, fail.
<BR>
<BR>no
<BR>
<BR>| ?- Recieved: hello world from: thread0
<BR>(A is 10 + 5) -&#62;&#62; myThread, fail.
<BR>
<BR>no
<BR>
<BR>| ?- Recieved: A is 10 + 5 from: thread0
</KBD>

<P>The message communication predicates <KBD>&#60;&#60;-</KBD> and 
<KBD>-&#62;&#62;</KBD> are described in <A HREF="SEC3.html#Section3.20">Interprocess Communication</A>
<P>Note that the execution of <KBD>myThread</KBD>'s goal is independent from the succes or failure of any other thread, and its result is written to standard output after the completion of the query in the initial thread (<KBD>thread0</KBD>).  Thus the message appears next to the prompt, while the next query is written on the line below.

</BLOCKQUOTE>

<P><KBD><a name="thread_is_thread"></a>thread_is_thread(Thread)</KBD>
<BLOCKQUOTE>
<P>Succeeds iff <KBD>Thread</KBD> is a valid thread ID and the thread that it refers to exists.
<BR><KBD>mode thread_is_thread(+thread_id)</KBD>

<P>Examples (Continued from last):

<KBD>
<P>| ?- thread_is_thread(foo). % the main thread
<BR>
<BR>yes
<BR>
<BR>| ?- thread_is_thread(myThread).
<BR>
<BR>yes
<BR>
<BR>| ?- thread_is_thread(aaa).
<BR>
<BR>no
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_is_initial_thread"></a>thread_is_initial_thread</KBD>
<BLOCKQUOTE>
<P>Succeeds iff the current thread is an initial thread.  The main thread is an initial thread.
<BR><KBD>mode thread_is_initial_thread</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_exit"></a>thread_exit</KBD>
<BR><KBD>thread_exit(Thread)</KBD>
<BLOCKQUOTE>
<P>End execution of the current thread or the specified <KBD>Thread</KBD>.
Fails if <KBD>Thread</KBD> is not a current thread.
<BR><KBD>mode thread_exit</KBD>
<BR><KBD>mode thread_exit(+thread_id)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_push_goal"></a>thread_push_goal(Thread, Goal)</KBD>
<BLOCKQUOTE>
<P>Push <KBD>Goal</KBD> to the front of the current conjunction of goals 
on the specified <KBD>Thread</KBD>. This predicate is used in the default handler for SIGINT. 
The given thread must be different from the thread in which this call is made.
Fails if <KBD>Thread</KBD> is not a current thread.
<BR><KBD>mode thread_push_goal(+thread_id, +term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_atomic_goal"></a>thread_atomic_goal(Goal)</KBD>
<BLOCKQUOTE>
<P> Call <KBD>Goal</KBD> with multi-threading turned off. 
Multi-threading is turned back on when <KBD>Goal</KBD> exits 
(either by success or failure).
This predicate has the effect of making <KBD>Goal</KBD> atomic with respect
to multi-threading.
<BR><KBD>mode thread_atomic_goal(+term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_wait"></a>thread_wait</KBD>
<BR><KBD>thread_wait(Conditions)</KBD>
<BLOCKQUOTE>
<P>Wait on the default set of conditions or on the given set of <KBD>Conditions</KBD>.  Execution resumes when any condition is satisfied.  If a condition isn't specified, its default is used.

<P>The available conditions are:

<UL type="disc">
<LI>
<KBD>db(Boolean)</KBD>
<BR>Wait on any database change (including changes to the global state and hash table).
<BR>default: <KBD>true</KBD>
<LI>
<KBD>timeout(T)</KBD>
<BR>The call will wait for <KBD>T</KBD> seconds before continuing.
<BR>default: <KBD>block</KBD>
</UL>
<P> Note: A timeout of <KBD>block</KBD> means that the thread will never timeout. 
Currently, if the conditions are set to <KBD>false</KBD>, 
<KBD>false</KBD> and <KBD>block</KBD> then the thread can never be woken.

<BR><KBD>mode thread_wait</KBD>
<BR><KBD>mode thread_wait(+closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_wait_on_goal"></a>thread_wait_on_goal(Goal)</KBD>
<BR><KBD>thread_wait_on_goal(Goal, Options)</KBD>
<BLOCKQUOTE>
<P> <KBD>Options</KBD> is a list containing:
<UL type="disc">
<LI>at most one occurrence of a term 
of the form <KBD>wait_preds(PredList)</KBD> where <KBD>PredList</KBD> is 
a list of terms of the form <KBD>P/N</KBD> or of the form <KBD>P/N-Stamp</KBD>
where <KBD>Stamp</KBD> is a database stamp - see <KBD><a href="SEC3.html#get_predicate_timestamp">get_predicate_timestamp</a></KBD> 
<LI>at most one occurrence of a term of the form <KBD>wait_for(Secs)</KBD></LI>
<LI>at most one occurrence of a term of the form <KBD>retry_every(Secs)</KBD></LI>
<LI>at most one of the above two terms
</UL>
<KBD>Goal</KBD> is first tried (unless <KBD>wait_preds(PredList)</KBD> includes stamps), and if it succeeds, then 
<KBD>thread_wait_on_goal</KBD> succeeds. Otherwise, <KBD>thread_wait_on_goal</KBD> blocks and waits for the database to change before retrying <KBD>Goal</KBD>.
If <KBD>wait_preds(PredList)</KBD> is given as an option then it waits until one
of the listed predicates change. 
If <KBD>wait_for(Secs)</KBD> is given and
<KBD>Goal</KBD> is not successfully retried within the given number of seconds
then <KBD>thread_wait_on_goal</KBD> fails. If <KBD>retry_every(Secs)</KBD> is
given then <KBD>Goal</KBD> is retried at least every <KBD>Secs</KBD> seconds,
even if there is no change to the dynamic database.
<P>It is sometimes useful for <KBD>Goal</KBD> to be able to access the predicates that have changed when timestamps are used in <KBD>wait_preds</KBD>. To support this, the variant <KBD>wait_preds(PredList, CPreds)</KBD> can be used (where 
<KBD>CPreds</KBD> is an unbound variable at the time of call). 
If <KBD>PredList</KBD> contains timestamps then each time <KBD>Goal</KBD> is tried <KBD>CPreds</KBD> will be rebound to those predicates in <KBD>PredList</KBD>  that  have been changed since the last time <KBD>Goal</KBD> was tried.
As a further enhancement, the predicates in <KBD>PredList</KBD> can be prefixed by <KBD>+</KBD> or <KBD>-</KBD>. A <KBD>+</KBD> (respectively <KBD>-</KBD>)
 means that the goal will be retried if the predicate is changed by an assert 
(respectively retract) of the predicate. 
<P> Note that if the supplied goal produces a side-effect and then fails, then
the side-effect will be produced each time the database is modified.
Also note that, if <KBD>retry_every(Secs)</KBD> is given, one way the goal could succeed without a change to the database is if the Prolog state changed in another way, for example by the use of random or because of a message or socket event.

<BR><KBD>mode thread_wait_on_goal(+term)</KBD>
<BR><KBD>mode thread_wait_on_goal(+term, @list(terms))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_sleep"></a>thread_sleep(Time_Out)</KBD>
<BLOCKQUOTE>
<P>This is the same as 
<BR><KBD>thread_wait([timeout(Time_Out), db(false)])</KBD>.
<BR><KBD>mode thread_sleep(+number)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_sleep_until"></a>thread_sleep_until(Time)</KBD>
<BLOCKQUOTE>
<P>This is similar to <KBD>thread_sleep</KBD> except that the argument is the 
time at which the thread should wake as the number of
seconds since the Unix epoch. See <KBD><a href="#realtime">realtime/[1]</a></KBD>.  
<BR><KBD>mode thread_sleep_until(+integer)</KBD>
</BLOCKQUOTE>


<P><KBD><a name="thread_defaults"></a>thread_defaults(DefaultList)</KBD>
<BLOCKQUOTE>
<P>Get the values for the default sizes of data areas used when a new thread is created.
<P>The entries returned in <KBD>DefaultList</KBD> are the same as for <KBD><a href="#thread_fork">thread_fork/[3,4]</a></KBD>.
<BR><KBD>mode thread_defaults(-closed_list(compound)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_set_defaults"></a>thread_set_defaults(DefaultList)</KBD>
<BLOCKQUOTE>
<P>Set the values for the default sizes of data areas used when a new thread is created.
<P>The items allowed in <KBD>DefaultList</KBD> are the same as for <KBD><a href="#thread_fork">thread_fork/[3,4]</a></KBD>.
<BR><KBD>mode thread_set_defaults(+closed_list(compound)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_errno"></a>thread_errno(Errno)</KBD>
<BLOCKQUOTE>
<P>Returns the current errno for this thread.
<BR><KBD>mode thread_errno(-integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="schedule_threads_now"></a>schedule_threads_now(ThreadNames)</KBD>
<BLOCKQUOTE>
<P>This runs a single timeslice for all threads whose names are listed in
<KBD>ThreadNames</KBD>. This predicate produces an error if a listed thread does not exist, the calling thread is listed, or is called by a thread within the execution of <KBD>schedule_threads_now</KBD>.
<BR><KBD>mode schedule_threads_now(@list(atoms))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="thread_yield"></a>thread_yield</KBD>
<BLOCKQUOTE>
<P>The thread gives up its timeslice.
<BR><KBD>mode thread_yield</KBD>
</BLOCKQUOTE>



<!-- Section 3.20 -->
<H2>
<A NAME="Section3.20">3.20 Interprocess Communication</A>
</H2>
Qu-Prolog supports high-level interprocess communication using the Pedro
server. Pedro supports both subscription/notification and peer-to-peer 
messages. A Qu-Prolog process can connect to the Pedro server and then send
messages to and 
receive messages from other Pedro clients. 
<P>
The reader is referred to the Pedro reference manual for further details.
<P>
For peer-to-peer messages addresses (handles) are used to determine the
recepient of a message, and the received message will be accompanied by the 
address of the sender and a reply-to address if required. 
<P>
A handle is of the form <KBD>ThreadName:ProcessName@MachineName</KBD> where the
components are respectively the name of the thread, the registered name 
of the process and the name of the machine on which the process is running.
<P>
When specifying addresses the handle can be used, but if the address is for a 
process on the same machine then the machine name can be elided. Further, if
the address is for a thread on the same process then the process name can 
also be elided. The special address <KBD>self</KBD> is the shorthand
for the address of this thread.
<P>
For non-Qu-Prolog processes for which the thread name is not relevant, handles
can be of the form <KBD>ProcessName@MachineName</KBD>. If a process uses such
a handle when sending a message to a Qu-Prolog process then the initial thread 
(thread0) will receive the message. If the thread name is a variable then
all running threads on the process will receive the message.
<P>
It is also possible, when sending a message, to use a handle with either
the process name or the machine name being a variable. 
If the process name is a variable all registered processes on that machine will receive
the message. If the machine name is a variable all registered processes with that name 
(on any machine) will receive the message. If both are variables then the message will be sent to all registered processes on all machines that have registered processes. 
<P>
All messages (both notifications and peer-to-peer), together with address
information, received by a thread are
placed in a message queue for that thread.
A notification received by a thread that is not a peer-to-peer message will 
get the handle <KBD>pedro</KBD>
<P>

Predicates:
<P>
<a name="pedro_connect"></a><KBD>pedro_connect</KBD>
<BR><KBD>pedro_connect(Machine)</KBD>
<BR><KBD>pedro_connect(Machine, Port)</KBD>
<BLOCKQUOTE>
Connect to an Pedro server. 
<KBD>Machine</KBD> is the machine on which the Pedro server is running 
(default <KBD>localhost</KBD>) and <KBD>Port</KBD> is the port on which 
the Pedro server is listening (default 4550).
<BR> <KBD>mode pedro_connect</KBD>
<BR> <KBD>mode pedro_connect(@atom)</KBD>
<BR> <KBD>mode pedro_connect(@atom, @integer)</KBD>

<P>Example:

<P>
<KBD>
<BR>| ?- pedro_connect.
<BR>| ?- pedro_connect(fred).
<BR>| ?- pedro_connect(fred, 4999).
</KBD>
</BLOCKQUOTE>

<a name="pedro_disconnect"></a><KBD>pedro_disconnect</KBD>
<BLOCKQUOTE>
Disconnect from the Pedro server.
<BR> <KBD>mode pedro_disconnect</KBD>
</BLOCKQUOTE>

<a name="pedro_is_connected"></a><KBD>pedro_is_connected</KBD>
<BLOCKQUOTE>
Succeeds if and only if the process is connected to Pedro.
<BR> <KBD>mode pedro_is_connected</KBD>
</BLOCKQUOTE>


<a name="pedro_register"></a><KBD>pedro_register(Name)</KBD>
<BLOCKQUOTE>
Register <KBD>Name</KBD> with the Pedro server. 
The process needs to be connected first. This name is 
used as part of the address of this process for peer-to-peer messages.
If the process is started with the <KBD>-Aname</KBD> switch then the process
connects with the Pedro server and registers the supplied name.
<BR> <KBD>mode pedro_register(@atom)</KBD>
</BLOCKQUOTE>

<a name="pedro_deregister"></a><KBD>pedro_deregister</KBD>
<BLOCKQUOTE>
Deregisters the current name with the Pedro server.
<BR> <KBD>mode pedro_deregister</KBD>
</BLOCKQUOTE>

<a name="pedro_is_registered"></a><KBD>pedro_is_registered</KBD>
<BLOCKQUOTE>
Succeeds if and only if the process is registered with Pedro.
<BR> <KBD>mode pedro_is_registered</KBD>
</BLOCKQUOTE>

<a name="pedro_subscribe"></a><KBD>pedro_subscribe(Head, Body, ID)</KBD>
<BLOCKQUOTE>
Subscribe to notifications which unify with <KBD>Head</KBD> and satisfy the
goal <KBD>Body</KBD>. 
The Pedro reference manual lists the goals that can be used in <KBD>Body</KBD>.
If the subscription succeeds <KBD>ID</KBD> will be instantiated to 
the ID for this subscription. This ID is used when unsubscribing.
<BR> <KBD>mode pedro_subscribe(@compound, @goal, ?integer)</KBD>
</BLOCKQUOTE>

<a name="pedro_unsubscribe"></a><KBD>pedro_unsubscribe(ID)</KBD>
<BLOCKQUOTE>
Remove the subscription with the supplied ID.
<BR> <KBD>mode pedro_unsubscribe(@integer)</KBD>
</BLOCKQUOTE>

<a name="pedro_notify"></a><KBD>pedro_notify(T)</KBD>
<BLOCKQUOTE>
Sends the compound term <KBD>T</KBD> as a notification.
<BR> <KBD>mode pedro_notify(@compound)</KBD>
</BLOCKQUOTE>

<a name="thread_handle"></a><KBD>thread_handle(Handle)</KBD>
<BLOCKQUOTE>
<KBD>Handle</KBD> is the handle (peer-to-peer address) of this thread.
<BR> <KBD>mode thread_handle(?handle)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="same_handle"></a>same_handle(Handle1, Handle2)</KBD>
<BLOCKQUOTE>
<P>This is true if <KBD>Handle1</KBD>  and <KBD>Handle2</KBD> represent 
the same handle.
<KBD>Handle1</KBD> must be ground at the time of call and be an 
<KBD>handle</KBD>.  
<BR><KBD>mode same_handle(@handle, ?handle)</KBD>
</BLOCKQUOTE>

<a name="ipc_send"></a><KBD>ipc_send(Message, ToAddress)</KBD>
<BR> <KBD>ipc_send(Message, ToAddress, OptList)</KBD>

<BLOCKQUOTE>
Send <KBD>Message</KBD> to <KBD>ToAddress</KBD>.   
The options supplied in <KBD>OptList</KBD> will determine the actions taken 
during sending.

<P>The only available option is:

<UL type="disc">
<LI>
<KBD>remember_names(Value)</KBD>
<BR>Remember the names of the variables in <KBD>Message</KBD>.  
<BR>Default: <KBD>true</KBD>.
</UL>
<BR><KBD>mode ipc_send(+term, @handle)</KBD>
<BR><KBD>mode ipc_send(+term, @handle, @handle)</KBD>
<BR><KBD>mode ipc_send(+term, @handle, @handle, +closed_list(compound))</KBD>

</BLOCKQUOTE>

<P><KBD><a name="ipc_peek"></a>ipc_peek(Message)</KBD>
<BR><KBD>ipc_peek(Message, FromAddress)</KBD>
<BR><KBD>ipc_peek(Message, FromAddress, OptList)</KBD>

<BLOCKQUOTE>
Examine the incoming message queue of this 
thread for a message that will unify with <KBD>Message</KBD> and 
an address that will unify with <KBD>FromAddress</KBD>.
The options supplied in <KBD>OptList</KBD> will determine the actions 
taken on peeking at the messages in the queue.
<P> Address unification is done via <KBD>same_handle/2</KBD>
and so shortened forms of handles can be given in the address
patterns.
<P>The available options are:

<UL type="disc">
<LI>
<KBD>timeout(Value)</KBD>
<BR><KBD>Value</KBD> is either <KBD>block</KBD>, <KBD>poll</KBD> or a number.  
If <KBD>Value</KBD> is <KBD>block</KBD> then the call delays until a message 
arrives.  If <KBD>Value</KBD> is <KBD>poll</KBD> then the call fails 
immediately if no message is in the queue.  If <KBD>Value</KBD> is 
a number, <KBD>N</KBD>, then the call will wait <KBD>N</KBD> seconds for a message, and if no matching message arrives in that time the call fails.
<BR>Default: <KBD>block</KBD>
<LI>
<KBD>remember_names(Value)</KBD>
<BR>Remember the names of variables in the incoming <KBD>Message</KBD>
<BR>Default: <KBD>true</KBD>
</UL>
<BR><KBD>mode ipc_peek(?term)</KBD>
<BR><KBD>mode ipc_peek(?term, ?handle)</KBD>
<BR><KBD>mode ipc_peek(?term, ?handle, +closed_list(compound))</KBD>
</BLOCKQUOTE>

<P><KBD><a name="ipc_recv"></a>ipc_recv(Message)</KBD>
<BR><KBD>ipc_recv(Message, FromAddress)</KBD>
<BR><KBD>ipc_recv(Message, FromAddress, OptList)</KBD>

<BLOCKQUOTE>
Attempt to unify <KBD>Message</KBD> with a message from the 
thread's message queue if possible.  
<KBD>FromAddress</KBD> will be unified with the address of the sender of the 
message.  
The available options are identical 
to those available with <KBD><a href="#ipc_peek">ipc_peek/4</a></KBD>.  
<BR><KBD>mode ipc_recv(?term)</KBD>
<BR><KBD>mode ipc_recv(?term, ?handle)</KBD>
<BR><KBD>mode ipc_recv(?term, ?handle,  +closed_list(compound))</KBD>
</BLOCKQUOTE>

<P>Examples (of the above four predicates):

<KBD>
<P>| ?- thread_handle(MyHandle), 
<BR>ipc_send('Hello World', MyHandle, []).
<BR>
<BR>MyHandle = thread0 : foo @ bloggs
<BR>
<BR>| ?- ipc_peek(Msg, FromHandle).
<BR>
<BR>Msg = Hello World
<BR>FromHandle = thread0 : foo @ bloggs
<BR>
<BR>| ?- ipc_recv(Msg, Th:PID).
<BR>
<BR>Msg = Hello World
<BR>Th = thread0
<BR>PID = foo
<BR>
</KBD>




<P><KBD><a name="->>"></a>Msg -&#62;&#62; Address</KBD>

<BLOCKQUOTE>
<P>Send <KBD>Msg</KBD> to <KBD>Address</KBD>.
<BR><KBD>mode @term -&#62;&#62; @handle</KBD>
</BLOCKQUOTE>

<P><KBD><a name="<<-"></a>Msg &#60;&#60;- Address</KBD>

<BLOCKQUOTE>
<P>Read a message from the thread's message queue and set <KBD>Address</KBD> to the senders address.
<BR><KBD>mode ?term &#60;&#60;- ?handle</KBD>
</BLOCKQUOTE>

<P><KBD><a name="<<="></a>Msg &#60;&#60;= Address</KBD>

<BLOCKQUOTE>
<P>Search the thread's message queue for a message that will unify 
with <KBD>Msg</KBD> and <KBD>Address</KBD>.
<BR><KBD>mode ?term &#60;&#60;= ?handle</KBD>
</BLOCKQUOTE>

<P>Examples (Of the above three predicates):

<KBD>
<BR>| ?- 'Other World' -&#62;&#62; self.
<BR>
<BR>yes
<BR>
<BR>| ?- Msg &#60;&#60;- Th:_.
<BR>
<BR>Msg = Hello World
<BR>Th = thread0
<BR>
<BR>| ?- 'Other World' &#60;&#60;= self.
<BR>
<BR>yes
</KBD>

<P><KBD><a name="broadcast"></a>broadcast(Term)</KBD>
<BLOCKQUOTE>
<P> Send <KBD>Term</KBD> as a message to all current threads within this process.
<BR><KBD>mode broadcast(+term)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="message_choice"></a>message_choice(ChoiceGoals)</KBD>
<BR><KBD>message_choice(ChoiceGoals;timeout(T) -&#62; TimeoutGoal)</KBD>
<BLOCKQUOTE>
<P><KBD>ChoiceGoals</KBD> takes the form:

<P><KBD>Term1 -&#62; Goal1; Term2 -&#62; Goal2; ... ; TermN -&#62; GoalN</KBD>

<P><KBD>Term1</KBD> to <KBD>TermN</KBD> are either message patterns or of the 
form <KBD>Msg::Goal</KBD> where <KBD>Msg</KBD> is a message pattern 
and <KBD>Goal</KBD> is a goal (for compatibility with logtalk <KBD>??</KBD> can be used instead of <KBD>::</KBD>).  
Message patterns take the form <KBD>Msg &#60;&#60;- Addr</KBD>.  Where <KBD>timeout(T) -&#62; TimeoutGoal</KBD> appears it should be last as any subsequent choices are ignored.

<P>Messages in the incoming message queue are tested against the test terms <KBD>Term1</KBD> to <KBD>TermN</KBD>.  The first message to match against the test terms and the first such matching test term are chosen.  

<P>The message is removed from the message queue, alternatives are cut and the goal <KBD>Goali</KBD> corresponding to the chosen term <KBD>Termi</KBD> is called.  

<P>If no matching messages are found then the call suspends until another message arrives or until the (optional) timeout is reached, in which case the <KBD>TimeoutGoal</KBD> is called.
<BR><KBD>mode message_choice(+term)</KBD>

<P>Example:

<KBD>
<P>| ?- msg(apple, orange) -&#62;&#62; self.
<BR>
<BR>yes
<BR>
<BR>| ?- msg(pear, orange) -&#62;&#62; self.
<BR>
<BR>yes
<BR>
<BR>| ?- msg(grape, grape) -&#62;&#62; self.
<BR>
<BR>| ?- msg(pear, grape) -&#62;&#62; self.
<BR>
<BR>yes
<BR>
<BR>| ?- repeat, message_choice((
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(msg(apple, _) &#60;&#60;- _) -&#62; (write('Apple Pie'), nl, fail);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(msg(_, orange) &#60;&#60;- _) -&#62; (write('Orange Juice'), nl, fail);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(msg(F1, F2) &#60;&#60;- _)::(F1==F2) -&#62; (write('Matching Fruit'), nl, fail);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;timeout(5) -&#62; (write('No (more) matching messages'), nl)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;)).
<BR>Apple Pie
<BR>Orange Juice
<BR>Matching Fruit
<BR>No (more) matching messages
<BR>
<BR>F1 = F1
<BR>F2 = F2
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="pedro_address"></a>pedro_address(IPAddress)</KBD>
<BLOCKQUOTE>
<P> <KBD>IPAddress</KBD> is the IP address of the Pedro server with which 
the process is connected.
<BR><KBD>mode pedro_address(?atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="pedro_port"></a>pedro_port(Port)</KBD>
<BLOCKQUOTE>
<P> <KBD>Port</KBD> is the port used by the Pedro server with which the process is connected.
<BR><KBD>mode pedro_port(?integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="set_default_message_thread"></a>set_default_message_thread(ThreadName)</KBD>
<BLOCKQUOTE>
<P> Set the name of the thread that receives peer-to-peer messages that do not include a thread name as part of the address.

<BR><KBD>mode set_default_message_thread(@atom)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="default_message_thread"></a>default_message_thread(ThreadName)</KBD>
<BLOCKQUOTE>
<P> Return true iff <KBD>ThreadName</KBD> is the name of the default message 
thread.

<BR><KBD>mode default_message_thread(?atom)</KBD>
</BLOCKQUOTE>


<H2>
<A NAME="Section3.21">3.21 Graphical User Interface</A>
</H2>
Qu-Prolog comes with a GUI built on the QT libraries. The program 
<KBD>xqp</KBD> is a GUI interface to <KBD>qp</KBD> built on these libraries.
The program <KBD>xqpdebug</KBD> is a GUI interface to the debugger also 
using QT.
If a <KBD>qp</KBD> process is registered with Pedro then starting the debugger
using  <KBD>xtrace</KBD> or <KBD>xdebug</KBD>
will cause the <KBD>xqpdebug</KBD> interface to start. This debugger is
specific to the thread that started the debugger. It is possible to start
debuggers in serveral threads.



<!-- Section 3.22 -->
<H2>
<A NAME="Section3.22">3.22 Garbage Collection</A>
</H2>
<P> Garbage collection of the heap (global stack) is triggered when the heap becomes over 90% full or by making a call to <KBD>gc</KBD>. If the garbage collector does not cause the heap to drop below 90% full then the process terminates with a heap overflow error.
<P> Note that the garbage collector may "thrash" if it only recovers enough space for the heap to drop just below 90% full.

<P>Predicates:

<P><KBD><a name="gc"></a>gc</KBD>

<BLOCKQUOTE>
Trigger the garbage collector.
</BLOCKQUOTE>


<!-- Section 3.23 -->
<H2>
<A NAME="Section3.23">3.23 TCP/IP</A>
</H2>
It is expected that most communications between processes will be carried out
using Pedro communication. Where communication with applications such as FTP or HTTP servers are required, communications using sockets may be needed.
The predicates described in this section provide support for basic socket communication. 
<P> A simple example using these predicates is given in the examples directory.
<P>Predicates:

<P><KBD><a name="tcp_server"></a>tcp_server(Socket, Port)</KBD>
<BR><KBD>tcp_server(Socket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Open a socket using the specified <KBD>Port</KBD> and <KBD>IPAddress</KBD>.
This call is intended for setting up a socket that will be used
in the server end of some processing relationship.
If <KBD>Port</KBD> is zero then some unused port will be chosen.
<BR><KBD>mode tcp_server(-integer, +integer)</KBD>
<BR><KBD>mode tcp_server(-integer, +integer, +integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_client"></a>tcp_client(Port, IPAddress, Socket)</KBD>
<BLOCKQUOTE>
<P>Open a socket using the specified <KBD>Port</KBD> and <KBD>IPAddress</KBD>.
This call is intended for setting up a socket that will be used
in the client end of some processing relationship.
<BR><KBD>mode tcp_client(+integer, +integer, -integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_open"></a>tcp_open(Socket)</KBD>
<BLOCKQUOTE>
<P>Open a socket.
<BR><KBD>mode tcp_open(-integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_close"></a>tcp_close(Socket)</KBD>
<BLOCKQUOTE>
<P>Close a socket. This closes an opened input (output) stream for this socket.
<BR><KBD>mode tcp_close(+integer)</KBD>
</BLOCKQUOTE>


<P><KBD><a name="tcp_bind"></a>tcp_bind(Socket, Port)</KBD>
<BR><KBD>tcp_bind(Socket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Bind <KBD>Socket</KBD> to the specified <KBD>Port</KBD> and <KBD>IPAddress</KBD>.
If <KBD>Port</KBD> is zero then some unused port will be chosen.
<BR>Corresponds to the C function: bind(3N).
<BR><KBD>mode tcp_bind(+integer, +integer)</KBD>
<BR><KBD>mode tcp_bind(+integer, +integer, +integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_listen"></a>tcp_listen(Socket)</KBD>
<BLOCKQUOTE>
<P>Listen for a connection on the socket.
<BR>Corresponds to the C function: listen(3N).
<BR><KBD>mode tcp_listen(+integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_connect"></a>tcp_connect(Socket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Establish a connection between <KBD>Socket</KBD> and the specified <KBD>Port</KBD> and <KBD>IPAddress</KBD>.
<BR>Corresponds to the C function: connect(3N).
<BR><KBD>mode tcp_connect(+integer, +integer, +integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_accept"></a>tcp_accept(Socket, NewSocket)</KBD>
<BR><KBD>tcp_accept(Socket, NewSocket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Accept a connection to <KBD>Socket</KBD>.
<BR>Corresponds to the C function: accept(3N).
<BR><KBD>mode tcp_accept(@integer, -integer)</KBD>
<BR><KBD>mode tcp_accept(@integer, -integer, @integer, @integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="open_socket_stream"></a>open_socket_stream(Socket, IOMode, Stream)</KBD>
<BLOCKQUOTE> 
<P>Open a stream for reading or writing on <KBD>Socket</KBD>.
<BR><KBD>mode open_socket_stream(@integer, @atom, -integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_getsockname"></a>tcp_getsockname(Socket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Return the local port and IP address associated with the socket.
<BR>Corresponds to the C function: getsockname(3N)
<BR><KBD>mode tcp_getsockname(+integer, -integer, -integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_getpeername"></a>tcp_getpeername(Socket, Port, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Return the remote port and IP address associated with the socket.
<BR>Corresponds to the C function: getpeername(3N)
<BR><KBD>mode tcp_getpeername(+integer, -integer, -integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_host_to_ip_address"></a>tcp_host_to_ip_address(Name, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Look up the IP address of the given host.
<BR>Corresponds to the C function: nslookup(1N)
<BR><KBD>mode tcp_host_to_ip_address(+atom, -integer)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="tcp_host_from_ip_address"></a>tcp_host_from_ip_address(Name, IPAddress)</KBD>
<BLOCKQUOTE>
<P>Look up the host name of the given IP address.
<BR>Corresponds to the C function: nslookup(1N)
<BR><KBD>mode tcp_host_from_ip_address(-atom, +integer)</KBD>
</BLOCKQUOTE>



<!-- Section 3.24 -->
<H2>
<A NAME="Section3.24">3.24 CHR System</A>
</H2>
This section briefly describes the Qu-Prolog implementation
of the K.U.Leuven Constraint Handling Rules (CHR) system (see <KBD>http://www.cs.kuleuven.be/~dtai/projects/CHR/</KBD>). This implementation is reasonably consistent with that of SWI Prolog.

<P>
The syntax of CHR rules is given below.

<KBD>
<BR>
<BR>chr_rules --> chr_rule, chr_rules.
<BR>chr_rules --> [].
<BR>
<BR>chr_rule --> name, rule_part, pragma, ['.'].
<BR>
<BR>name --> atom, ['@'].
<BR>name --> [].
<BR>
<BR>rule_part --> simplification_rule.
<BR>rule_part --> propagation_rule.
<BR>rule_part --> simpagation_rule.
<BR>
<BR>simplification_rule --> head, ['<=>'], guard, body.
<BR>propagation_rule --> head, ['==>'], guard, body.
<BR>simpagation_rule --> head, ['\'], head, ['<=>'], guard, body.
<BR>
<BR>head --> constraints.
<BR>
<BR>constraints --> constraint, constraint_id.
<BR>constraints --> constraint, constraint_id, [','], constraints.
<BR>
<BR>constraint --> nonvar_term.
<BR>
<BR>constraint_id --> [].
<BR>constraint_id --> ['#'], variable.
<BR>constraint_id --> ['#', 'passive'] .
<BR>
<BR>guard --> [].
<BR>guard --> goal, ['|'].
<BR>
<BR>body --> goal.
<BR>
<BR>pragma --> [].
<BR>pragma --> ['pragma'], pragmas.
<BR>
<BR>pragmas --> pragma_part.
<BR>pragmas --> pragma_part, [','], pragmas.
<BR>
<BR>pragma_part --> ['passive('], variable, [')'].
</KBD>
<P>
The semantics of the rules are as follows.

<P>
Whenever a new constraint is added or some variable in an existing constraint
is bound (causing the constraint of be retried) then the constraint becomes 
'active'. The rules are then tried in order. If the active constraint together
with other ('passive') constraints match the head of a rule and the guard 
is true then the body of the rule is executed. Note that variables occurring
in the constraints are not allowed to be bound when matching against the rule
head or in the guard.
<P>
There are three rules types:

<UL type="disc">
<LI>Simplification
<BR>The matched head constraints are removed from the constraint store.
<LI>Propagation
<BR>The matched head constraints are not removed and the rule cannot be replied
to the same collection of constraints (in the same order) again.
<LI>Simpagation
<BR>The constraints before the <KBD>\</KBD> are retrained while the constraints
after the <KBD>\</KBD> are removed.
</UL>

The following examples are adapted from the reference above.

<KBD>
<BR>
<BR> %% CHR rules for less_than_or_equal
<BR>
<BR>:- chr_init.
<BR>
<BR>:- chr_constraint leq/2.
<BR>
<BR>reflexivity  @ leq(X,X) <=> true.
<BR>antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
<BR>idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.
<BR>transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).
</KBD>
<P>

The directive <KBD>chr_init</KBD> must occur before any 
CHR directives or rules. This loads the CHR operator declarations and enables
the term expansion rules to convert the rules to Qu-Prolog clauses.
<P>
The <KBD>chr_constraint</KBD> declares the allowed constraints. This is followed
by the required rules. Normal Qu-Prolog code can be freely intermixed with
CHR rules.
<P>
The next example uses the passive pragma.

<KBD>
<BR>
<BR>:- chr_init.
<BR>:- chr_constraint fibonacci/2.
<BR>
<BR>%% fibonacci(N,M) is true iff  M is the Nth Fibonacci number.
<BR>
<BR>fibonacci(N,M1) # Id \ fibonacci(N,M2) <=> var(M2) | M1 = M2 pragma passive(Id).
<BR>
<BR>fibonacci(0,M) ==> M = 1.
<BR>
<BR>fibonacci(1,M) ==> M = 1.
<BR>
<BR>fibonacci(N,M) ==> N > 1 |
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N1 is N-1,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fibonacci(N1,M1),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N2 is N-2,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fibonacci(N2,M2),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M is M1 + M2.
</KBD>
<P>
In this example, the first constraint in the first rule can only be passive.

<!-- Section 3.25 -->
<H2>
<A NAME="Section3.25">3.24 Miscellaneous</A>
</H2>

<P>Predicates:

<P><KBD><a name="os"></a>os(Term)</KBD>
<BLOCKQUOTE>
Access the operating system.

<P>The possible values for <KBD>Term</KBD> are

<UL type="disc">
<LI>
<KBD>access(File, Mode)</KBD>
<BR>The same as <KBD>access(File, Mode, 0)</KBD>.
<LI>
<KBD>argv(Args)</KBD>
<BR>The same as <KBD><a href="#get_args">get_args/1</a></KBD>.
<LI>
<KBD>exit(Integer)</KBD>
<BR>The same as <KBD><a href="#halt">halt/1</a></KBD>.
<LI>
<KBD>mktemp(Atom, File)</KBD>
<BR>Call the Unix system call <KBD>mktemp(3)</KBD> which returns a unique file name, <KBD>File</KBD>. The name is derived from the <KBD>Atom</KBD> which must have six trailing <KBD>X</KBD>s.
<LI>
<KBD>system(Cmd)</KBD>
<BR>Execute the  <KBD>Cmd</KBD> using <KBD>/bin/sh</KBD>.
<LI>
<KBD>system(Cmd, Status)</KBD>
<BR>Execute the <KBD>Cmd</KBD> and return exit code in <KBD>Status</KBD> using <KBD>/bin/sh</KBD>.
</UL>

<BR><KBD>mode os(+compound)</KBD>

<P>Example:

<KBD>
<P>| ?- os(mktemp(fileXXXXXX, File)).
<BR>
<BR>File = filenCwJaB
<BR>
<BR>| ?- os(system(date)).
<BR>Tue Jan 11 14:40:04 EST 2000
<BR>
<BR>yes
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="current_prolog_flag"></a>current_prolog_flag(Flag, Value)</KBD>

<BLOCKQUOTE>
Extract the <KBD>Value</KBD> of the prolog <KBD>Flag</KBD>. Currently, the only flag is <KBD>version</KBD> -- the version number of Qu-Prolog.

<BR><KBD>mode current_prolog_flag(@atom, ?term)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="interpreter"></a>interpreter</KBD>

<BLOCKQUOTE>
Start the standard Qu-Prolog interpreter. This is useful for stand-alone applications that need an interpreter as part of the processing.

<BR><KBD>mode interpreter</KBD>

</BLOCKQUOTE>

<P><KBD><a name="chdir"></a>chdir(Dir)</KBD>

<BLOCKQUOTE>
Change directory to that given by the atom <KBD>Dir</KBD>. 

<BR><KBD>mode chdir(@atom)</KBD>

<P>Example:

<KBD>
<P>| ?- chdir('..').
</KBD>
<P> changes to the parent directory.
</BLOCKQUOTE>

<P><KBD><a name="getcwd"></a>getcwd(Dir)</KBD>

<BLOCKQUOTE>
Get the current working directory. 

<BR><KBD>mode getcwd(-atom)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="working_directory"></a>working_directory(Dir)</KBD>
<BR><KBD>working_directory(OldDir, NewDir)</KBD>

<BLOCKQUOTE>
Get/set the current working directory with <KBD>working_directory(Dir)</KBD>. If <KBD>Dir</KBD> is a variable then it is set to the working
directory. Otherwise it should be an atom representing a directory, in which case the working directory is set to <KBD>Dir</KBD>.
<BR><KBD>working_directory(OldDir, NewDir)</KBD> sets the working directory.
<KBD>NewDir</KBD> is the new 
working directory
and <KBD>OldDir</KBD> is previous working directory.  
<BR>These are interfaces to <KBD>chdir</KBD> and <KBD>getcwd</KBD>.  

<BR><KBD>mode working_directory(?atom)</KBD>
<BR><KBD>mode working_directory(-atom, @atom)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="absolute_file_name"></a>absolute_file_name(File, Path)</KBD>

<BLOCKQUOTE>
Expand <KBD>File</KBD> (file or directory) to its full path (<KBD>Path</KBD>). Enviroment variables,
<KBD>~</KBD>,  <KBD>.</KBD> and <KBD>..</KBD> are expanded.  

<BR><KBD>mode absolute_file_name(+atom, -atom)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="file_directory_name"></a>file_directory_name(File, Path)</KBD>

<BLOCKQUOTE>
Expand <KBD>File</KBD> (file or directory) to its full path and return the directory (<KBD>Path</KBD>). Enviroment variables,
<KBD>~</KBD>,  <KBD>.</KBD> and <KBD>..</KBD> are expanded.  

<BR><KBD>mode file_directory_name(+atom, -atom)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="file_base_name"></a>file_base_name(File, FileBase)</KBD>

<BLOCKQUOTE>
Expand <KBD>File</KBD> (file or directory) to its full path and return the file base name (<KBD>FileBase</KBD>). Enviroment variables,
<KBD>~</KBD>,  <KBD>.</KBD> and <KBD>..</KBD> are expanded.  

<BR><KBD>mode file_directory_name(+atom, -atom)</KBD>

</BLOCKQUOTE>



<P><KBD><a name="getenv"></a>getenv(EnvVar, Value)</KBD>

<BLOCKQUOTE>
Get the environment variable <KBD>EnvVar</KBD> and unify with <KBD>Value</KBD>.

<BR><KBD>mode getenv(+atom, -atom)</KBD>

</BLOCKQUOTE>

<P><KBD><a name="setenv"></a>setenv(EnvVar, Value)</KBD>

<BLOCKQUOTE>
Set the environment variable <KBD>EnvVar</KBD> to <KBD>Value</KBD>.

<BR><KBD>mode setenv(+atom, +atom)</KBD>

</BLOCKQUOTE>



<P><KBD><a name="prompt"></a>prompt(Variable, Atom)</KBD>

<BLOCKQUOTE>
The current prompt is returned in <KBD>Variable</KBD> before setting the prompt to <KBD>Atom</KBD>.  The prompt is reset to the previous value on backtracking.
<BR><KBD>mode prompt(?atom, @atom)</KBD>

<P>Example:

<KBD>
<P>| ?- prompt(P, atom), write(P), nl, prompt(P2, P).
<BR>| ?-
<BR>
<BR>P = | ?-
<BR>P2 = atom
</KBD>
</BLOCKQUOTE>
<P><KBD><a name="realtime"></a>realtime(Time)</KBD>
 
<BLOCKQUOTE>
The argument is unified with the current time given as the number of seconds since the Unix epoch. It
has the same semantics as the Unix C function <KBD>time(2)</KBD>.
<BR><KBD>mode realtime(?integer)</KBD>
</BLOCKQUOTE> 

<P><KBD><a name="gmtime"></a>gmtime(Time, GMTime)</KBD>
 
<BLOCKQUOTE>
<KBD>gmtime(Time, GMTime)</KBD> is true if and only if <KBD>GMTime</KBD> is a compound term of the form
<BR><KBD>time(Year, Month, Day, Hour, Min, Sec)</KBD>
<BR>that corresponds to the GMT time for <KBD>Time</KBD> as the number of seconds since the Unix epoch.
When <KBD>Time</KBD> is given, it has the same semantics as the Unix C function <KBD>gmtime</KBD>.
<BR><KBD>mode gmtime(@integer, ?compound)</KBD>
<BR><KBD>mode gmtime(?integer, +compound)</KBD>

<P>Example:
 
<KBD>
<P>| ?- gmtime(ET, time(100, 5, 6, 10, 5, 20)).
<BR>
<BR>ET = 960285920
<BR>
<BR>| ?- gmtime(960285920,GT).
<BR> 
<BR>GT = time(100, 5, 6, 10, 5, 20)
</KBD>
</BLOCKQUOTE>

<P><KBD><a name="localtime"></a>localtime(Time, GMTime)</KBD>
 
<BLOCKQUOTE>
<KBD>localtime(Time, LTime)</KBD> is true if and only if <KBD>LTime</KBD> is a compound term of the form
<BR><KBD>time(Year, Month, Day, Hour, Min, Sec, IsDS)</KBD>
<BR>that corresponds to the local time for <KBD>Time</KBD> as the number of seconds since the Unix epoch.
When <KBD>Time</KBD> is given, it has the same semantics as the Unix C function <KBD>localtime</KBD>.
<BR><KBD>mode localtime(@integer, ?compound)</KBD>
<BR><KBD>mode localtime(?integer, +compound)</KBD>
</BLOCKQUOTE>

<P><KBD><a name="gettimeofday"></a>gettimeofday(Time)</KBD>
 
<BLOCKQUOTE>
The argument is unified with the current time given as the number of seconds since the Unix epoch. It is similar to <KBD>realtime</KBD> except it contains the fractional part of the time 
<BR><KBD>mode gettimeofday(?double)</KBD>
</BLOCKQUOTE> 

<P><KBD><a name="create_timer"></a>create_timer(Goal, Time, OneTime, ID)</KBD>
 
<BLOCKQUOTE>
This creates a timer that in <KBD>Time</KBD> seconds will call <KBD>Goal</KBD>. If 
<KBD>OneTime</KBD> is <KBD>true</KBD> then the timer will be deleted  when the goal is called.
Otherwise, the timer will reset so that the goal is repeadly called every <KBD>Time</KBD> seconds. <KBD>ID</KBD> is a unique ID given to the timer. When the thread that created the timer
exists then all its timers will be removed. The goal will be called once and then failed over and so
the goal should have a side-effect such as database modification. If an exception is thrown in 
the goal then the entire process terminates.


<BR><KBD>mode create_timer(+goal, @number, @term, -integer)</KBD>

</BLOCKQUOTE>
<P><KBD><a name="delete_timer"></a>delete_timer(ID)</KBD>
 
<BLOCKQUOTE>
Delete the timer with the given ID. This thread must be the the thread that created the timer.
<BR><KBD>mode delete_timer(@integer)</KBD>
</BLOCKQUOTE>



<HR>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="0">
<TR>
<TD width="15%" align="center" valign="top"><a href="TOC.html" target="main">Table of Contents</a></TD>
<TD width="14%" align="center" valign="top"><a href="SEC1.html" target="main">Getting Started</a></TD>
<TD width="14%" align="center" valign="top"><a href="SEC2.html" target="main">Syntax</a></TD>
<TD width="14%" align="center" valign="top"><a href="SEC3.html" target="main">Built-in Predicates</a></TD>
<TD width="14%" align="center" valign="top"><a href="SEC4.html" target="main">Standard Operators</a></TD>
<TD width="14%" align="center" valign="top"><a href="SEC5.html" target="main">Notation</a></TD>
<TD width="15%" align="center" valign="top"><a href="INDEX.html" target="main">Index</a></TD>
</TR>
</TABLE>

</BODY>
</HTML>
